
OpeniCELink.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000066e4  0800010c  0800010c  0001010c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000001e8  080067f0  080067f0  000167f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080069d8  080069d8  00020184  2**0
                  CONTENTS
  4 .ARM          00000000  080069d8  080069d8  00020184  2**0
                  CONTENTS
  5 .preinit_array 00000000  080069d8  080069d8  00020184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080069d8  080069d8  000169d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080069dc  080069dc  000169dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000184  20000000  080069e0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000e9c  20000188  08006b64  00020188  2**3
                  ALLOC
 10 ._user_heap_stack 00001404  20001024  08006b64  00021024  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020184  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001addd  00000000  00000000  000201ad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000051ba  00000000  00000000  0003af8a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    000119f2  00000000  00000000  00040144  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000ed8  00000000  00000000  00051b38  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00002bb0  00000000  00000000  00052a10  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0001c5b7  00000000  00000000  000555c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0001e04d  00000000  00000000  00071b77  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0008b4ed  00000000  00000000  0008fbc4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000050  00000000  00000000  0011b0b1  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00003264  00000000  00000000  0011b104  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800010c <__do_global_dtors_aux>:
 800010c:	b510      	push	{r4, lr}
 800010e:	4c05      	ldr	r4, [pc, #20]	; (8000124 <__do_global_dtors_aux+0x18>)
 8000110:	7823      	ldrb	r3, [r4, #0]
 8000112:	b933      	cbnz	r3, 8000122 <__do_global_dtors_aux+0x16>
 8000114:	4b04      	ldr	r3, [pc, #16]	; (8000128 <__do_global_dtors_aux+0x1c>)
 8000116:	b113      	cbz	r3, 800011e <__do_global_dtors_aux+0x12>
 8000118:	4804      	ldr	r0, [pc, #16]	; (800012c <__do_global_dtors_aux+0x20>)
 800011a:	f3af 8000 	nop.w
 800011e:	2301      	movs	r3, #1
 8000120:	7023      	strb	r3, [r4, #0]
 8000122:	bd10      	pop	{r4, pc}
 8000124:	20000188 	.word	0x20000188
 8000128:	00000000 	.word	0x00000000
 800012c:	080067d8 	.word	0x080067d8

08000130 <frame_dummy>:
 8000130:	b508      	push	{r3, lr}
 8000132:	4b03      	ldr	r3, [pc, #12]	; (8000140 <frame_dummy+0x10>)
 8000134:	b11b      	cbz	r3, 800013e <frame_dummy+0xe>
 8000136:	4903      	ldr	r1, [pc, #12]	; (8000144 <frame_dummy+0x14>)
 8000138:	4803      	ldr	r0, [pc, #12]	; (8000148 <frame_dummy+0x18>)
 800013a:	f3af 8000 	nop.w
 800013e:	bd08      	pop	{r3, pc}
 8000140:	00000000 	.word	0x00000000
 8000144:	2000018c 	.word	0x2000018c
 8000148:	080067d8 	.word	0x080067d8

0800014c <w25_init>:
/* w25_init use for initialize the struct to store SPI bus, CS pin GPIO band and number.
 * also use for probing for the SPI NOR chip by detecting the JEDEC ID respond
 *
 */
uint8_t w25_init(W25QXX *w25q, SPI_HandleTypeDef *SPIbus,
		GPIO_TypeDef *CSBANK, uint16_t CS_PIN){
 800014c:	b530      	push	{r4, r5, lr}
	w25q->SPIbus = SPIbus;
	w25q->CSBANK = CSBANK;
	w25q->CS_PIN = CS_PIN;

	// probe JEDEC
	uint8_t tempbuf[4] = {W25_CMD_JDEC, 0, 0, 0};
 800014e:	259f      	movs	r5, #159	; 0x9f
		GPIO_TypeDef *CSBANK, uint16_t CS_PIN){
 8000150:	4694      	mov	ip, r2
 8000152:	4604      	mov	r4, r0
 8000154:	b085      	sub	sp, #20
	uint8_t tempbuf[4] = {W25_CMD_JDEC, 0, 0, 0};
 8000156:	9503      	str	r5, [sp, #12]
	// CE Low
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);

	// Send command and receive the data at the same time.
	HAL_SPI_TransmitReceive(w25q->SPIbus, tempbuf, tempbuf, 4, 100);
 8000158:	2564      	movs	r5, #100	; 0x64
		GPIO_TypeDef *CSBANK, uint16_t CS_PIN){
 800015a:	4660      	mov	r0, ip
	w25q->CSBANK = CSBANK;
 800015c:	e9c4 1c00 	strd	r1, ip, [r4]
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 8000160:	2200      	movs	r2, #0
 8000162:	4619      	mov	r1, r3
	w25q->CS_PIN = CS_PIN;
 8000164:	8123      	strh	r3, [r4, #8]
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 8000166:	f001 f86d 	bl	8001244 <HAL_GPIO_WritePin>
	HAL_SPI_TransmitReceive(w25q->SPIbus, tempbuf, tempbuf, 4, 100);
 800016a:	aa03      	add	r2, sp, #12
 800016c:	2304      	movs	r3, #4
 800016e:	4611      	mov	r1, r2
 8000170:	6820      	ldr	r0, [r4, #0]
 8000172:	9500      	str	r5, [sp, #0]
 8000174:	f002 fd74 	bl	8002c60 <HAL_SPI_TransmitReceive>

	// CE High
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);
 8000178:	2201      	movs	r2, #1
 800017a:	8921      	ldrh	r1, [r4, #8]
 800017c:	6860      	ldr	r0, [r4, #4]
 800017e:	f001 f861 	bl	8001244 <HAL_GPIO_WritePin>

	// Chip checking.
	switch(tempbuf[1]){
 8000182:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8000186:	3b01      	subs	r3, #1
 8000188:	b2db      	uxtb	r3, r3
 800018a:	2bfd      	cmp	r3, #253	; 0xfd
 800018c:	d807      	bhi.n	800019e <w25_init+0x52>
		default:// else it's just unknown chip, maybe some other brand.
			break ;// Unknown chip.
	}

	// store the capacity in byte uint.
	w25q->flash_capa = 1 << tempbuf[3]; // store the flash size in byte unit.
 800018e:	2301      	movs	r3, #1
	return 0;
 8000190:	2000      	movs	r0, #0
	w25q->flash_capa = 1 << tempbuf[3]; // store the flash size in byte unit.
 8000192:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8000196:	4093      	lsls	r3, r2
 8000198:	60e3      	str	r3, [r4, #12]
}
 800019a:	b005      	add	sp, #20
 800019c:	bd30      	pop	{r4, r5, pc}
	switch(tempbuf[1]){
 800019e:	2001      	movs	r0, #1
}
 80001a0:	b005      	add	sp, #20
 80001a2:	bd30      	pop	{r4, r5, pc}

080001a4 <w25_writeMode>:
 */
void w25_writeMode(W25QXX *w25q, uint8_t onoff){
	uint8_t CMD = onoff ? W25_CMD_WREN : W25_CMD_WRDS;

	// CE Low
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 80001a4:	2200      	movs	r2, #0
	uint8_t CMD = onoff ? W25_CMD_WREN : W25_CMD_WRDS;
 80001a6:	4291      	cmp	r1, r2
void w25_writeMode(W25QXX *w25q, uint8_t onoff){
 80001a8:	b510      	push	{r4, lr}
	uint8_t CMD = onoff ? W25_CMD_WREN : W25_CMD_WRDS;
 80001aa:	bf14      	ite	ne
 80001ac:	2306      	movne	r3, #6
 80001ae:	2304      	moveq	r3, #4
void w25_writeMode(W25QXX *w25q, uint8_t onoff){
 80001b0:	4604      	mov	r4, r0
 80001b2:	b082      	sub	sp, #8
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 80001b4:	8901      	ldrh	r1, [r0, #8]
 80001b6:	6840      	ldr	r0, [r0, #4]
	uint8_t CMD = onoff ? W25_CMD_WREN : W25_CMD_WRDS;
 80001b8:	f88d 3007 	strb.w	r3, [sp, #7]
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 80001bc:	f001 f842 	bl	8001244 <HAL_GPIO_WritePin>

	// send command to enable or disable flash writing.
	HAL_SPI_Transmit(w25q->SPIbus, &CMD, 1, 100);
 80001c0:	2364      	movs	r3, #100	; 0x64
 80001c2:	f10d 0107 	add.w	r1, sp, #7
 80001c6:	2201      	movs	r2, #1
 80001c8:	6820      	ldr	r0, [r4, #0]
 80001ca:	f002 fc1b 	bl	8002a04 <HAL_SPI_Transmit>

	// CE High
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);
 80001ce:	2201      	movs	r2, #1
 80001d0:	8921      	ldrh	r1, [r4, #8]
 80001d2:	6860      	ldr	r0, [r4, #4]
 80001d4:	f001 f836 	bl	8001244 <HAL_GPIO_WritePin>
}
 80001d8:	b002      	add	sp, #8
 80001da:	bd10      	pop	{r4, pc}

080001dc <w25_write>:
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);

	return 0;
}

uint8_t w25_write(W25QXX *w25q,uint8_t *data, uint32_t datsize){
 80001dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if(datsize > w25q->flash_capa)// never write beyond the flash capacity!
 80001e0:	68c3      	ldr	r3, [r0, #12]
uint8_t w25_write(W25QXX *w25q,uint8_t *data, uint32_t datsize){
 80001e2:	b083      	sub	sp, #12
	if(datsize > w25q->flash_capa)// never write beyond the flash capacity!
 80001e4:	4293      	cmp	r3, r2
 80001e6:	d35a      	bcc.n	800029e <w25_write+0xc2>
		return 1;

	uint16_t page_num = datsize / 256;// check for how many page-aligned data.
 80001e8:	f3c2 280f 	ubfx	r8, r2, #8, #16
	uint8_t page_remain = datsize % 256;// if the data isn't page aligned, all the rest data will be flash separately.
 80001ec:	4604      	mov	r4, r0
 80001ee:	460d      	mov	r5, r1
	uint16_t page_num = datsize / 256;// check for how many page-aligned data.
 80001f0:	0a16      	lsrs	r6, r2, #8
	uint8_t page_remain = datsize % 256;// if the data isn't page aligned, all the rest data will be flash separately.
 80001f2:	b2d7      	uxtb	r7, r2
	uint16_t last_page = 0;// store last page-aligned address for the non-aligned byte.

	for(uint16_t pages = 0; pages < page_num; pages++){
 80001f4:	f1b8 0f00 	cmp.w	r8, #0
 80001f8:	d056      	beq.n	80002a8 <w25_write+0xcc>
	uint8_t CMD[4] = {
 80001fa:	f04f 0902 	mov.w	r9, #2
 80001fe:	f108 38ff 	add.w	r8, r8, #4294967295
 8000202:	b2b6      	uxth	r6, r6
 8000204:	fa1f f888 	uxth.w	r8, r8
 8000208:	eb01 2606 	add.w	r6, r1, r6, lsl #8
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 800020c:	2200      	movs	r2, #0
 800020e:	8921      	ldrh	r1, [r4, #8]
 8000210:	6860      	ldr	r0, [r4, #4]
	uint8_t CMD[4] = {
 8000212:	f8cd 9004 	str.w	r9, [sp, #4]
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 8000216:	f001 f815 	bl	8001244 <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(w25q->SPIbus, CMD, 4, 100);
 800021a:	2204      	movs	r2, #4
 800021c:	2364      	movs	r3, #100	; 0x64
 800021e:	eb0d 0102 	add.w	r1, sp, r2
 8000222:	6820      	ldr	r0, [r4, #0]
 8000224:	f002 fbee 	bl	8002a04 <HAL_SPI_Transmit>
	HAL_SPI_Transmit(w25q->SPIbus, buffer, bufsize, 100);
 8000228:	4629      	mov	r1, r5
 800022a:	2364      	movs	r3, #100	; 0x64
 800022c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000230:	6820      	ldr	r0, [r4, #0]
 8000232:	f002 fbe7 	bl	8002a04 <HAL_SPI_Transmit>
		w25_pageWrite(w25q, pages*256, data, 256);
		data += 256;// move to next 256 bytes.
 8000236:	f505 7580 	add.w	r5, r5, #256	; 0x100
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);
 800023a:	2201      	movs	r2, #1
 800023c:	8921      	ldrh	r1, [r4, #8]
 800023e:	6860      	ldr	r0, [r4, #4]
 8000240:	f001 f800 	bl	8001244 <HAL_GPIO_WritePin>
	for(uint16_t pages = 0; pages < page_num; pages++){
 8000244:	42b5      	cmp	r5, r6
 8000246:	d1e1      	bne.n	800020c <w25_write+0x30>
		last_page = pages;
	}

	if(page_remain)
 8000248:	b91f      	cbnz	r7, 8000252 <w25_write+0x76>
		w25_pageWrite(w25q, last_page + 256, data, page_remain);

	return 0;
}
 800024a:	4638      	mov	r0, r7
 800024c:	b003      	add	sp, #12
 800024e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t CMD[4] = {
 8000252:	2500      	movs	r5, #0
 8000254:	2302      	movs	r3, #2
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 8000256:	462a      	mov	r2, r5
 8000258:	8921      	ldrh	r1, [r4, #8]
 800025a:	6860      	ldr	r0, [r4, #4]
	uint8_t CMD[4] = {
 800025c:	f88d 3004 	strb.w	r3, [sp, #4]
			(uint8_t)(addr)// page address [7 - 0]
 8000260:	f88d 8007 	strb.w	r8, [sp, #7]
	uint8_t CMD[4] = {
 8000264:	f88d 5005 	strb.w	r5, [sp, #5]
 8000268:	f88d 5006 	strb.w	r5, [sp, #6]
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 800026c:	f000 ffea 	bl	8001244 <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(w25q->SPIbus, CMD, 4, 100);
 8000270:	2204      	movs	r2, #4
 8000272:	2364      	movs	r3, #100	; 0x64
 8000274:	eb0d 0102 	add.w	r1, sp, r2
 8000278:	6820      	ldr	r0, [r4, #0]
 800027a:	f002 fbc3 	bl	8002a04 <HAL_SPI_Transmit>
	HAL_SPI_Transmit(w25q->SPIbus, buffer, bufsize, 100);
 800027e:	463a      	mov	r2, r7
	return 0;
 8000280:	462f      	mov	r7, r5
	HAL_SPI_Transmit(w25q->SPIbus, buffer, bufsize, 100);
 8000282:	2364      	movs	r3, #100	; 0x64
 8000284:	4631      	mov	r1, r6
 8000286:	6820      	ldr	r0, [r4, #0]
 8000288:	f002 fbbc 	bl	8002a04 <HAL_SPI_Transmit>
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);
 800028c:	6860      	ldr	r0, [r4, #4]
 800028e:	2201      	movs	r2, #1
 8000290:	8921      	ldrh	r1, [r4, #8]
 8000292:	f000 ffd7 	bl	8001244 <HAL_GPIO_WritePin>
}
 8000296:	4638      	mov	r0, r7
 8000298:	b003      	add	sp, #12
 800029a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return 1;
 800029e:	2701      	movs	r7, #1
}
 80002a0:	4638      	mov	r0, r7
 80002a2:	b003      	add	sp, #12
 80002a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for(uint16_t pages = 0; pages < page_num; pages++){
 80002a8:	460e      	mov	r6, r1
	if(page_remain)
 80002aa:	2f00      	cmp	r7, #0
 80002ac:	d0cd      	beq.n	800024a <w25_write+0x6e>
 80002ae:	e7d0      	b.n	8000252 <w25_write+0x76>

080002b0 <w25_erase32K>:

/* Erase data in 1 block (32KBytes) size
 * Select the start address of that sector to erase.
 */
uint8_t w25_erase32K(W25QXX *w25q, uint32_t addr){
	if(addr > w25q->flash_capa)// never read from address beyond the boundary!
 80002b0:	68c2      	ldr	r2, [r0, #12]
 80002b2:	428a      	cmp	r2, r1
 80002b4:	d201      	bcs.n	80002ba <w25_erase32K+0xa>
			return 1;
 80002b6:	2001      	movs	r0, #1

	// CE High
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);

	return 0;
}
 80002b8:	4770      	bx	lr
uint8_t w25_erase32K(W25QXX *w25q, uint32_t addr){
 80002ba:	b530      	push	{r4, r5, lr}
	uint8_t CMD[4] = {
 80002bc:	2500      	movs	r5, #0
 80002be:	f04f 0c52 	mov.w	ip, #82	; 0x52
 80002c2:	460b      	mov	r3, r1
uint8_t w25_erase32K(W25QXX *w25q, uint32_t addr){
 80002c4:	b083      	sub	sp, #12
 80002c6:	4604      	mov	r4, r0
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 80002c8:	462a      	mov	r2, r5
 80002ca:	8901      	ldrh	r1, [r0, #8]
 80002cc:	6840      	ldr	r0, [r0, #4]
	uint8_t CMD[4] = {
 80002ce:	f88d c004 	strb.w	ip, [sp, #4]
				(uint8_t)(addr)// page address [7 - 0]
 80002d2:	f88d 3007 	strb.w	r3, [sp, #7]
	uint8_t CMD[4] = {
 80002d6:	f88d 5005 	strb.w	r5, [sp, #5]
 80002da:	f88d 5006 	strb.w	r5, [sp, #6]
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_RESET);
 80002de:	f000 ffb1 	bl	8001244 <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(w25q->SPIbus, CMD, 4, 100);
 80002e2:	2204      	movs	r2, #4
 80002e4:	2364      	movs	r3, #100	; 0x64
 80002e6:	eb0d 0102 	add.w	r1, sp, r2
 80002ea:	6820      	ldr	r0, [r4, #0]
 80002ec:	f002 fb8a 	bl	8002a04 <HAL_SPI_Transmit>
	HAL_GPIO_WritePin(w25q->CSBANK, w25q->CS_PIN, GPIO_PIN_SET);
 80002f0:	6860      	ldr	r0, [r4, #4]
 80002f2:	2201      	movs	r2, #1
 80002f4:	8921      	ldrh	r1, [r4, #8]
 80002f6:	f000 ffa5 	bl	8001244 <HAL_GPIO_WritePin>
	return 0;
 80002fa:	4628      	mov	r0, r5
}
 80002fc:	b003      	add	sp, #12
 80002fe:	bd30      	pop	{r4, r5, pc}

08000300 <__io_putchar>:
static void MX_SPI1_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */

PUTCHAR_PROTOTYPE
{
 8000300:	b500      	push	{lr}
 8000302:	b083      	sub	sp, #12
 8000304:	9001      	str	r0, [sp, #4]
  /* Place your implementation of fputc here */
  /* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */
  HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF);
 8000306:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800030a:	2201      	movs	r2, #1
 800030c:	a901      	add	r1, sp, #4
 800030e:	4803      	ldr	r0, [pc, #12]	; (800031c <__io_putchar+0x1c>)
 8000310:	f002 fe48 	bl	8002fa4 <HAL_UART_Transmit>

  return ch;
}
 8000314:	9801      	ldr	r0, [sp, #4]
 8000316:	b003      	add	sp, #12
 8000318:	f85d fb04 	ldr.w	pc, [sp], #4
 800031c:	20000258 	.word	0x20000258

08000320 <ice_mkfs>:
/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */


// Drive mkfs
void ice_mkfs(){
 8000320:	b5f0      	push	{r4, r5, r6, r7, lr}
	const uint8_t ms_fat12[62] = {
 8000322:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 80003d0 <ice_mkfs+0xb0>
void ice_mkfs(){
 8000326:	b095      	sub	sp, #84	; 0x54
	const uint8_t ms_fat12[62] = {
 8000328:	f10d 0c10 	add.w	ip, sp, #16
 800032c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}

		HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError);

		for(uint8_t i=0; i < 62; i+= 2){// Write Boot sector (BIOS Parameter Block) to the internal Flash.
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD,
					FLASH_MEM_BASE_ADDR + i, (ms_fat12[i] | ms_fat12[i+1] << 8)); // flash modified data onto Flash memory.
 8000330:	f10c 4578 	add.w	r5, ip, #4160749568	; 0xf8000000
	const uint8_t ms_fat12[62] = {
 8000334:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8000338:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800033c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8000340:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8000344:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8000348:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
 800034c:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8000350:	f8ac 3000 	strh.w	r3, [ip]
		HAL_FLASH_Unlock();
 8000354:	f000 fd9c 	bl	8000e90 <HAL_FLASH_Unlock>
		EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; // erase 1024 KBytes (which is the size of 1 page).
 8000358:	2300      	movs	r3, #0
 800035a:	481e      	ldr	r0, [pc, #120]	; (80003d4 <ice_mkfs+0xb4>)
		EraseInitStruct.PageAddress = FLASH_MEM_BASE_ADDR; // We start erase from the beginning of sector.
 800035c:	4a1e      	ldr	r2, [pc, #120]	; (80003d8 <ice_mkfs+0xb8>)
		EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; // erase 1024 KBytes (which is the size of 1 page).
 800035e:	6003      	str	r3, [r0, #0]
		EraseInitStruct.PageAddress = FLASH_MEM_BASE_ADDR; // We start erase from the beginning of sector.
 8000360:	2340      	movs	r3, #64	; 0x40
 8000362:	4f1e      	ldr	r7, [pc, #120]	; (80003dc <ice_mkfs+0xbc>)
 8000364:	e9c0 2302 	strd	r2, r3, [r0, #8]
		HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError);
 8000368:	491d      	ldr	r1, [pc, #116]	; (80003e0 <ice_mkfs+0xc0>)
 800036a:	4c1b      	ldr	r4, [pc, #108]	; (80003d8 <ice_mkfs+0xb8>)
		for(uint8_t i=0; i < 62; i+= 2){// Write Boot sector (BIOS Parameter Block) to the internal Flash.
 800036c:	4e1d      	ldr	r6, [pc, #116]	; (80003e4 <ice_mkfs+0xc4>)
					FLASH_MEM_BASE_ADDR + i, (ms_fat12[i] | ms_fat12[i+1] << 8)); // flash modified data onto Flash memory.
 800036e:	f5a5 457c 	sub.w	r5, r5, #64512	; 0xfc00
 8000372:	446f      	add	r7, sp
		HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError);
 8000374:	f000 fdf6 	bl	8000f64 <HAL_FLASHEx_Erase>
					FLASH_MEM_BASE_ADDR + i, (ms_fat12[i] | ms_fat12[i+1] << 8)); // flash modified data onto Flash memory.
 8000378:	f814 c007 	ldrb.w	ip, [r4, r7]
 800037c:	5d62      	ldrb	r2, [r4, r5]
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD,
 800037e:	4621      	mov	r1, r4
 8000380:	2300      	movs	r3, #0
 8000382:	2001      	movs	r0, #1
 8000384:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
		for(uint8_t i=0; i < 62; i+= 2){// Write Boot sector (BIOS Parameter Block) to the internal Flash.
 8000388:	3402      	adds	r4, #2
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD,
 800038a:	f000 fc97 	bl	8000cbc <HAL_FLASH_Program>
		for(uint8_t i=0; i < 62; i+= 2){// Write Boot sector (BIOS Parameter Block) to the internal Flash.
 800038e:	42b4      	cmp	r4, r6
 8000390:	d1f2      	bne.n	8000378 <ice_mkfs+0x58>
		}

		HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, FLASH_MEM_BASE_ADDR + 510, 0xAA55);// Write the signature of FAT file system at the end of sector 0.
 8000392:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8000396:	2300      	movs	r3, #0
 8000398:	4913      	ldr	r1, [pc, #76]	; (80003e8 <ice_mkfs+0xc8>)
 800039a:	2001      	movs	r0, #1
 800039c:	f000 fc8e 	bl	8000cbc <HAL_FLASH_Program>

		// Set Label name at the beginning of sector 3.
		const uint8_t ice_label[12] = {'I', 'C', 'E', 'B', 'L', 'A', 'S', 'T', 'E', 'R', ' ', 0xFF};
 80003a0:	ab01      	add	r3, sp, #4
 80003a2:	461d      	mov	r5, r3
 80003a4:	4a11      	ldr	r2, [pc, #68]	; (80003ec <ice_mkfs+0xcc>)
 80003a6:	4c12      	ldr	r4, [pc, #72]	; (80003f0 <ice_mkfs+0xd0>)
 80003a8:	ca07      	ldmia	r2, {r0, r1, r2}
 80003aa:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		for(uint8_t i =0; i < 12; i+= 2)
 80003ae:	4f11      	ldr	r7, [pc, #68]	; (80003f4 <ice_mkfs+0xd4>)
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, FLASH_MEM_BASE_ADDR + 1024+512+i, (ice_label[i] | ice_label[i+1] << 8));
 80003b0:	786e      	ldrb	r6, [r5, #1]
 80003b2:	f815 2b02 	ldrb.w	r2, [r5], #2
 80003b6:	4621      	mov	r1, r4
 80003b8:	2300      	movs	r3, #0
 80003ba:	2001      	movs	r0, #1
 80003bc:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
		for(uint8_t i =0; i < 12; i+= 2)
 80003c0:	3402      	adds	r4, #2
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, FLASH_MEM_BASE_ADDR + 1024+512+i, (ice_label[i] | ice_label[i+1] << 8));
 80003c2:	f000 fc7b 	bl	8000cbc <HAL_FLASH_Program>
		for(uint8_t i =0; i < 12; i+= 2)
 80003c6:	42bc      	cmp	r4, r7
 80003c8:	d1f2      	bne.n	80003b0 <ice_mkfs+0x90>
}
 80003ca:	b015      	add	sp, #84	; 0x54
 80003cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80003ce:	bf00      	nop
 80003d0:	080067f0 	.word	0x080067f0
 80003d4:	200001a8 	.word	0x200001a8
 80003d8:	0800fc00 	.word	0x0800fc00
 80003dc:	f7ff0411 	.word	0xf7ff0411
 80003e0:	200001b8 	.word	0x200001b8
 80003e4:	0800fc3e 	.word	0x0800fc3e
 80003e8:	0800fdfe 	.word	0x0800fdfe
 80003ec:	08006830 	.word	0x08006830
 80003f0:	08010200 	.word	0x08010200
 80003f4:	0801020c 	.word	0x0801020c

080003f8 <SystemClock_Config>:
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80003f8:	2300      	movs	r3, #0
{
 80003fa:	b5d0      	push	{r4, r6, r7, lr}
 80003fc:	b094      	sub	sp, #80	; 0x50
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80003fe:	2601      	movs	r6, #1
 8000400:	f44f 3780 	mov.w	r7, #65536	; 0x10000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000404:	2401      	movs	r4, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000406:	2102      	movs	r1, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000408:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800040c:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000410:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8000414:	e9cd 3307 	strd	r3, r3, [sp, #28]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000418:	e9cd 3301 	strd	r3, r3, [sp, #4]
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800041c:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800041e:	9304      	str	r3, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000420:	9300      	str	r3, [sp, #0]
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000422:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000424:	9303      	str	r3, [sp, #12]
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 8000426:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800042a:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800042c:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000430:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000432:	9111      	str	r1, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000434:	9212      	str	r2, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 8000436:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000438:	f001 fea0 	bl	800217c <HAL_RCC_OscConfig>
 800043c:	b108      	cbz	r0, 8000442 <SystemClock_Config+0x4a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800043e:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000440:	e7fe      	b.n	8000440 <SystemClock_Config+0x48>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000442:	220f      	movs	r2, #15
 8000444:	2302      	movs	r3, #2
 8000446:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800044a:	2200      	movs	r2, #0
 800044c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000450:	9008      	str	r0, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000452:	4621      	mov	r1, r4
 8000454:	a804      	add	r0, sp, #16
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000456:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800045a:	f002 f87f 	bl	800255c <HAL_RCC_ClockConfig>
 800045e:	b108      	cbz	r0, 8000464 <SystemClock_Config+0x6c>
 8000460:	b672      	cpsid	i
  while (1)
 8000462:	e7fe      	b.n	8000462 <SystemClock_Config+0x6a>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8000464:	2210      	movs	r2, #16
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
 8000466:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800046a:	4668      	mov	r0, sp
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 800046c:	9200      	str	r2, [sp, #0]
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
 800046e:	9303      	str	r3, [sp, #12]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000470:	f002 f98a 	bl	8002788 <HAL_RCCEx_PeriphCLKConfig>
 8000474:	4602      	mov	r2, r0
 8000476:	b108      	cbz	r0, 800047c <SystemClock_Config+0x84>
 8000478:	b672      	cpsid	i
  while (1)
 800047a:	e7fe      	b.n	800047a <SystemClock_Config+0x82>
  HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_SYSCLK, RCC_MCODIV_1);
 800047c:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
 8000480:	f002 f93c 	bl	80026fc <HAL_RCC_MCOConfig>
}
 8000484:	b014      	add	sp, #80	; 0x50
 8000486:	bdd0      	pop	{r4, r6, r7, pc}

08000488 <main>:
{
 8000488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800048c:	2500      	movs	r5, #0
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800048e:	2708      	movs	r7, #8
{
 8000490:	b089      	sub	sp, #36	; 0x24
  HAL_Init();
 8000492:	f000 faa1 	bl	80009d8 <HAL_Init>
  SystemClock_Config();
 8000496:	f7ff ffaf 	bl	80003f8 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800049a:	e9cd 5504 	strd	r5, r5, [sp, #16]
 800049e:	e9cd 5506 	strd	r5, r5, [sp, #24]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80004a2:	4e89      	ldr	r6, [pc, #548]	; (80006c8 <main+0x240>)
  HAL_GPIO_WritePin(GPIOA, SPI0_CS_Pin|USB_EN_Pin, GPIO_PIN_SET);
 80004a4:	f248 0102 	movw	r1, #32770	; 0x8002
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80004a8:	69b3      	ldr	r3, [r6, #24]
  HAL_GPIO_WritePin(GPIOA, SPI0_CS_Pin|USB_EN_Pin, GPIO_PIN_SET);
 80004aa:	2201      	movs	r2, #1
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80004ac:	f043 0320 	orr.w	r3, r3, #32
 80004b0:	61b3      	str	r3, [r6, #24]
 80004b2:	69b3      	ldr	r3, [r6, #24]
  HAL_GPIO_WritePin(GPIOA, SPI0_CS_Pin|USB_EN_Pin, GPIO_PIN_SET);
 80004b4:	4885      	ldr	r0, [pc, #532]	; (80006cc <main+0x244>)
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80004b6:	f003 0320 	and.w	r3, r3, #32
 80004ba:	9301      	str	r3, [sp, #4]
 80004bc:	9b01      	ldr	r3, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80004be:	69b3      	ldr	r3, [r6, #24]
  GPIO_InitStruct.Pin = CRESET_pin_Pin;
 80004c0:	f04f 0800 	mov.w	r8, #0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80004c4:	f043 0304 	orr.w	r3, r3, #4
 80004c8:	61b3      	str	r3, [r6, #24]
 80004ca:	69b3      	ldr	r3, [r6, #24]
  GPIO_InitStruct.Pin = CRESET_pin_Pin;
 80004cc:	f04f 0902 	mov.w	r9, #2
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80004d0:	f003 0304 	and.w	r3, r3, #4
 80004d4:	9302      	str	r3, [sp, #8]
 80004d6:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80004d8:	69b3      	ldr	r3, [r6, #24]
  hspi1.Instance = SPI1;
 80004da:	4c7d      	ldr	r4, [pc, #500]	; (80006d0 <main+0x248>)
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80004dc:	433b      	orrs	r3, r7
 80004de:	61b3      	str	r3, [r6, #24]
 80004e0:	69b3      	ldr	r3, [r6, #24]
 80004e2:	403b      	ands	r3, r7
 80004e4:	9303      	str	r3, [sp, #12]
 80004e6:	9b03      	ldr	r3, [sp, #12]
  HAL_GPIO_WritePin(GPIOA, SPI0_CS_Pin|USB_EN_Pin, GPIO_PIN_SET);
 80004e8:	f000 feac 	bl	8001244 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(CRESET_pin_GPIO_Port, CRESET_pin_Pin, GPIO_PIN_RESET);
 80004ec:	462a      	mov	r2, r5
 80004ee:	2102      	movs	r1, #2
 80004f0:	4878      	ldr	r0, [pc, #480]	; (80006d4 <main+0x24c>)
 80004f2:	f000 fea7 	bl	8001244 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = SPI0_CS_Pin;
 80004f6:	2202      	movs	r2, #2
 80004f8:	2311      	movs	r3, #17
 80004fa:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80004fe:	2201      	movs	r2, #1
 8000500:	2302      	movs	r3, #2
  HAL_GPIO_Init(SPI0_CS_GPIO_Port, &GPIO_InitStruct);
 8000502:	4872      	ldr	r0, [pc, #456]	; (80006cc <main+0x244>)
 8000504:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = SPI0_CS_Pin;
 8000506:	e9cd 2306 	strd	r2, r3, [sp, #24]
  HAL_GPIO_Init(SPI0_CS_GPIO_Port, &GPIO_InitStruct);
 800050a:	f000 fd8d 	bl	8001028 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = CRESET_pin_Pin;
 800050e:	2202      	movs	r2, #2
 8000510:	2301      	movs	r3, #1
  HAL_GPIO_Init(CRESET_pin_GPIO_Port, &GPIO_InitStruct);
 8000512:	4870      	ldr	r0, [pc, #448]	; (80006d4 <main+0x24c>)
 8000514:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = CRESET_pin_Pin;
 8000516:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800051a:	e9cd 8906 	strd	r8, r9, [sp, #24]
  HAL_GPIO_Init(CRESET_pin_GPIO_Port, &GPIO_InitStruct);
 800051e:	f000 fd83 	bl	8001028 <HAL_GPIO_Init>
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000522:	2303      	movs	r3, #3
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 8000524:	f44f 7280 	mov.w	r2, #256	; 0x100
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000528:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 800052a:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800052c:	4867      	ldr	r0, [pc, #412]	; (80006cc <main+0x244>)
 800052e:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 8000530:	e9cd 2304 	strd	r2, r3, [sp, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000534:	f000 fd78 	bl	8001028 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = USB_EN_Pin;
 8000538:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800053c:	2301      	movs	r3, #1
  HAL_GPIO_Init(USB_EN_GPIO_Port, &GPIO_InitStruct);
 800053e:	4863      	ldr	r0, [pc, #396]	; (80006cc <main+0x244>)
 8000540:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = USB_EN_Pin;
 8000542:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8000546:	e9cd 8906 	strd	r8, r9, [sp, #24]
  HAL_GPIO_Init(USB_EN_GPIO_Port, &GPIO_InitStruct);
 800054a:	f000 fd6d 	bl	8001028 <HAL_GPIO_Init>
  __HAL_RCC_DMA1_CLK_ENABLE();
 800054e:	6973      	ldr	r3, [r6, #20]
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
 8000550:	462a      	mov	r2, r5
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000552:	f043 0301 	orr.w	r3, r3, #1
 8000556:	6173      	str	r3, [r6, #20]
 8000558:	6973      	ldr	r3, [r6, #20]
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
 800055a:	4629      	mov	r1, r5
  __HAL_RCC_DMA1_CLK_ENABLE();
 800055c:	f003 0301 	and.w	r3, r3, #1
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
 8000560:	200d      	movs	r0, #13
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000562:	9304      	str	r3, [sp, #16]
 8000564:	9b04      	ldr	r3, [sp, #16]
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
 8000566:	f000 fa7f 	bl	8000a68 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
 800056a:	200d      	movs	r0, #13
 800056c:	f000 faba 	bl	8000ae4 <HAL_NVIC_EnableIRQ>
  hspi1.Instance = SPI1;
 8000570:	4b59      	ldr	r3, [pc, #356]	; (80006d8 <main+0x250>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000572:	f44f 7182 	mov.w	r1, #260	; 0x104
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000576:	f44f 7200 	mov.w	r2, #512	; 0x200
  hspi1.Instance = SPI1;
 800057a:	6023      	str	r3, [r4, #0]
  hspi1.Init.CRCPolynomial = 10;
 800057c:	230a      	movs	r3, #10
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800057e:	4620      	mov	r0, r4
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8000580:	e9c4 5502 	strd	r5, r5, [r4, #8]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000584:	e9c4 5504 	strd	r5, r5, [r4, #16]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000588:	e9c4 7507 	strd	r7, r5, [r4, #28]
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800058c:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000590:	6061      	str	r1, [r4, #4]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000592:	61a2      	str	r2, [r4, #24]
  hspi1.Init.CRCPolynomial = 10;
 8000594:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000596:	f002 f9d7 	bl	8002948 <HAL_SPI_Init>
 800059a:	b108      	cbz	r0, 80005a0 <main+0x118>
 800059c:	b672      	cpsid	i
  while (1)
 800059e:	e7fe      	b.n	800059e <main+0x116>
  huart2.Instance = USART2;
 80005a0:	4603      	mov	r3, r0
 80005a2:	4a4e      	ldr	r2, [pc, #312]	; (80006dc <main+0x254>)
 80005a4:	484e      	ldr	r0, [pc, #312]	; (80006e0 <main+0x258>)
 80005a6:	6002      	str	r2, [r0, #0]
  huart2.Init.BaudRate = 115200;
 80005a8:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
  huart2.Init.Parity = UART_PARITY_NONE;
 80005ac:	e9c0 3303 	strd	r3, r3, [r0, #12]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80005b0:	e9c0 7305 	strd	r7, r3, [r0, #20]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 80005b4:	6083      	str	r3, [r0, #8]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 80005b6:	61c3      	str	r3, [r0, #28]
  huart2.Init.BaudRate = 115200;
 80005b8:	6042      	str	r2, [r0, #4]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 80005ba:	f002 fc85 	bl	8002ec8 <HAL_UART_Init>
 80005be:	b108      	cbz	r0, 80005c4 <main+0x13c>
 80005c0:	b672      	cpsid	i
  while (1)
 80005c2:	e7fe      	b.n	80005c2 <main+0x13a>
  MX_USB_DEVICE_Init();
 80005c4:	f004 fdfc 	bl	80051c0 <MX_USB_DEVICE_Init>
  if(w25_init(&w25q, &hspi1, SPI0_CS_GPIO_Port, SPI0_CS_Pin)){
 80005c8:	2302      	movs	r3, #2
 80005ca:	4621      	mov	r1, r4
 80005cc:	4a3f      	ldr	r2, [pc, #252]	; (80006cc <main+0x244>)
 80005ce:	4845      	ldr	r0, [pc, #276]	; (80006e4 <main+0x25c>)
 80005d0:	f7ff fdbc 	bl	800014c <w25_init>
 80005d4:	2800      	cmp	r0, #0
 80005d6:	d06f      	beq.n	80006b8 <main+0x230>
	  printf("ERROR:SPI flash init failed.\n");
 80005d8:	4843      	ldr	r0, [pc, #268]	; (80006e8 <main+0x260>)
 80005da:	f005 f979 	bl	80058d0 <puts>
  HAL_GPIO_WritePin(CRESET_pin_GPIO_Port, CRESET_pin_Pin, GPIO_PIN_SET);// Release reset pin, lets FPGA run.
 80005de:	2201      	movs	r2, #1
 80005e0:	2102      	movs	r1, #2
 80005e2:	483c      	ldr	r0, [pc, #240]	; (80006d4 <main+0x24c>)
 80005e4:	f000 fe2e 	bl	8001244 <HAL_GPIO_WritePin>
  ice_mkfs();
 80005e8:	f7ff fe9a 	bl	8000320 <ice_mkfs>
  HAL_GPIO_WritePin(USB_EN_GPIO_Port, USB_EN_Pin, GPIO_PIN_SET);
 80005ec:	2201      	movs	r2, #1
 80005ee:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80005f2:	4836      	ldr	r0, [pc, #216]	; (80006cc <main+0x244>)
 80005f4:	f000 fe26 	bl	8001244 <HAL_GPIO_WritePin>
	uint8_t *flash_scan = (uint8_t *)(FLASH_MEM_BASE_ADDR);
 80005f8:	4e3c      	ldr	r6, [pc, #240]	; (80006ec <main+0x264>)
	  if(flash_scan == (uint8_t *)FLASH_MEM_END_ADDR)
 80005fa:	4d3d      	ldr	r5, [pc, #244]	; (80006f0 <main+0x268>)
	  if(*(flash_scan++) == 0x7E){//MSB byte of preamble should be at 0x8015805.
 80005fc:	4f3d      	ldr	r7, [pc, #244]	; (80006f4 <main+0x26c>)
	HAL_GPIO_WritePin(USB_EN_GPIO_Port, USB_EN_Pin, GPIO_PIN_SET);
 80005fe:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 80006cc <main+0x244>
	uint8_t *flash_scan = (uint8_t *)(FLASH_MEM_BASE_ADDR);
 8000602:	4633      	mov	r3, r6
 8000604:	e005      	b.n	8000612 <main+0x18a>
	  if(flash_scan == (uint8_t *)FLASH_MEM_END_ADDR)
 8000606:	461c      	mov	r4, r3
	  if(*(flash_scan++) == 0x7E){//MSB byte of preamble should be at 0x8015805.
 8000608:	4623      	mov	r3, r4
 800060a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800060e:	2a7e      	cmp	r2, #126	; 0x7e
 8000610:	d007      	beq.n	8000622 <main+0x19a>
	  if(flash_scan == (uint8_t *)FLASH_MEM_END_ADDR)
 8000612:	42ab      	cmp	r3, r5
 8000614:	d1f7      	bne.n	8000606 <main+0x17e>
	  if(*(flash_scan++) == 0x7E){//MSB byte of preamble should be at 0x8015805.
 8000616:	7833      	ldrb	r3, [r6, #0]
 8000618:	2b7e      	cmp	r3, #126	; 0x7e
 800061a:	bf18      	it	ne
 800061c:	463c      	movne	r4, r7
 800061e:	d1f3      	bne.n	8000608 <main+0x180>
				flash_scan = (uint8_t *)(FLASH_MEM_BASE_ADDR);
 8000620:	4634      	mov	r4, r6
		  if(*(flash_scan++) == 0xAA){
 8000622:	7862      	ldrb	r2, [r4, #1]
 8000624:	1ca3      	adds	r3, r4, #2
 8000626:	2aaa      	cmp	r2, #170	; 0xaa
 8000628:	d1f3      	bne.n	8000612 <main+0x18a>
			  if(*(flash_scan++) == 0x99){
 800062a:	78a2      	ldrb	r2, [r4, #2]
 800062c:	1ce3      	adds	r3, r4, #3
 800062e:	2a99      	cmp	r2, #153	; 0x99
 8000630:	d1ef      	bne.n	8000612 <main+0x18a>
				  if(*flash_scan == 0x7E){
 8000632:	78e2      	ldrb	r2, [r4, #3]
 8000634:	2a7e      	cmp	r2, #126	; 0x7e
 8000636:	d1ec      	bne.n	8000612 <main+0x18a>
					  HAL_Delay(1000);// slow down a bit. Let's the Bitstream copied.
 8000638:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800063c:	f000 f9f0 	bl	8000a20 <HAL_Delay>
 8000640:	46a2      	mov	sl, r4
 8000642:	4653      	mov	r3, sl
	if(*(flash_scan++) == 0x01){
 8000644:	461a      	mov	r2, r3
 8000646:	f813 9b01 	ldrb.w	r9, [r3], #1
 800064a:	f1b9 0f01 	cmp.w	r9, #1
 800064e:	d1f9      	bne.n	8000644 <main+0x1bc>
		if(*(flash_scan++) == 0x06){
 8000650:	7819      	ldrb	r1, [r3, #0]
 8000652:	f102 0a02 	add.w	sl, r2, #2
 8000656:	2906      	cmp	r1, #6
 8000658:	d1f3      	bne.n	8000642 <main+0x1ba>
			if(*flash_scan == 0x00){
 800065a:	f893 b001 	ldrb.w	fp, [r3, #1]
 800065e:	f1bb 0f00 	cmp.w	fp, #0
 8000662:	d1ee      	bne.n	8000642 <main+0x1ba>
	HAL_GPIO_WritePin(CRESET_pin_GPIO_Port, CRESET_pin_Pin, GPIO_PIN_RESET);
 8000664:	465a      	mov	r2, fp
 8000666:	2102      	movs	r1, #2
 8000668:	481a      	ldr	r0, [pc, #104]	; (80006d4 <main+0x24c>)
 800066a:	f000 fdeb 	bl	8001244 <HAL_GPIO_WritePin>
	w25_erase32K(&w25q, 0);// erase 32KByte starting at address 0
 800066e:	4659      	mov	r1, fp
 8000670:	481c      	ldr	r0, [pc, #112]	; (80006e4 <main+0x25c>)
 8000672:	f7ff fe1d 	bl	80002b0 <w25_erase32K>
	bitstream_size = ((uint8_t *)flash_scan - fdata) + 1;
 8000676:	ebaa 0204 	sub.w	r2, sl, r4
	w25_write(&w25q, (uint8_t *)fdata, bitstream_size);// Flash bit stream to SPI NOR flash.
 800067a:	4621      	mov	r1, r4
 800067c:	3201      	adds	r2, #1
 800067e:	4819      	ldr	r0, [pc, #100]	; (80006e4 <main+0x25c>)
 8000680:	f7ff fdac 	bl	80001dc <w25_write>
	HAL_GPIO_WritePin(CRESET_pin_GPIO_Port, CRESET_pin_Pin, GPIO_PIN_SET);
 8000684:	464a      	mov	r2, r9
 8000686:	2102      	movs	r1, #2
 8000688:	4812      	ldr	r0, [pc, #72]	; (80006d4 <main+0x24c>)
 800068a:	f000 fddb 	bl	8001244 <HAL_GPIO_WritePin>
	printf("DONE:Bit stream is flashed into SPI NOR");
 800068e:	481a      	ldr	r0, [pc, #104]	; (80006f8 <main+0x270>)
 8000690:	f005 f898 	bl	80057c4 <iprintf>
	ice_mkfs();
 8000694:	f7ff fe44 	bl	8000320 <ice_mkfs>
	HAL_GPIO_WritePin(USB_EN_GPIO_Port, USB_EN_Pin, GPIO_PIN_SET);
 8000698:	464a      	mov	r2, r9
 800069a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800069e:	4640      	mov	r0, r8
 80006a0:	f000 fdd0 	bl	8001244 <HAL_GPIO_WritePin>
	HAL_Delay(20);
 80006a4:	2014      	movs	r0, #20
 80006a6:	f000 f9bb 	bl	8000a20 <HAL_Delay>
	HAL_GPIO_WritePin(USB_EN_GPIO_Port, USB_EN_Pin, GPIO_PIN_RESET);
 80006aa:	465a      	mov	r2, fp
 80006ac:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80006b0:	4640      	mov	r0, r8
 80006b2:	f000 fdc7 	bl	8001244 <HAL_GPIO_WritePin>
  {
 80006b6:	e7a4      	b.n	8000602 <main+0x17a>
	  printf("INFO:SPI flash detected\n");
 80006b8:	4810      	ldr	r0, [pc, #64]	; (80006fc <main+0x274>)
 80006ba:	f005 f909 	bl	80058d0 <puts>
	  w25_writeMode(&w25q, 1);// NOR flash write enable.
 80006be:	2101      	movs	r1, #1
 80006c0:	4808      	ldr	r0, [pc, #32]	; (80006e4 <main+0x25c>)
 80006c2:	f7ff fd6f 	bl	80001a4 <w25_writeMode>
 80006c6:	e78a      	b.n	80005de <main+0x156>
 80006c8:	40021000 	.word	0x40021000
 80006cc:	40010800 	.word	0x40010800
 80006d0:	20000200 	.word	0x20000200
 80006d4:	40010c00 	.word	0x40010c00
 80006d8:	40013000 	.word	0x40013000
 80006dc:	40004400 	.word	0x40004400
 80006e0:	20000258 	.word	0x20000258
 80006e4:	2000029c 	.word	0x2000029c
 80006e8:	08006840 	.word	0x08006840
 80006ec:	0800fc00 	.word	0x0800fc00
 80006f0:	0801ffff 	.word	0x0801ffff
 80006f4:	0800fc01 	.word	0x0800fc01
 80006f8:	08006878 	.word	0x08006878
 80006fc:	08006860 	.word	0x08006860

08000700 <Error_Handler>:
 8000700:	b672      	cpsid	i
  while (1)
 8000702:	e7fe      	b.n	8000702 <Error_Handler+0x2>

08000704 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8000704:	4b0e      	ldr	r3, [pc, #56]	; (8000740 <HAL_MspInit+0x3c>)
{
 8000706:	b082      	sub	sp, #8
  __HAL_RCC_AFIO_CLK_ENABLE();
 8000708:	699a      	ldr	r2, [r3, #24]

  /* System interrupt init*/

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 800070a:	490e      	ldr	r1, [pc, #56]	; (8000744 <HAL_MspInit+0x40>)
  __HAL_RCC_AFIO_CLK_ENABLE();
 800070c:	f042 0201 	orr.w	r2, r2, #1
 8000710:	619a      	str	r2, [r3, #24]
 8000712:	699a      	ldr	r2, [r3, #24]
 8000714:	f002 0201 	and.w	r2, r2, #1
 8000718:	9200      	str	r2, [sp, #0]
 800071a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800071c:	69da      	ldr	r2, [r3, #28]
 800071e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000722:	61da      	str	r2, [r3, #28]
 8000724:	69db      	ldr	r3, [r3, #28]
 8000726:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800072a:	9301      	str	r3, [sp, #4]
 800072c:	9b01      	ldr	r3, [sp, #4]
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 800072e:	684b      	ldr	r3, [r1, #4]
 8000730:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8000734:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8000738:	604b      	str	r3, [r1, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800073a:	b002      	add	sp, #8
 800073c:	4770      	bx	lr
 800073e:	bf00      	nop
 8000740:	40021000 	.word	0x40021000
 8000744:	40010000 	.word	0x40010000

08000748 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8000748:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800074a:	2400      	movs	r4, #0
  if(hspi->Instance==SPI1)
 800074c:	4b25      	ldr	r3, [pc, #148]	; (80007e4 <HAL_SPI_MspInit+0x9c>)
 800074e:	6802      	ldr	r2, [r0, #0]
{
 8000750:	b086      	sub	sp, #24
  if(hspi->Instance==SPI1)
 8000752:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000754:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8000758:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(hspi->Instance==SPI1)
 800075c:	d001      	beq.n	8000762 <HAL_SPI_MspInit+0x1a>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 800075e:	b006      	add	sp, #24
 8000760:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000762:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
 8000766:	699a      	ldr	r2, [r3, #24]
 8000768:	4605      	mov	r5, r0
 800076a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800076e:	619a      	str	r2, [r3, #24]
 8000770:	699a      	ldr	r2, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000772:	481d      	ldr	r0, [pc, #116]	; (80007e8 <HAL_SPI_MspInit+0xa0>)
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000774:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8000778:	9200      	str	r2, [sp, #0]
 800077a:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800077c:	699a      	ldr	r2, [r3, #24]
    hdma_spi1_tx.Instance = DMA1_Channel3;
 800077e:	4e1b      	ldr	r6, [pc, #108]	; (80007ec <HAL_SPI_MspInit+0xa4>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000780:	f042 0204 	orr.w	r2, r2, #4
 8000784:	619a      	str	r2, [r3, #24]
 8000786:	699b      	ldr	r3, [r3, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 8000788:	22a0      	movs	r2, #160	; 0xa0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800078a:	f003 0304 	and.w	r3, r3, #4
 800078e:	9301      	str	r3, [sp, #4]
 8000790:	9901      	ldr	r1, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000792:	2103      	movs	r1, #3
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 8000794:	2302      	movs	r3, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000796:	9105      	str	r1, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000798:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 800079a:	e9cd 2302 	strd	r2, r3, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800079e:	f000 fc43 	bl	8001028 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 80007a2:	2240      	movs	r2, #64	; 0x40
 80007a4:	2300      	movs	r3, #0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007a6:	4810      	ldr	r0, [pc, #64]	; (80007e8 <HAL_SPI_MspInit+0xa0>)
 80007a8:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 80007aa:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80007ae:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007b0:	f000 fc3a 	bl	8001028 <HAL_GPIO_Init>
    hdma_spi1_tx.Instance = DMA1_Channel3;
 80007b4:	4b0e      	ldr	r3, [pc, #56]	; (80007f0 <HAL_SPI_MspInit+0xa8>)
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80007b6:	2110      	movs	r1, #16
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80007b8:	2280      	movs	r2, #128	; 0x80
    hdma_spi1_tx.Instance = DMA1_Channel3;
 80007ba:	6033      	str	r3, [r6, #0]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_MEDIUM;
 80007bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 80007c0:	4630      	mov	r0, r6
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80007c2:	e9c6 4404 	strd	r4, r4, [r6, #16]
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80007c6:	60b4      	str	r4, [r6, #8]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 80007c8:	61b4      	str	r4, [r6, #24]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80007ca:	6071      	str	r1, [r6, #4]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80007cc:	60f2      	str	r2, [r6, #12]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_MEDIUM;
 80007ce:	61f3      	str	r3, [r6, #28]
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 80007d0:	f000 f9ae 	bl	8000b30 <HAL_DMA_Init>
 80007d4:	b918      	cbnz	r0, 80007de <HAL_SPI_MspInit+0x96>
    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 80007d6:	64ae      	str	r6, [r5, #72]	; 0x48
 80007d8:	6275      	str	r5, [r6, #36]	; 0x24
}
 80007da:	b006      	add	sp, #24
 80007dc:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 80007de:	f7ff ff8f 	bl	8000700 <Error_Handler>
 80007e2:	e7f8      	b.n	80007d6 <HAL_SPI_MspInit+0x8e>
 80007e4:	40013000 	.word	0x40013000
 80007e8:	40010800 	.word	0x40010800
 80007ec:	200001bc 	.word	0x200001bc
 80007f0:	40020030 	.word	0x40020030

080007f4 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80007f4:	b5d0      	push	{r4, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80007f6:	2400      	movs	r4, #0
  if(huart->Instance==USART2)
 80007f8:	4b19      	ldr	r3, [pc, #100]	; (8000860 <HAL_UART_MspInit+0x6c>)
 80007fa:	6802      	ldr	r2, [r0, #0]
{
 80007fc:	b086      	sub	sp, #24
  if(huart->Instance==USART2)
 80007fe:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000800:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8000804:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(huart->Instance==USART2)
 8000808:	d001      	beq.n	800080e <HAL_UART_MspInit+0x1a>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 800080a:	b006      	add	sp, #24
 800080c:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_USART2_CLK_ENABLE();
 800080e:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
 8000812:	69da      	ldr	r2, [r3, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000814:	2604      	movs	r6, #4
    __HAL_RCC_USART2_CLK_ENABLE();
 8000816:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800081a:	61da      	str	r2, [r3, #28]
 800081c:	69da      	ldr	r2, [r3, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800081e:	2702      	movs	r7, #2
    __HAL_RCC_USART2_CLK_ENABLE();
 8000820:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8000824:	9200      	str	r2, [sp, #0]
 8000826:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000828:	699a      	ldr	r2, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800082a:	a902      	add	r1, sp, #8
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800082c:	f042 0204 	orr.w	r2, r2, #4
 8000830:	619a      	str	r2, [r3, #24]
 8000832:	699b      	ldr	r3, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000834:	480b      	ldr	r0, [pc, #44]	; (8000864 <HAL_UART_MspInit+0x70>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000836:	f003 0304 	and.w	r3, r3, #4
 800083a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800083c:	2303      	movs	r3, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800083e:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000840:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000842:	e9cd 6702 	strd	r6, r7, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000846:	f000 fbef 	bl	8001028 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 800084a:	2208      	movs	r2, #8
 800084c:	2300      	movs	r3, #0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800084e:	4805      	ldr	r0, [pc, #20]	; (8000864 <HAL_UART_MspInit+0x70>)
 8000850:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8000852:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000856:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000858:	f000 fbe6 	bl	8001028 <HAL_GPIO_Init>
}
 800085c:	b006      	add	sp, #24
 800085e:	bdd0      	pop	{r4, r6, r7, pc}
 8000860:	40004400 	.word	0x40004400
 8000864:	40010800 	.word	0x40010800

08000868 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8000868:	e7fe      	b.n	8000868 <NMI_Handler>
 800086a:	bf00      	nop

0800086c <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800086c:	e7fe      	b.n	800086c <HardFault_Handler>
 800086e:	bf00      	nop

08000870 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000870:	e7fe      	b.n	8000870 <MemManage_Handler>
 8000872:	bf00      	nop

08000874 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000874:	e7fe      	b.n	8000874 <BusFault_Handler>
 8000876:	bf00      	nop

08000878 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000878:	e7fe      	b.n	8000878 <UsageFault_Handler>
 800087a:	bf00      	nop

0800087c <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800087c:	4770      	bx	lr
 800087e:	bf00      	nop

08000880 <DebugMon_Handler>:
 8000880:	4770      	bx	lr
 8000882:	bf00      	nop

08000884 <PendSV_Handler>:
 8000884:	4770      	bx	lr
 8000886:	bf00      	nop

08000888 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000888:	f000 b8b8 	b.w	80009fc <HAL_IncTick>

0800088c <DMA1_Channel3_IRQHandler>:
void DMA1_Channel3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel3_IRQn 0 */

  /* USER CODE END DMA1_Channel3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 800088c:	4801      	ldr	r0, [pc, #4]	; (8000894 <DMA1_Channel3_IRQHandler+0x8>)
 800088e:	f000 b981 	b.w	8000b94 <HAL_DMA_IRQHandler>
 8000892:	bf00      	nop
 8000894:	200001bc 	.word	0x200001bc

08000898 <USB_LP_CAN1_RX0_IRQHandler>:
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 8000898:	4801      	ldr	r0, [pc, #4]	; (80008a0 <USB_LP_CAN1_RX0_IRQHandler+0x8>)
 800089a:	f000 bd6f 	b.w	800137c <HAL_PCD_IRQHandler>
 800089e:	bf00      	nop
 80008a0:	20000bb8 	.word	0x20000bb8

080008a4 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80008a4:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80008a6:	1e16      	subs	r6, r2, #0
 80008a8:	dd07      	ble.n	80008ba <_read+0x16>
 80008aa:	460c      	mov	r4, r1
 80008ac:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 80008ae:	f3af 8000 	nop.w
 80008b2:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80008b6:	42a5      	cmp	r5, r4
 80008b8:	d1f9      	bne.n	80008ae <_read+0xa>
	}

return len;
}
 80008ba:	4630      	mov	r0, r6
 80008bc:	bd70      	pop	{r4, r5, r6, pc}
 80008be:	bf00      	nop

080008c0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80008c0:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80008c2:	1e16      	subs	r6, r2, #0
 80008c4:	dd07      	ble.n	80008d6 <_write+0x16>
 80008c6:	460c      	mov	r4, r1
 80008c8:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 80008ca:	f814 0b01 	ldrb.w	r0, [r4], #1
 80008ce:	f7ff fd17 	bl	8000300 <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80008d2:	42ac      	cmp	r4, r5
 80008d4:	d1f9      	bne.n	80008ca <_write+0xa>
	}
	return len;
}
 80008d6:	4630      	mov	r0, r6
 80008d8:	bd70      	pop	{r4, r5, r6, pc}
 80008da:	bf00      	nop

080008dc <_close>:

int _close(int file)
{
	return -1;
}
 80008dc:	f04f 30ff 	mov.w	r0, #4294967295
 80008e0:	4770      	bx	lr
 80008e2:	bf00      	nop

080008e4 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 80008e4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
 80008e8:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 80008ea:	604b      	str	r3, [r1, #4]
}
 80008ec:	4770      	bx	lr
 80008ee:	bf00      	nop

080008f0 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 80008f0:	2001      	movs	r0, #1
 80008f2:	4770      	bx	lr

080008f4 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 80008f4:	2000      	movs	r0, #0
 80008f6:	4770      	bx	lr

080008f8 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80008f8:	490d      	ldr	r1, [pc, #52]	; (8000930 <_sbrk+0x38>)
{
 80008fa:	4603      	mov	r3, r0
 80008fc:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80008fe:	4a0d      	ldr	r2, [pc, #52]	; (8000934 <_sbrk+0x3c>)
 8000900:	4c0d      	ldr	r4, [pc, #52]	; (8000938 <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 8000902:	6808      	ldr	r0, [r1, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000904:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8000906:	b120      	cbz	r0, 8000912 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8000908:	4403      	add	r3, r0
 800090a:	4293      	cmp	r3, r2
 800090c:	d807      	bhi.n	800091e <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 800090e:	600b      	str	r3, [r1, #0]

  return (void *)prev_heap_end;
}
 8000910:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8000912:	4c0a      	ldr	r4, [pc, #40]	; (800093c <_sbrk+0x44>)
 8000914:	4620      	mov	r0, r4
  if (__sbrk_heap_end + incr > max_heap)
 8000916:	4403      	add	r3, r0
 8000918:	4293      	cmp	r3, r2
    __sbrk_heap_end = &_end;
 800091a:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 800091c:	d9f7      	bls.n	800090e <_sbrk+0x16>
    errno = ENOMEM;
 800091e:	f004 ff11 	bl	8005744 <__errno>
 8000922:	220c      	movs	r2, #12
 8000924:	4603      	mov	r3, r0
    return (void *)-1;
 8000926:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOMEM;
 800092a:	601a      	str	r2, [r3, #0]
}
 800092c:	bd10      	pop	{r4, pc}
 800092e:	bf00      	nop
 8000930:	200002ac 	.word	0x200002ac
 8000934:	20005000 	.word	0x20005000
 8000938:	00000400 	.word	0x00000400
 800093c:	20001028 	.word	0x20001028

08000940 <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000940:	4770      	bx	lr
 8000942:	bf00      	nop

08000944 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000944:	480c      	ldr	r0, [pc, #48]	; (8000978 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8000946:	490d      	ldr	r1, [pc, #52]	; (800097c <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8000948:	4a0d      	ldr	r2, [pc, #52]	; (8000980 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800094a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800094c:	e002      	b.n	8000954 <LoopCopyDataInit>

0800094e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800094e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000950:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000952:	3304      	adds	r3, #4

08000954 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000954:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000956:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000958:	d3f9      	bcc.n	800094e <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800095a:	4a0a      	ldr	r2, [pc, #40]	; (8000984 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 800095c:	4c0a      	ldr	r4, [pc, #40]	; (8000988 <LoopFillZerobss+0x22>)
  movs r3, #0
 800095e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000960:	e001      	b.n	8000966 <LoopFillZerobss>

08000962 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000962:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000964:	3204      	adds	r2, #4

08000966 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000966:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000968:	d3fb      	bcc.n	8000962 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800096a:	f7ff ffe9 	bl	8000940 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800096e:	f004 feef 	bl	8005750 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000972:	f7ff fd89 	bl	8000488 <main>
  bx lr
 8000976:	4770      	bx	lr
  ldr r0, =_sdata
 8000978:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800097c:	20000184 	.word	0x20000184
  ldr r2, =_sidata
 8000980:	080069e0 	.word	0x080069e0
  ldr r2, =_sbss
 8000984:	20000188 	.word	0x20000188
  ldr r4, =_ebss
 8000988:	20001024 	.word	0x20001024

0800098c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800098c:	e7fe      	b.n	800098c <ADC1_2_IRQHandler>
	...

08000990 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000990:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000992:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000996:	4a0d      	ldr	r2, [pc, #52]	; (80009cc <HAL_InitTick+0x3c>)
{
 8000998:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800099a:	7811      	ldrb	r1, [r2, #0]
 800099c:	4a0c      	ldr	r2, [pc, #48]	; (80009d0 <HAL_InitTick+0x40>)
 800099e:	fbb3 f3f1 	udiv	r3, r3, r1
 80009a2:	6812      	ldr	r2, [r2, #0]
 80009a4:	fbb2 f0f3 	udiv	r0, r2, r3
 80009a8:	f000 f8aa 	bl	8000b00 <HAL_SYSTICK_Config>
 80009ac:	b908      	cbnz	r0, 80009b2 <HAL_InitTick+0x22>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80009ae:	2d0f      	cmp	r5, #15
 80009b0:	d901      	bls.n	80009b6 <HAL_InitTick+0x26>
    return HAL_ERROR;
 80009b2:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 80009b4:	bd38      	pop	{r3, r4, r5, pc}
 80009b6:	4604      	mov	r4, r0
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80009b8:	4602      	mov	r2, r0
 80009ba:	4629      	mov	r1, r5
 80009bc:	f04f 30ff 	mov.w	r0, #4294967295
 80009c0:	f000 f852 	bl	8000a68 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80009c4:	4b03      	ldr	r3, [pc, #12]	; (80009d4 <HAL_InitTick+0x44>)
 80009c6:	4620      	mov	r0, r4
 80009c8:	601d      	str	r5, [r3, #0]
}
 80009ca:	bd38      	pop	{r3, r4, r5, pc}
 80009cc:	20000004 	.word	0x20000004
 80009d0:	20000000 	.word	0x20000000
 80009d4:	20000008 	.word	0x20000008

080009d8 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80009d8:	4a07      	ldr	r2, [pc, #28]	; (80009f8 <HAL_Init+0x20>)
{
 80009da:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80009dc:	6813      	ldr	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009de:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80009e0:	f043 0310 	orr.w	r3, r3, #16
 80009e4:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009e6:	f000 f82d 	bl	8000a44 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80009ea:	200f      	movs	r0, #15
 80009ec:	f7ff ffd0 	bl	8000990 <HAL_InitTick>
  HAL_MspInit();
 80009f0:	f7ff fe88 	bl	8000704 <HAL_MspInit>
}
 80009f4:	2000      	movs	r0, #0
 80009f6:	bd08      	pop	{r3, pc}
 80009f8:	40022000 	.word	0x40022000

080009fc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80009fc:	4a03      	ldr	r2, [pc, #12]	; (8000a0c <HAL_IncTick+0x10>)
 80009fe:	4b04      	ldr	r3, [pc, #16]	; (8000a10 <HAL_IncTick+0x14>)
 8000a00:	6811      	ldr	r1, [r2, #0]
 8000a02:	781b      	ldrb	r3, [r3, #0]
 8000a04:	440b      	add	r3, r1
 8000a06:	6013      	str	r3, [r2, #0]
}
 8000a08:	4770      	bx	lr
 8000a0a:	bf00      	nop
 8000a0c:	200002b0 	.word	0x200002b0
 8000a10:	20000004 	.word	0x20000004

08000a14 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000a14:	4b01      	ldr	r3, [pc, #4]	; (8000a1c <HAL_GetTick+0x8>)
 8000a16:	6818      	ldr	r0, [r3, #0]
}
 8000a18:	4770      	bx	lr
 8000a1a:	bf00      	nop
 8000a1c:	200002b0 	.word	0x200002b0

08000a20 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000a20:	b538      	push	{r3, r4, r5, lr}
 8000a22:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000a24:	f7ff fff6 	bl	8000a14 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000a28:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8000a2a:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 8000a2c:	d002      	beq.n	8000a34 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8000a2e:	4b04      	ldr	r3, [pc, #16]	; (8000a40 <HAL_Delay+0x20>)
 8000a30:	781b      	ldrb	r3, [r3, #0]
 8000a32:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000a34:	f7ff ffee 	bl	8000a14 <HAL_GetTick>
 8000a38:	1b40      	subs	r0, r0, r5
 8000a3a:	42a0      	cmp	r0, r4
 8000a3c:	d3fa      	bcc.n	8000a34 <HAL_Delay+0x14>
  {
  }
}
 8000a3e:	bd38      	pop	{r3, r4, r5, pc}
 8000a40:	20000004 	.word	0x20000004

08000a44 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000a44:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000a48:	4906      	ldr	r1, [pc, #24]	; (8000a64 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 8000a4a:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000a4c:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 8000a4e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000a52:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000a56:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8000a58:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000a5c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8000a60:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8000a62:	4770      	bx	lr
 8000a64:	e000ed00 	.word	0xe000ed00

08000a68 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000a68:	4b1c      	ldr	r3, [pc, #112]	; (8000adc <HAL_NVIC_SetPriority+0x74>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000a6a:	b500      	push	{lr}
 8000a6c:	68db      	ldr	r3, [r3, #12]
 8000a6e:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000a72:	f1c3 0e07 	rsb	lr, r3, #7
 8000a76:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a7a:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000a7e:	bf28      	it	cs
 8000a80:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a84:	f1bc 0f06 	cmp.w	ip, #6
 8000a88:	d91b      	bls.n	8000ac2 <HAL_NVIC_SetPriority+0x5a>

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000a8a:	f04f 3cff 	mov.w	ip, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a8e:	3b03      	subs	r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000a90:	fa0c fc03 	lsl.w	ip, ip, r3
 8000a94:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000a98:	f04f 3cff 	mov.w	ip, #4294967295
 8000a9c:	fa0c fc0e 	lsl.w	ip, ip, lr
 8000aa0:	ea21 010c 	bic.w	r1, r1, ip
 8000aa4:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8000aa6:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000aa8:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 8000aac:	db0c      	blt.n	8000ac8 <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000aae:	0109      	lsls	r1, r1, #4
 8000ab0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000ab4:	b2c9      	uxtb	r1, r1
 8000ab6:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000aba:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000abe:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ac2:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000ac4:	4613      	mov	r3, r2
 8000ac6:	e7e7      	b.n	8000a98 <HAL_NVIC_SetPriority+0x30>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ac8:	4b05      	ldr	r3, [pc, #20]	; (8000ae0 <HAL_NVIC_SetPriority+0x78>)
 8000aca:	f000 000f 	and.w	r0, r0, #15
 8000ace:	0109      	lsls	r1, r1, #4
 8000ad0:	b2c9      	uxtb	r1, r1
 8000ad2:	4403      	add	r3, r0
 8000ad4:	7619      	strb	r1, [r3, #24]
 8000ad6:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ada:	bf00      	nop
 8000adc:	e000ed00 	.word	0xe000ed00
 8000ae0:	e000ecfc 	.word	0xe000ecfc

08000ae4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000ae4:	2800      	cmp	r0, #0
 8000ae6:	db07      	blt.n	8000af8 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000ae8:	2301      	movs	r3, #1
 8000aea:	f000 011f 	and.w	r1, r0, #31
 8000aee:	4a03      	ldr	r2, [pc, #12]	; (8000afc <HAL_NVIC_EnableIRQ+0x18>)
 8000af0:	0940      	lsrs	r0, r0, #5
 8000af2:	408b      	lsls	r3, r1
 8000af4:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000af8:	4770      	bx	lr
 8000afa:	bf00      	nop
 8000afc:	e000e100 	.word	0xe000e100

08000b00 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000b00:	3801      	subs	r0, #1
 8000b02:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000b06:	d20f      	bcs.n	8000b28 <HAL_SYSTICK_Config+0x28>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000b08:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b0c:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000b10:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000b12:	2107      	movs	r1, #7
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000b14:	b410      	push	{r4}
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b16:	4c05      	ldr	r4, [pc, #20]	; (8000b2c <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000b18:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b1a:	f884 c023 	strb.w	ip, [r4, #35]	; 0x23
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000b1e:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000b20:	619a      	str	r2, [r3, #24]
   return SysTick_Config(TicksNumb);
}
 8000b22:	bc10      	pop	{r4}
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000b24:	6119      	str	r1, [r3, #16]
 8000b26:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000b28:	2001      	movs	r0, #1
 8000b2a:	4770      	bx	lr
 8000b2c:	e000ed00 	.word	0xe000ed00

08000b30 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp = 0U;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8000b30:	b340      	cbz	r0, 8000b84 <HAL_DMA_Init+0x54>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8000b32:	4603      	mov	r3, r0
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000b34:	c805      	ldmia	r0, {r0, r2}
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 8000b36:	f44f 7c80 	mov.w	ip, #256	; 0x100
{
 8000b3a:	b430      	push	{r4, r5}
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000b3c:	2400      	movs	r4, #0
  tmp |=  hdma->Init.Direction        |
 8000b3e:	6899      	ldr	r1, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000b40:	68dd      	ldr	r5, [r3, #12]
  tmp |=  hdma->Init.Direction        |
 8000b42:	430a      	orrs	r2, r1
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8000b44:	4910      	ldr	r1, [pc, #64]	; (8000b88 <HAL_DMA_Init+0x58>)
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000b46:	432a      	orrs	r2, r5
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8000b48:	4d10      	ldr	r5, [pc, #64]	; (8000b8c <HAL_DMA_Init+0x5c>)
 8000b4a:	4401      	add	r1, r0
 8000b4c:	fba5 5101 	umull	r5, r1, r5, r1
 8000b50:	0909      	lsrs	r1, r1, #4
 8000b52:	0089      	lsls	r1, r1, #2
 8000b54:	6419      	str	r1, [r3, #64]	; 0x40
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000b56:	6919      	ldr	r1, [r3, #16]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000b58:	699d      	ldr	r5, [r3, #24]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000b5a:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000b5c:	6959      	ldr	r1, [r3, #20]
 8000b5e:	430a      	orrs	r2, r1
  tmp = hdma->Instance->CCR;
 8000b60:	6801      	ldr	r1, [r0, #0]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000b62:	432a      	orrs	r2, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8000b64:	69dd      	ldr	r5, [r3, #28]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8000b66:	f421 517f 	bic.w	r1, r1, #16320	; 0x3fc0
 8000b6a:	f021 0130 	bic.w	r1, r1, #48	; 0x30
          hdma->Init.Mode                | hdma->Init.Priority;
 8000b6e:	432a      	orrs	r2, r5
  tmp |=  hdma->Init.Direction        |
 8000b70:	430a      	orrs	r2, r1
  hdma->DmaBaseAddress = DMA1;
 8000b72:	4907      	ldr	r1, [pc, #28]	; (8000b90 <HAL_DMA_Init+0x60>)
 8000b74:	63d9      	str	r1, [r3, #60]	; 0x3c
  hdma->Instance->CCR = tmp;
 8000b76:	6002      	str	r2, [r0, #0]
  hdma->Lock = HAL_UNLOCKED;
 8000b78:	f8a3 c020 	strh.w	ip, [r3, #32]

  return HAL_OK;
 8000b7c:	4620      	mov	r0, r4
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000b7e:	639c      	str	r4, [r3, #56]	; 0x38
}
 8000b80:	bc30      	pop	{r4, r5}
 8000b82:	4770      	bx	lr
    return HAL_ERROR;
 8000b84:	2001      	movs	r0, #1
}
 8000b86:	4770      	bx	lr
 8000b88:	bffdfff8 	.word	0xbffdfff8
 8000b8c:	cccccccd 	.word	0xcccccccd
 8000b90:	40020000 	.word	0x40020000

08000b94 <HAL_DMA_IRQHandler>:
{
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
  uint32_t source_it = hdma->Instance->CCR;
  
  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8000b94:	2204      	movs	r2, #4
{
 8000b96:	b470      	push	{r4, r5, r6}
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8000b98:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8000b9a:	6c01      	ldr	r1, [r0, #64]	; 0x40
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8000b9c:	6834      	ldr	r4, [r6, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8000b9e:	6803      	ldr	r3, [r0, #0]
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8000ba0:	408a      	lsls	r2, r1
 8000ba2:	4222      	tst	r2, r4
  uint32_t source_it = hdma->Instance->CCR;
 8000ba4:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8000ba6:	d01f      	beq.n	8000be8 <HAL_DMA_IRQHandler+0x54>
 8000ba8:	076a      	lsls	r2, r5, #29
 8000baa:	d51d      	bpl.n	8000be8 <HAL_DMA_IRQHandler+0x54>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8000bac:	681a      	ldr	r2, [r3, #0]
 8000bae:	0691      	lsls	r1, r2, #26
 8000bb0:	d403      	bmi.n	8000bba <HAL_DMA_IRQHandler+0x26>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8000bb2:	681a      	ldr	r2, [r3, #0]
 8000bb4:	f022 0204 	bic.w	r2, r2, #4
 8000bb8:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000bba:	4a3e      	ldr	r2, [pc, #248]	; (8000cb4 <HAL_DMA_IRQHandler+0x120>)
 8000bbc:	4293      	cmp	r3, r2
 8000bbe:	d050      	beq.n	8000c62 <HAL_DMA_IRQHandler+0xce>
 8000bc0:	3214      	adds	r2, #20
 8000bc2:	4293      	cmp	r3, r2
 8000bc4:	d060      	beq.n	8000c88 <HAL_DMA_IRQHandler+0xf4>
 8000bc6:	3214      	adds	r2, #20
 8000bc8:	4293      	cmp	r3, r2
 8000bca:	d067      	beq.n	8000c9c <HAL_DMA_IRQHandler+0x108>
 8000bcc:	3214      	adds	r2, #20
 8000bce:	4293      	cmp	r3, r2
 8000bd0:	d06a      	beq.n	8000ca8 <HAL_DMA_IRQHandler+0x114>
 8000bd2:	3214      	adds	r2, #20
 8000bd4:	4293      	cmp	r3, r2
 8000bd6:	d05c      	beq.n	8000c92 <HAL_DMA_IRQHandler+0xfe>
 8000bd8:	3214      	adds	r2, #20
 8000bda:	4293      	cmp	r3, r2
 8000bdc:	bf0c      	ite	eq
 8000bde:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 8000be2:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000be6:	e03d      	b.n	8000c64 <HAL_DMA_IRQHandler+0xd0>
      hdma->XferHalfCpltCallback(hdma);
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if (((flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_TC) != RESET))
 8000be8:	2202      	movs	r2, #2
 8000bea:	408a      	lsls	r2, r1
 8000bec:	4222      	tst	r2, r4
 8000bee:	d022      	beq.n	8000c36 <HAL_DMA_IRQHandler+0xa2>
 8000bf0:	07aa      	lsls	r2, r5, #30
 8000bf2:	d520      	bpl.n	8000c36 <HAL_DMA_IRQHandler+0xa2>
  {
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8000bf4:	681a      	ldr	r2, [r3, #0]
 8000bf6:	0691      	lsls	r1, r2, #26
 8000bf8:	d406      	bmi.n	8000c08 <HAL_DMA_IRQHandler+0x74>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8000bfa:	2101      	movs	r1, #1
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  
 8000bfc:	681a      	ldr	r2, [r3, #0]
 8000bfe:	f022 020a 	bic.w	r2, r2, #10
 8000c02:	601a      	str	r2, [r3, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8000c04:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21
    }
    /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000c08:	4a2a      	ldr	r2, [pc, #168]	; (8000cb4 <HAL_DMA_IRQHandler+0x120>)
 8000c0a:	4293      	cmp	r3, r2
 8000c0c:	d031      	beq.n	8000c72 <HAL_DMA_IRQHandler+0xde>
 8000c0e:	3214      	adds	r2, #20
 8000c10:	4293      	cmp	r3, r2
 8000c12:	d041      	beq.n	8000c98 <HAL_DMA_IRQHandler+0x104>
 8000c14:	3214      	adds	r2, #20
 8000c16:	4293      	cmp	r3, r2
 8000c18:	d043      	beq.n	8000ca2 <HAL_DMA_IRQHandler+0x10e>
 8000c1a:	3214      	adds	r2, #20
 8000c1c:	4293      	cmp	r3, r2
 8000c1e:	d035      	beq.n	8000c8c <HAL_DMA_IRQHandler+0xf8>
 8000c20:	3214      	adds	r2, #20
 8000c22:	4293      	cmp	r3, r2
 8000c24:	d043      	beq.n	8000cae <HAL_DMA_IRQHandler+0x11a>
 8000c26:	3214      	adds	r2, #20
 8000c28:	4293      	cmp	r3, r2
 8000c2a:	bf0c      	ite	eq
 8000c2c:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8000c30:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000c34:	e01e      	b.n	8000c74 <HAL_DMA_IRQHandler+0xe0>
      hdma->XferCpltCallback(hdma);
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8000c36:	2208      	movs	r2, #8
 8000c38:	408a      	lsls	r2, r1
 8000c3a:	4222      	tst	r2, r4
 8000c3c:	d017      	beq.n	8000c6e <HAL_DMA_IRQHandler+0xda>
 8000c3e:	072a      	lsls	r2, r5, #28
 8000c40:	d515      	bpl.n	8000c6e <HAL_DMA_IRQHandler+0xda>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000c42:	681a      	ldr	r2, [r3, #0]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8000c44:	f44f 7480 	mov.w	r4, #256	; 0x100
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000c48:	f022 020e 	bic.w	r2, r2, #14
 8000c4c:	601a      	str	r2, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8000c4e:	2301      	movs	r3, #1

    if (hdma->XferErrorCallback != NULL)
 8000c50:	6b02      	ldr	r2, [r0, #48]	; 0x30
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8000c52:	fa03 f101 	lsl.w	r1, r3, r1
 8000c56:	6071      	str	r1, [r6, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8000c58:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 8000c5a:	8404      	strh	r4, [r0, #32]
    if (hdma->XferErrorCallback != NULL)
 8000c5c:	b13a      	cbz	r2, 8000c6e <HAL_DMA_IRQHandler+0xda>
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
    }
  }
  return;
}
 8000c5e:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 8000c60:	4710      	bx	r2
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000c62:	2304      	movs	r3, #4
 8000c64:	4914      	ldr	r1, [pc, #80]	; (8000cb8 <HAL_DMA_IRQHandler+0x124>)
    if(hdma->XferHalfCpltCallback != NULL)
 8000c66:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000c68:	604b      	str	r3, [r1, #4]
    if(hdma->XferHalfCpltCallback != NULL)
 8000c6a:	2a00      	cmp	r2, #0
 8000c6c:	d1f7      	bne.n	8000c5e <HAL_DMA_IRQHandler+0xca>
}
 8000c6e:	bc70      	pop	{r4, r5, r6}
 8000c70:	4770      	bx	lr
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000c72:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);
 8000c74:	2100      	movs	r1, #0
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000c76:	4c10      	ldr	r4, [pc, #64]	; (8000cb8 <HAL_DMA_IRQHandler+0x124>)
    if(hdma->XferCpltCallback != NULL)
 8000c78:	6a82      	ldr	r2, [r0, #40]	; 0x28
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000c7a:	6063      	str	r3, [r4, #4]
    __HAL_UNLOCK(hdma);
 8000c7c:	f880 1020 	strb.w	r1, [r0, #32]
    if(hdma->XferCpltCallback != NULL)
 8000c80:	2a00      	cmp	r2, #0
 8000c82:	d0f4      	beq.n	8000c6e <HAL_DMA_IRQHandler+0xda>
}
 8000c84:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 8000c86:	4710      	bx	r2
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000c88:	2340      	movs	r3, #64	; 0x40
 8000c8a:	e7eb      	b.n	8000c64 <HAL_DMA_IRQHandler+0xd0>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000c8c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000c90:	e7f0      	b.n	8000c74 <HAL_DMA_IRQHandler+0xe0>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000c92:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000c96:	e7e5      	b.n	8000c64 <HAL_DMA_IRQHandler+0xd0>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000c98:	2320      	movs	r3, #32
 8000c9a:	e7eb      	b.n	8000c74 <HAL_DMA_IRQHandler+0xe0>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000c9c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000ca0:	e7e0      	b.n	8000c64 <HAL_DMA_IRQHandler+0xd0>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000ca2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ca6:	e7e5      	b.n	8000c74 <HAL_DMA_IRQHandler+0xe0>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000ca8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000cac:	e7da      	b.n	8000c64 <HAL_DMA_IRQHandler+0xd0>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000cae:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000cb2:	e7df      	b.n	8000c74 <HAL_DMA_IRQHandler+0xe0>
 8000cb4:	40020008 	.word	0x40020008
 8000cb8:	40020000 	.word	0x40020000

08000cbc <HAL_FLASH_Program>:
  * @param  Data:         Specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8000cbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8000cc0:	f8df 91c4 	ldr.w	r9, [pc, #452]	; 8000e88 <HAL_FLASH_Program+0x1cc>
{
 8000cc4:	b083      	sub	sp, #12
  __HAL_LOCK(&pFlash);
 8000cc6:	f899 4018 	ldrb.w	r4, [r9, #24]
 8000cca:	2c01      	cmp	r4, #1
 8000ccc:	f000 80cf 	beq.w	8000e6e <HAL_FLASH_Program+0x1b2>
 8000cd0:	469a      	mov	sl, r3
 8000cd2:	2301      	movs	r3, #1
 8000cd4:	4606      	mov	r6, r0
 8000cd6:	4688      	mov	r8, r1
 8000cd8:	4693      	mov	fp, r2
 8000cda:	f889 3018 	strb.w	r3, [r9, #24]
{
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
     
  uint32_t tickstart = HAL_GetTick();
 8000cde:	f7ff fe99 	bl	8000a14 <HAL_GetTick>
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
  { 
    if (Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000ce2:	f24c 3750 	movw	r7, #50000	; 0xc350
  uint32_t tickstart = HAL_GetTick();
 8000ce6:	4604      	mov	r4, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000ce8:	4d68      	ldr	r5, [pc, #416]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000cea:	e005      	b.n	8000cf8 <HAL_FLASH_Program+0x3c>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000cec:	f7ff fe92 	bl	8000a14 <HAL_GetTick>
 8000cf0:	1b00      	subs	r0, r0, r4
 8000cf2:	42b8      	cmp	r0, r7
 8000cf4:	f200 80b9 	bhi.w	8000e6a <HAL_FLASH_Program+0x1ae>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000cf8:	68eb      	ldr	r3, [r5, #12]
 8000cfa:	07da      	lsls	r2, r3, #31
 8000cfc:	d4f6      	bmi.n	8000cec <HAL_FLASH_Program+0x30>
      }
    }
  }
  
  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8000cfe:	68eb      	ldr	r3, [r5, #12]
 8000d00:	069b      	lsls	r3, r3, #26
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000d02:	bf44      	itt	mi
 8000d04:	2320      	movmi	r3, #32
 8000d06:	60eb      	strmi	r3, [r5, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000d08:	4b60      	ldr	r3, [pc, #384]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000d0a:	68da      	ldr	r2, [r3, #12]
 8000d0c:	06d7      	lsls	r7, r2, #27
 8000d0e:	d453      	bmi.n	8000db8 <HAL_FLASH_Program+0xfc>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000d10:	69da      	ldr	r2, [r3, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000d12:	07d5      	lsls	r5, r2, #31
 8000d14:	d450      	bmi.n	8000db8 <HAL_FLASH_Program+0xfc>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000d16:	68df      	ldr	r7, [r3, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000d18:	f017 0704 	ands.w	r7, r7, #4
 8000d1c:	d14c      	bne.n	8000db8 <HAL_FLASH_Program+0xfc>
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8000d1e:	2e01      	cmp	r6, #1
 8000d20:	d003      	beq.n	8000d2a <HAL_FLASH_Program+0x6e>
      nbiterations = 4U;
 8000d22:	2e02      	cmp	r6, #2
 8000d24:	bf0c      	ite	eq
 8000d26:	2602      	moveq	r6, #2
 8000d28:	2604      	movne	r6, #4
    for (index = 0U; index < nbiterations; index++)
 8000d2a:	eb08 0346 	add.w	r3, r8, r6, lsl #1
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000d2e:	f24c 3650 	movw	r6, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000d32:	4c56      	ldr	r4, [pc, #344]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000d34:	9301      	str	r3, [sp, #4]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000d36:	f1c7 0120 	rsb	r1, r7, #32
 8000d3a:	fa0a f101 	lsl.w	r1, sl, r1
 8000d3e:	fa2b f307 	lsr.w	r3, fp, r7
 8000d42:	430b      	orrs	r3, r1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8000d44:	2100      	movs	r1, #0
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000d46:	f1a7 0220 	sub.w	r2, r7, #32
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8000d4a:	f8c9 101c 	str.w	r1, [r9, #28]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000d4e:	fa2a f202 	lsr.w	r2, sl, r2
 8000d52:	4313      	orrs	r3, r2
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000d54:	6922      	ldr	r2, [r4, #16]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000d56:	b29b      	uxth	r3, r3
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000d58:	f042 0201 	orr.w	r2, r2, #1
 8000d5c:	6122      	str	r2, [r4, #16]
  *(__IO uint16_t*)Address = Data;
 8000d5e:	f8a8 3000 	strh.w	r3, [r8]
  uint32_t tickstart = HAL_GetTick();
 8000d62:	f7ff fe57 	bl	8000a14 <HAL_GetTick>
 8000d66:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000d68:	e004      	b.n	8000d74 <HAL_FLASH_Program+0xb8>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000d6a:	f7ff fe53 	bl	8000a14 <HAL_GetTick>
 8000d6e:	1b40      	subs	r0, r0, r5
 8000d70:	42b0      	cmp	r0, r6
 8000d72:	d872      	bhi.n	8000e5a <HAL_FLASH_Program+0x19e>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000d74:	68e3      	ldr	r3, [r4, #12]
 8000d76:	07d9      	lsls	r1, r3, #31
 8000d78:	d4f7      	bmi.n	8000d6a <HAL_FLASH_Program+0xae>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8000d7a:	68e3      	ldr	r3, [r4, #12]
 8000d7c:	069a      	lsls	r2, r3, #26
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000d7e:	bf44      	itt	mi
 8000d80:	2320      	movmi	r3, #32
 8000d82:	60e3      	strmi	r3, [r4, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000d84:	68e3      	ldr	r3, [r4, #12]
 8000d86:	06db      	lsls	r3, r3, #27
 8000d88:	d439      	bmi.n	8000dfe <HAL_FLASH_Program+0x142>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000d8a:	69e3      	ldr	r3, [r4, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000d8c:	07dd      	lsls	r5, r3, #31
 8000d8e:	d436      	bmi.n	8000dfe <HAL_FLASH_Program+0x142>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000d90:	68e0      	ldr	r0, [r4, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000d92:	f010 0004 	ands.w	r0, r0, #4
 8000d96:	d132      	bne.n	8000dfe <HAL_FLASH_Program+0x142>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000d98:	6923      	ldr	r3, [r4, #16]
    for (index = 0U; index < nbiterations; index++)
 8000d9a:	f108 0802 	add.w	r8, r8, #2
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000d9e:	f023 0301 	bic.w	r3, r3, #1
 8000da2:	6123      	str	r3, [r4, #16]
    for (index = 0U; index < nbiterations; index++)
 8000da4:	9b01      	ldr	r3, [sp, #4]
 8000da6:	3710      	adds	r7, #16
 8000da8:	4598      	cmp	r8, r3
 8000daa:	d1c4      	bne.n	8000d36 <HAL_FLASH_Program+0x7a>
  __HAL_UNLOCK(&pFlash);
 8000dac:	2300      	movs	r3, #0
 8000dae:	f889 3018 	strb.w	r3, [r9, #24]
}
 8000db2:	b003      	add	sp, #12
 8000db4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint32_t flags = 0U;
  
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8000db8:	4b34      	ldr	r3, [pc, #208]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000dba:	68db      	ldr	r3, [r3, #12]
 8000dbc:	f013 0310 	ands.w	r3, r3, #16
 8000dc0:	d159      	bne.n	8000e76 <HAL_FLASH_Program+0x1ba>
 8000dc2:	2104      	movs	r1, #4
#endif /* FLASH_BANK2_END */
  }
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000dc4:	4a31      	ldr	r2, [pc, #196]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000dc6:	68d2      	ldr	r2, [r2, #12]
 8000dc8:	0754      	lsls	r4, r2, #29
 8000dca:	d506      	bpl.n	8000dda <HAL_FLASH_Program+0x11e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
#if defined(FLASH_BANK2_END)
    flags |= FLASH_FLAG_PGERR | FLASH_FLAG_PGERR_BANK2;
#else
    flags |= FLASH_FLAG_PGERR;
 8000dcc:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8000dce:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8000dd2:	f042 0201 	orr.w	r2, r2, #1
 8000dd6:	f8c9 201c 	str.w	r2, [r9, #28]
#endif /* FLASH_BANK2_END */
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8000dda:	4a2c      	ldr	r2, [pc, #176]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000ddc:	69d1      	ldr	r1, [r2, #28]
 8000dde:	07c8      	lsls	r0, r1, #31
 8000de0:	d509      	bpl.n	8000df6 <HAL_FLASH_Program+0x13a>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8000de2:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8000de6:	f041 0104 	orr.w	r1, r1, #4
 8000dea:	f8c9 101c 	str.w	r1, [r9, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8000dee:	69d1      	ldr	r1, [r2, #28]
 8000df0:	f021 0101 	bic.w	r1, r1, #1
 8000df4:	61d1      	str	r1, [r2, #28]
  }

  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000df6:	4a25      	ldr	r2, [pc, #148]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
    return HAL_ERROR;
 8000df8:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000dfa:	60d3      	str	r3, [r2, #12]
  if(status == HAL_OK)
 8000dfc:	e7d6      	b.n	8000dac <HAL_FLASH_Program+0xf0>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8000dfe:	4b23      	ldr	r3, [pc, #140]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000e00:	68da      	ldr	r2, [r3, #12]
 8000e02:	f012 0210 	ands.w	r2, r2, #16
 8000e06:	d02e      	beq.n	8000e66 <HAL_FLASH_Program+0x1aa>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000e08:	2114      	movs	r1, #20
    flags |= FLASH_FLAG_WRPERR;
 8000e0a:	2210      	movs	r2, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000e0c:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8000e10:	f043 0302 	orr.w	r3, r3, #2
 8000e14:	f8c9 301c 	str.w	r3, [r9, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000e18:	4b1c      	ldr	r3, [pc, #112]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000e1a:	68db      	ldr	r3, [r3, #12]
 8000e1c:	0758      	lsls	r0, r3, #29
 8000e1e:	d506      	bpl.n	8000e2e <HAL_FLASH_Program+0x172>
    flags |= FLASH_FLAG_PGERR;
 8000e20:	460a      	mov	r2, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8000e22:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8000e26:	f043 0301 	orr.w	r3, r3, #1
 8000e2a:	f8c9 301c 	str.w	r3, [r9, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8000e2e:	4b17      	ldr	r3, [pc, #92]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
 8000e30:	69d9      	ldr	r1, [r3, #28]
 8000e32:	07c9      	lsls	r1, r1, #31
 8000e34:	d509      	bpl.n	8000e4a <HAL_FLASH_Program+0x18e>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8000e36:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8000e3a:	f041 0104 	orr.w	r1, r1, #4
 8000e3e:	f8c9 101c 	str.w	r1, [r9, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8000e42:	69d9      	ldr	r1, [r3, #28]
 8000e44:	f021 0101 	bic.w	r1, r1, #1
 8000e48:	61d9      	str	r1, [r3, #28]
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000e4a:	4b10      	ldr	r3, [pc, #64]	; (8000e8c <HAL_FLASH_Program+0x1d0>)
    return HAL_ERROR;
 8000e4c:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000e4e:	60da      	str	r2, [r3, #12]
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000e50:	691a      	ldr	r2, [r3, #16]
 8000e52:	f022 0201 	bic.w	r2, r2, #1
 8000e56:	611a      	str	r2, [r3, #16]
      if (status != HAL_OK)
 8000e58:	e7a8      	b.n	8000dac <HAL_FLASH_Program+0xf0>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000e5a:	6923      	ldr	r3, [r4, #16]
 8000e5c:	2003      	movs	r0, #3
 8000e5e:	f023 0301 	bic.w	r3, r3, #1
 8000e62:	6123      	str	r3, [r4, #16]
      if (status != HAL_OK)
 8000e64:	e7a2      	b.n	8000dac <HAL_FLASH_Program+0xf0>
 8000e66:	2104      	movs	r1, #4
 8000e68:	e7d6      	b.n	8000e18 <HAL_FLASH_Program+0x15c>
 8000e6a:	2003      	movs	r0, #3
 8000e6c:	e79e      	b.n	8000dac <HAL_FLASH_Program+0xf0>
  __HAL_LOCK(&pFlash);
 8000e6e:	2002      	movs	r0, #2
}
 8000e70:	b003      	add	sp, #12
 8000e72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000e76:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8000e7a:	2114      	movs	r1, #20
 8000e7c:	f042 0202 	orr.w	r2, r2, #2
    flags |= FLASH_FLAG_WRPERR;
 8000e80:	2310      	movs	r3, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000e82:	f8c9 201c 	str.w	r2, [r9, #28]
    flags |= FLASH_FLAG_WRPERR;
 8000e86:	e79d      	b.n	8000dc4 <HAL_FLASH_Program+0x108>
 8000e88:	200002b8 	.word	0x200002b8
 8000e8c:	40022000 	.word	0x40022000

08000e90 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8000e90:	4b06      	ldr	r3, [pc, #24]	; (8000eac <HAL_FLASH_Unlock+0x1c>)
 8000e92:	6918      	ldr	r0, [r3, #16]
 8000e94:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8000e98:	d006      	beq.n	8000ea8 <HAL_FLASH_Unlock+0x18>
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8000e9a:	4905      	ldr	r1, [pc, #20]	; (8000eb0 <HAL_FLASH_Unlock+0x20>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8000e9c:	4a05      	ldr	r2, [pc, #20]	; (8000eb4 <HAL_FLASH_Unlock+0x24>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8000e9e:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8000ea0:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8000ea2:	6918      	ldr	r0, [r3, #16]
  HAL_StatusTypeDef status = HAL_OK;
 8000ea4:	f3c0 10c0 	ubfx	r0, r0, #7, #1
}
 8000ea8:	4770      	bx	lr
 8000eaa:	bf00      	nop
 8000eac:	40022000 	.word	0x40022000
 8000eb0:	45670123 	.word	0x45670123
 8000eb4:	cdef89ab 	.word	0xcdef89ab

08000eb8 <FLASH_WaitForLastOperation>:
{
 8000eb8:	b570      	push	{r4, r5, r6, lr}
 8000eba:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000ebc:	f7ff fdaa 	bl	8000a14 <HAL_GetTick>
 8000ec0:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000ec2:	4e26      	ldr	r6, [pc, #152]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000ec4:	1c60      	adds	r0, r4, #1
 8000ec6:	d136      	bne.n	8000f36 <FLASH_WaitForLastOperation+0x7e>
 8000ec8:	4a24      	ldr	r2, [pc, #144]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000eca:	68d3      	ldr	r3, [r2, #12]
 8000ecc:	07d9      	lsls	r1, r3, #31
 8000ece:	d4fc      	bmi.n	8000eca <FLASH_WaitForLastOperation+0x12>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8000ed0:	4b22      	ldr	r3, [pc, #136]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000ed2:	68da      	ldr	r2, [r3, #12]
 8000ed4:	0696      	lsls	r6, r2, #26
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000ed6:	bf44      	itt	mi
 8000ed8:	2220      	movmi	r2, #32
 8000eda:	60da      	strmi	r2, [r3, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000edc:	4b1f      	ldr	r3, [pc, #124]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000ede:	68da      	ldr	r2, [r3, #12]
 8000ee0:	06d5      	lsls	r5, r2, #27
 8000ee2:	d407      	bmi.n	8000ef4 <FLASH_WaitForLastOperation+0x3c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000ee4:	69da      	ldr	r2, [r3, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000ee6:	07d4      	lsls	r4, r2, #31
 8000ee8:	d404      	bmi.n	8000ef4 <FLASH_WaitForLastOperation+0x3c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000eea:	68d8      	ldr	r0, [r3, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000eec:	f010 0004 	ands.w	r0, r0, #4
 8000ef0:	d100      	bne.n	8000ef4 <FLASH_WaitForLastOperation+0x3c>
}
 8000ef2:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8000ef4:	4b19      	ldr	r3, [pc, #100]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000ef6:	68db      	ldr	r3, [r3, #12]
 8000ef8:	f013 0310 	ands.w	r3, r3, #16
 8000efc:	d126      	bne.n	8000f4c <FLASH_WaitForLastOperation+0x94>
 8000efe:	2104      	movs	r1, #4
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000f00:	4a16      	ldr	r2, [pc, #88]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000f02:	68d2      	ldr	r2, [r2, #12]
 8000f04:	0750      	lsls	r0, r2, #29
 8000f06:	d505      	bpl.n	8000f14 <FLASH_WaitForLastOperation+0x5c>
    flags |= FLASH_FLAG_PGERR;
 8000f08:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8000f0a:	4915      	ldr	r1, [pc, #84]	; (8000f60 <FLASH_WaitForLastOperation+0xa8>)
 8000f0c:	69ca      	ldr	r2, [r1, #28]
 8000f0e:	f042 0201 	orr.w	r2, r2, #1
 8000f12:	61ca      	str	r2, [r1, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8000f14:	4a11      	ldr	r2, [pc, #68]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
 8000f16:	69d1      	ldr	r1, [r2, #28]
 8000f18:	07c9      	lsls	r1, r1, #31
 8000f1a:	d508      	bpl.n	8000f2e <FLASH_WaitForLastOperation+0x76>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8000f1c:	4810      	ldr	r0, [pc, #64]	; (8000f60 <FLASH_WaitForLastOperation+0xa8>)
 8000f1e:	69c1      	ldr	r1, [r0, #28]
 8000f20:	f041 0104 	orr.w	r1, r1, #4
 8000f24:	61c1      	str	r1, [r0, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8000f26:	69d1      	ldr	r1, [r2, #28]
 8000f28:	f021 0101 	bic.w	r1, r1, #1
 8000f2c:	61d1      	str	r1, [r2, #28]
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000f2e:	4a0b      	ldr	r2, [pc, #44]	; (8000f5c <FLASH_WaitForLastOperation+0xa4>)
    return HAL_ERROR;
 8000f30:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000f32:	60d3      	str	r3, [r2, #12]
}
 8000f34:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000f36:	68f3      	ldr	r3, [r6, #12]
 8000f38:	07db      	lsls	r3, r3, #31
 8000f3a:	d5c9      	bpl.n	8000ed0 <FLASH_WaitForLastOperation+0x18>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000f3c:	b124      	cbz	r4, 8000f48 <FLASH_WaitForLastOperation+0x90>
 8000f3e:	f7ff fd69 	bl	8000a14 <HAL_GetTick>
 8000f42:	1b40      	subs	r0, r0, r5
 8000f44:	42a0      	cmp	r0, r4
 8000f46:	d9bd      	bls.n	8000ec4 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 8000f48:	2003      	movs	r0, #3
}
 8000f4a:	bd70      	pop	{r4, r5, r6, pc}
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000f4c:	4804      	ldr	r0, [pc, #16]	; (8000f60 <FLASH_WaitForLastOperation+0xa8>)
 8000f4e:	2114      	movs	r1, #20
 8000f50:	69c2      	ldr	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 8000f52:	2310      	movs	r3, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000f54:	f042 0202 	orr.w	r2, r2, #2
 8000f58:	61c2      	str	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 8000f5a:	e7d1      	b.n	8000f00 <FLASH_WaitForLastOperation+0x48>
 8000f5c:	40022000 	.word	0x40022000
 8000f60:	200002b8 	.word	0x200002b8

08000f64 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8000f64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0U;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8000f68:	4e2d      	ldr	r6, [pc, #180]	; (8001020 <HAL_FLASHEx_Erase+0xbc>)
 8000f6a:	7e33      	ldrb	r3, [r6, #24]
 8000f6c:	2b01      	cmp	r3, #1
 8000f6e:	d054      	beq.n	800101a <HAL_FLASHEx_Erase+0xb6>
 8000f70:	2301      	movs	r3, #1
 8000f72:	7633      	strb	r3, [r6, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8000f74:	6803      	ldr	r3, [r0, #0]
 8000f76:	4681      	mov	r9, r0
 8000f78:	2b02      	cmp	r3, #2
 8000f7a:	d031      	beq.n	8000fe0 <HAL_FLASHEx_Erase+0x7c>
    else
#endif /* FLASH_BANK2_END */
   {
      /* Page Erase requested on address located on bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8000f7c:	f24c 3050 	movw	r0, #50000	; 0xc350
 8000f80:	4688      	mov	r8, r1
 8000f82:	f7ff ff99 	bl	8000eb8 <FLASH_WaitForLastOperation>
 8000f86:	4607      	mov	r7, r0
 8000f88:	bb78      	cbnz	r0, 8000fea <HAL_FLASHEx_Erase+0x86>
      {
        /*Initialization of PageError variable*/
        *PageError = 0xFFFFFFFFU;
 8000f8a:	f04f 33ff 	mov.w	r3, #4294967295
 8000f8e:	f8c8 3000 	str.w	r3, [r8]
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 8000f92:	e9d9 5302 	ldrd	r5, r3, [r9, #8]
 8000f96:	eb05 2383 	add.w	r3, r5, r3, lsl #10
        for(address = pEraseInit->PageAddress;
 8000f9a:	429d      	cmp	r5, r3
 8000f9c:	d225      	bcs.n	8000fea <HAL_FLASHEx_Erase+0x86>
  }
  else
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 8000f9e:	4c21      	ldr	r4, [pc, #132]	; (8001024 <HAL_FLASHEx_Erase+0xc0>)
 8000fa0:	e007      	b.n	8000fb2 <HAL_FLASHEx_Erase+0x4e>
            address += FLASH_PAGE_SIZE)
 8000fa2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 8000fa6:	e9d9 3202 	ldrd	r3, r2, [r9, #8]
 8000faa:	eb03 2382 	add.w	r3, r3, r2, lsl #10
        for(address = pEraseInit->PageAddress;
 8000fae:	42ab      	cmp	r3, r5
 8000fb0:	d91c      	bls.n	8000fec <HAL_FLASHEx_Erase+0x88>
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8000fb2:	61f7      	str	r7, [r6, #28]
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 8000fb4:	6923      	ldr	r3, [r4, #16]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8000fb6:	f24c 3050 	movw	r0, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 8000fba:	f043 0302 	orr.w	r3, r3, #2
 8000fbe:	6123      	str	r3, [r4, #16]
    WRITE_REG(FLASH->AR, PageAddress);
 8000fc0:	6165      	str	r5, [r4, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8000fc2:	6923      	ldr	r3, [r4, #16]
 8000fc4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000fc8:	6123      	str	r3, [r4, #16]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8000fca:	f7ff ff75 	bl	8000eb8 <FLASH_WaitForLastOperation>
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8000fce:	6923      	ldr	r3, [r4, #16]
 8000fd0:	f023 0302 	bic.w	r3, r3, #2
 8000fd4:	6123      	str	r3, [r4, #16]
          if (status != HAL_OK)
 8000fd6:	2800      	cmp	r0, #0
 8000fd8:	d0e3      	beq.n	8000fa2 <HAL_FLASHEx_Erase+0x3e>
            *PageError = address;
 8000fda:	f8c8 5000 	str.w	r5, [r8]
            break;
 8000fde:	e005      	b.n	8000fec <HAL_FLASHEx_Erase+0x88>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8000fe0:	f24c 3050 	movw	r0, #50000	; 0xc350
 8000fe4:	f7ff ff68 	bl	8000eb8 <FLASH_WaitForLastOperation>
 8000fe8:	b120      	cbz	r0, 8000ff4 <HAL_FLASHEx_Erase+0x90>
  HAL_StatusTypeDef status = HAL_ERROR;
 8000fea:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 8000fec:	2300      	movs	r3, #0
 8000fee:	7633      	strb	r3, [r6, #24]
}
 8000ff0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8000ff4:	4c0b      	ldr	r4, [pc, #44]	; (8001024 <HAL_FLASHEx_Erase+0xc0>)
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8000ff6:	61f0      	str	r0, [r6, #28]
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8000ff8:	6923      	ldr	r3, [r4, #16]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8000ffa:	f24c 3050 	movw	r0, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8000ffe:	f043 0304 	orr.w	r3, r3, #4
 8001002:	6123      	str	r3, [r4, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8001004:	6923      	ldr	r3, [r4, #16]
 8001006:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800100a:	6123      	str	r3, [r4, #16]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800100c:	f7ff ff54 	bl	8000eb8 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 8001010:	6923      	ldr	r3, [r4, #16]
 8001012:	f023 0304 	bic.w	r3, r3, #4
 8001016:	6123      	str	r3, [r4, #16]
 8001018:	e7e8      	b.n	8000fec <HAL_FLASHEx_Erase+0x88>
  __HAL_LOCK(&pFlash);
 800101a:	2002      	movs	r0, #2
}
 800101c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001020:	200002b8 	.word	0x200002b8
 8001024:	40022000 	.word	0x40022000

08001028 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001028:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800102c:	680e      	ldr	r6, [r1, #0]
{
 800102e:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001030:	2e00      	cmp	r6, #0
 8001032:	f000 80b5 	beq.w	80011a0 <HAL_GPIO_Init+0x178>
 8001036:	2200      	movs	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001038:	4f7a      	ldr	r7, [pc, #488]	; (8001224 <HAL_GPIO_Init+0x1fc>)
  uint32_t config = 0x00u;
 800103a:	4692      	mov	sl, r2
  uint32_t position = 0x00u;
 800103c:	4613      	mov	r3, r2
        {
          SET_BIT(EXTI->FTSR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 800103e:	4d7a      	ldr	r5, [pc, #488]	; (8001228 <HAL_GPIO_Init+0x200>)
      switch (GPIO_Init->Mode)
 8001040:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 800122c <HAL_GPIO_Init+0x204>
 8001044:	e006      	b.n	8001054 <HAL_GPIO_Init+0x2c>
        }
      }
    }

	position++;
 8001046:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001048:	fa36 f403 	lsrs.w	r4, r6, r3
 800104c:	f102 0204 	add.w	r2, r2, #4
 8001050:	f000 80a6 	beq.w	80011a0 <HAL_GPIO_Init+0x178>
    ioposition = (0x01uL << position);
 8001054:	2401      	movs	r4, #1
 8001056:	409c      	lsls	r4, r3
    if (iocurrent == ioposition)
 8001058:	ea34 0e06 	bics.w	lr, r4, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800105c:	ea04 0c06 	and.w	ip, r4, r6
    if (iocurrent == ioposition)
 8001060:	d1f1      	bne.n	8001046 <HAL_GPIO_Init+0x1e>
      switch (GPIO_Init->Mode)
 8001062:	684e      	ldr	r6, [r1, #4]
 8001064:	2e12      	cmp	r6, #18
 8001066:	f200 809e 	bhi.w	80011a6 <HAL_GPIO_Init+0x17e>
 800106a:	2e12      	cmp	r6, #18
 800106c:	d81a      	bhi.n	80010a4 <HAL_GPIO_Init+0x7c>
 800106e:	e8df f006 	tbb	[pc, r6]
 8001072:	b9a7      	.short	0xb9a7
 8001074:	1919ceb5 	.word	0x1919ceb5
 8001078:	19191919 	.word	0x19191919
 800107c:	19191919 	.word	0x19191919
 8001080:	b1191919 	.word	0xb1191919
 8001084:	bc          	.byte	0xbc
 8001085:	00          	.byte	0x00
 8001086:	f8df e1a8 	ldr.w	lr, [pc, #424]	; 8001230 <HAL_GPIO_Init+0x208>
 800108a:	4576      	cmp	r6, lr
 800108c:	f000 8098 	beq.w	80011c0 <HAL_GPIO_Init+0x198>
 8001090:	f50e 2e70 	add.w	lr, lr, #983040	; 0xf0000
 8001094:	4576      	cmp	r6, lr
 8001096:	f000 8093 	beq.w	80011c0 <HAL_GPIO_Init+0x198>
 800109a:	f5ae 1e80 	sub.w	lr, lr, #1048576	; 0x100000
 800109e:	4576      	cmp	r6, lr
 80010a0:	f000 808e 	beq.w	80011c0 <HAL_GPIO_Init+0x198>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80010a4:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 80010a8:	bf9c      	itt	ls
 80010aa:	4686      	movls	lr, r0
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80010ac:	4693      	movls	fp, r2
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80010ae:	f04f 060f 	mov.w	r6, #15
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80010b2:	bf84      	itt	hi
 80010b4:	f100 0e04 	addhi.w	lr, r0, #4
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80010b8:	f1a2 0b20 	subhi.w	fp, r2, #32
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80010bc:	f8de 4000 	ldr.w	r4, [lr]
 80010c0:	fa0a f90b 	lsl.w	r9, sl, fp
 80010c4:	fa06 fb0b 	lsl.w	fp, r6, fp
 80010c8:	ea24 040b 	bic.w	r4, r4, fp
 80010cc:	ea44 0409 	orr.w	r4, r4, r9
 80010d0:	f8ce 4000 	str.w	r4, [lr]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80010d4:	684c      	ldr	r4, [r1, #4]
 80010d6:	f014 5f80 	tst.w	r4, #268435456	; 0x10000000
 80010da:	d079      	beq.n	80011d0 <HAL_GPIO_Init+0x1a8>
        __HAL_RCC_AFIO_CLK_ENABLE();
 80010dc:	f8d7 e018 	ldr.w	lr, [r7, #24]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 80010e0:	f003 0903 	and.w	r9, r3, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 80010e4:	f04e 0e01 	orr.w	lr, lr, #1
 80010e8:	f8c7 e018 	str.w	lr, [r7, #24]
 80010ec:	f8d7 e018 	ldr.w	lr, [r7, #24]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 80010f0:	ea4f 0989 	mov.w	r9, r9, lsl #2
        __HAL_RCC_AFIO_CLK_ENABLE();
 80010f4:	f00e 0e01 	and.w	lr, lr, #1
 80010f8:	f8cd e004 	str.w	lr, [sp, #4]
 80010fc:	f8dd e004 	ldr.w	lr, [sp, #4]
        temp = AFIO->EXTICR[position >> 2u];
 8001100:	f023 0e03 	bic.w	lr, r3, #3
 8001104:	f10e 4e80 	add.w	lr, lr, #1073741824	; 0x40000000
 8001108:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
 800110c:	f8de b008 	ldr.w	fp, [lr, #8]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001110:	fa06 f609 	lsl.w	r6, r6, r9
 8001114:	ea2b 0606 	bic.w	r6, fp, r6
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001118:	f8df b118 	ldr.w	fp, [pc, #280]	; 8001234 <HAL_GPIO_Init+0x20c>
 800111c:	4558      	cmp	r0, fp
 800111e:	d013      	beq.n	8001148 <HAL_GPIO_Init+0x120>
 8001120:	f50b 6b80 	add.w	fp, fp, #1024	; 0x400
 8001124:	4558      	cmp	r0, fp
 8001126:	d06b      	beq.n	8001200 <HAL_GPIO_Init+0x1d8>
 8001128:	f8df b10c 	ldr.w	fp, [pc, #268]	; 8001238 <HAL_GPIO_Init+0x210>
 800112c:	4558      	cmp	r0, fp
 800112e:	d060      	beq.n	80011f2 <HAL_GPIO_Init+0x1ca>
 8001130:	f8df b108 	ldr.w	fp, [pc, #264]	; 800123c <HAL_GPIO_Init+0x214>
 8001134:	4558      	cmp	r0, fp
 8001136:	bf0c      	ite	eq
 8001138:	f04f 0b03 	moveq.w	fp, #3
 800113c:	f04f 0b04 	movne.w	fp, #4
 8001140:	fa0b f909 	lsl.w	r9, fp, r9
 8001144:	ea46 0609 	orr.w	r6, r6, r9
        AFIO->EXTICR[position >> 2u] = temp;
 8001148:	f8ce 6008 	str.w	r6, [lr, #8]
          SET_BIT(EXTI->IMR, iocurrent);
 800114c:	682e      	ldr	r6, [r5, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800114e:	f414 3f80 	tst.w	r4, #65536	; 0x10000
          SET_BIT(EXTI->IMR, iocurrent);
 8001152:	bf14      	ite	ne
 8001154:	ea46 060c 	orrne.w	r6, r6, ip
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8001158:	ea26 060c 	biceq.w	r6, r6, ip
 800115c:	602e      	str	r6, [r5, #0]
          SET_BIT(EXTI->EMR, iocurrent);
 800115e:	686e      	ldr	r6, [r5, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001160:	f414 3f00 	tst.w	r4, #131072	; 0x20000
          SET_BIT(EXTI->EMR, iocurrent);
 8001164:	bf14      	ite	ne
 8001166:	ea46 060c 	orrne.w	r6, r6, ip
          CLEAR_BIT(EXTI->EMR, iocurrent);
 800116a:	ea26 060c 	biceq.w	r6, r6, ip
 800116e:	606e      	str	r6, [r5, #4]
          SET_BIT(EXTI->RTSR, iocurrent);
 8001170:	68ae      	ldr	r6, [r5, #8]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001172:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
          SET_BIT(EXTI->RTSR, iocurrent);
 8001176:	bf14      	ite	ne
 8001178:	ea46 060c 	orrne.w	r6, r6, ip
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 800117c:	ea26 060c 	biceq.w	r6, r6, ip
 8001180:	60ae      	str	r6, [r5, #8]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001182:	f414 1f00 	tst.w	r4, #2097152	; 0x200000
          SET_BIT(EXTI->FTSR, iocurrent);
 8001186:	68ec      	ldr	r4, [r5, #12]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001188:	d01f      	beq.n	80011ca <HAL_GPIO_Init+0x1a2>
          SET_BIT(EXTI->FTSR, iocurrent);
 800118a:	ea44 040c 	orr.w	r4, r4, ip
 800118e:	60ec      	str	r4, [r5, #12]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001190:	680e      	ldr	r6, [r1, #0]
	position++;
 8001192:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001194:	fa36 f403 	lsrs.w	r4, r6, r3
 8001198:	f102 0204 	add.w	r2, r2, #4
 800119c:	f47f af5a 	bne.w	8001054 <HAL_GPIO_Init+0x2c>
  }
}
 80011a0:	b003      	add	sp, #12
 80011a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      switch (GPIO_Init->Mode)
 80011a6:	4546      	cmp	r6, r8
 80011a8:	d00a      	beq.n	80011c0 <HAL_GPIO_Init+0x198>
 80011aa:	f67f af6c 	bls.w	8001086 <HAL_GPIO_Init+0x5e>
 80011ae:	f8df e090 	ldr.w	lr, [pc, #144]	; 8001240 <HAL_GPIO_Init+0x218>
 80011b2:	4576      	cmp	r6, lr
 80011b4:	d004      	beq.n	80011c0 <HAL_GPIO_Init+0x198>
 80011b6:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
 80011ba:	4576      	cmp	r6, lr
 80011bc:	f47f af72 	bne.w	80010a4 <HAL_GPIO_Init+0x7c>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 80011c0:	688e      	ldr	r6, [r1, #8]
 80011c2:	bb3e      	cbnz	r6, 8001214 <HAL_GPIO_Init+0x1ec>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 80011c4:	f04f 0a04 	mov.w	sl, #4
 80011c8:	e76c      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 80011ca:	ea24 040c 	bic.w	r4, r4, ip
 80011ce:	60ec      	str	r4, [r5, #12]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80011d0:	680e      	ldr	r6, [r1, #0]
 80011d2:	e738      	b.n	8001046 <HAL_GPIO_Init+0x1e>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 80011d4:	68cc      	ldr	r4, [r1, #12]
 80011d6:	f104 0a04 	add.w	sl, r4, #4
          break;
 80011da:	e763      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 80011dc:	68cc      	ldr	r4, [r1, #12]
 80011de:	f104 0a08 	add.w	sl, r4, #8
          break;
 80011e2:	e75f      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 80011e4:	f8d1 a00c 	ldr.w	sl, [r1, #12]
          break;
 80011e8:	e75c      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 80011ea:	68cc      	ldr	r4, [r1, #12]
 80011ec:	f104 0a0c 	add.w	sl, r4, #12
          break;
 80011f0:	e758      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 80011f2:	f04f 0b02 	mov.w	fp, #2
 80011f6:	fa0b f909 	lsl.w	r9, fp, r9
 80011fa:	ea46 0609 	orr.w	r6, r6, r9
 80011fe:	e7a3      	b.n	8001148 <HAL_GPIO_Init+0x120>
 8001200:	f04f 0b01 	mov.w	fp, #1
 8001204:	fa0b f909 	lsl.w	r9, fp, r9
 8001208:	ea46 0609 	orr.w	r6, r6, r9
 800120c:	e79c      	b.n	8001148 <HAL_GPIO_Init+0x120>
      switch (GPIO_Init->Mode)
 800120e:	f04f 0a00 	mov.w	sl, #0
 8001212:	e747      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001214:	2e01      	cmp	r6, #1
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001216:	f04f 0a08 	mov.w	sl, #8
            GPIOx->BSRR = ioposition;
 800121a:	bf0c      	ite	eq
 800121c:	6104      	streq	r4, [r0, #16]
            GPIOx->BRR = ioposition;
 800121e:	6144      	strne	r4, [r0, #20]
 8001220:	e740      	b.n	80010a4 <HAL_GPIO_Init+0x7c>
 8001222:	bf00      	nop
 8001224:	40021000 	.word	0x40021000
 8001228:	40010400 	.word	0x40010400
 800122c:	10220000 	.word	0x10220000
 8001230:	10120000 	.word	0x10120000
 8001234:	40010800 	.word	0x40010800
 8001238:	40011000 	.word	0x40011000
 800123c:	40011400 	.word	0x40011400
 8001240:	10310000 	.word	0x10310000

08001244 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8001244:	b902      	cbnz	r2, 8001248 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 8001246:	0409      	lsls	r1, r1, #16
 8001248:	6101      	str	r1, [r0, #16]
  }
}
 800124a:	4770      	bx	lr

0800124c <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800124c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800124e:	b087      	sub	sp, #28
  USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8001250:	2800      	cmp	r0, #0
 8001252:	d074      	beq.n	800133e <HAL_PCD_Init+0xf2>

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8001254:	f890 32a9 	ldrb.w	r3, [r0, #681]	; 0x2a9
 8001258:	4605      	mov	r5, r0
 800125a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800125e:	2b00      	cmp	r3, #0
 8001260:	d068      	beq.n	8001334 <HAL_PCD_Init+0xe8>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8001262:	2303      	movs	r3, #3

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8001264:	462e      	mov	r6, r5
  hpcd->State = HAL_PCD_STATE_BUSY;
 8001266:	f885 32a9 	strb.w	r3, [r5, #681]	; 0x2a9
  __HAL_PCD_DISABLE(hpcd);
 800126a:	6828      	ldr	r0, [r5, #0]
 800126c:	f001 ff34 	bl	80030d8 <USB_DisableGlobalInt>
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8001270:	f856 eb10 	ldr.w	lr, [r6], #16
 8001274:	466c      	mov	r4, sp
 8001276:	46b4      	mov	ip, r6
 8001278:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800127c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800127e:	f8dc 3000 	ldr.w	r3, [ip]
 8001282:	1d2f      	adds	r7, r5, #4
 8001284:	6023      	str	r3, [r4, #0]
 8001286:	4670      	mov	r0, lr
 8001288:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800128c:	f001 ff12 	bl	80030b4 <USB_CoreInit>
 8001290:	4604      	mov	r4, r0
 8001292:	b130      	cbz	r0, 80012a2 <HAL_PCD_Init+0x56>

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
    return HAL_ERROR;
 8001294:	2401      	movs	r4, #1
    hpcd->State = HAL_PCD_STATE_ERROR;
 8001296:	2302      	movs	r3, #2
  hpcd->USB_Address = 0U;
  hpcd->State = HAL_PCD_STATE_READY;
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 8001298:	4620      	mov	r0, r4
    hpcd->State = HAL_PCD_STATE_ERROR;
 800129a:	f885 32a9 	strb.w	r3, [r5, #681]	; 0x2a9
}
 800129e:	b007      	add	sp, #28
 80012a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80012a2:	4601      	mov	r1, r0
 80012a4:	6828      	ldr	r0, [r5, #0]
 80012a6:	f001 ff21 	bl	80030ec <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012aa:	6868      	ldr	r0, [r5, #4]
 80012ac:	b350      	cbz	r0, 8001304 <HAL_PCD_Init+0xb8>
 80012ae:	4622      	mov	r2, r4
    hpcd->IN_ep[i].is_in = 1U;
 80012b0:	f04f 0e01 	mov.w	lr, #1
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80012b4:	4621      	mov	r1, r4
    hpcd->IN_ep[i].is_in = 1U;
 80012b6:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 80012ba:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012be:	f102 0c01 	add.w	ip, r2, #1
    hpcd->IN_ep[i].num = i;
 80012c2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    hpcd->IN_ep[i].tx_fifo_num = i;
 80012c6:	86da      	strh	r2, [r3, #54]	; 0x36
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012c8:	fa5f f28c 	uxtb.w	r2, ip
 80012cc:	4282      	cmp	r2, r0
    hpcd->IN_ep[i].xfer_buff = 0U;
 80012ce:	e9c3 110e 	strd	r1, r1, [r3, #56]	; 0x38
    hpcd->IN_ep[i].is_in = 1U;
 80012d2:	f883 e029 	strb.w	lr, [r3, #41]	; 0x29
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80012d6:	f883 102b 	strb.w	r1, [r3, #43]	; 0x2b
    hpcd->IN_ep[i].xfer_len = 0U;
 80012da:	6419      	str	r1, [r3, #64]	; 0x40
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012dc:	d3eb      	bcc.n	80012b6 <HAL_PCD_Init+0x6a>
    hpcd->OUT_ep[i].is_in = 0U;
 80012de:	2200      	movs	r2, #0
 80012e0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80012e4:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012e8:	1c61      	adds	r1, r4, #1
    hpcd->OUT_ep[i].num = i;
 80012ea:	f883 4168 	strb.w	r4, [r3, #360]	; 0x168
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012ee:	b2cc      	uxtb	r4, r1
 80012f0:	4284      	cmp	r4, r0
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80012f2:	e9c3 225e 	strd	r2, r2, [r3, #376]	; 0x178
    hpcd->OUT_ep[i].is_in = 0U;
 80012f6:	f883 2169 	strb.w	r2, [r3, #361]	; 0x169
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80012fa:	f883 216b 	strb.w	r2, [r3, #363]	; 0x16b
    hpcd->OUT_ep[i].xfer_len = 0U;
 80012fe:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001302:	d3ed      	bcc.n	80012e0 <HAL_PCD_Init+0x94>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8001304:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8001306:	466c      	mov	r4, sp
 8001308:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800130a:	6833      	ldr	r3, [r6, #0]
 800130c:	6828      	ldr	r0, [r5, #0]
 800130e:	6023      	str	r3, [r4, #0]
 8001310:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8001314:	f001 feec 	bl	80030f0 <USB_DevInit>
 8001318:	4604      	mov	r4, r0
 800131a:	2800      	cmp	r0, #0
 800131c:	d1ba      	bne.n	8001294 <HAL_PCD_Init+0x48>
  hpcd->State = HAL_PCD_STATE_READY;
 800131e:	2301      	movs	r3, #1
  hpcd->USB_Address = 0U;
 8001320:	f885 0024 	strb.w	r0, [r5, #36]	; 0x24
  (void)USB_DevDisconnect(hpcd->Instance);
 8001324:	6828      	ldr	r0, [r5, #0]
  hpcd->State = HAL_PCD_STATE_READY;
 8001326:	f885 32a9 	strb.w	r3, [r5, #681]	; 0x2a9
  (void)USB_DevDisconnect(hpcd->Instance);
 800132a:	f002 fcd7 	bl	8003cdc <USB_DevDisconnect>
}
 800132e:	4620      	mov	r0, r4
 8001330:	b007      	add	sp, #28
 8001332:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 8001334:	f880 22a8 	strb.w	r2, [r0, #680]	; 0x2a8
    HAL_PCD_MspInit(hpcd);
 8001338:	f004 f8c2 	bl	80054c0 <HAL_PCD_MspInit>
 800133c:	e791      	b.n	8001262 <HAL_PCD_Init+0x16>
    return HAL_ERROR;
 800133e:	2401      	movs	r4, #1
}
 8001340:	4620      	mov	r0, r4
 8001342:	b007      	add	sp, #28
 8001344:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001346:	bf00      	nop

08001348 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 8001348:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hpcd);
 800134a:	f890 32a8 	ldrb.w	r3, [r0, #680]	; 0x2a8
 800134e:	2b01      	cmp	r3, #1
 8001350:	d012      	beq.n	8001378 <HAL_PCD_Start+0x30>
 8001352:	4604      	mov	r4, r0
 8001354:	2501      	movs	r5, #1
  __HAL_PCD_ENABLE(hpcd);
 8001356:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001358:	f884 52a8 	strb.w	r5, [r4, #680]	; 0x2a8
  __HAL_PCD_ENABLE(hpcd);
 800135c:	f001 feb2 	bl	80030c4 <USB_EnableGlobalInt>

#if defined (USB)
  HAL_PCDEx_SetConnectionState(hpcd, 1U);
 8001360:	4629      	mov	r1, r5
 8001362:	4620      	mov	r0, r4
 8001364:	f004 f9ec 	bl	8005740 <HAL_PCDEx_SetConnectionState>
#endif /* defined (USB) */

  (void)USB_DevConnect(hpcd->Instance);
 8001368:	6820      	ldr	r0, [r4, #0]
 800136a:	f002 fcb5 	bl	8003cd8 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800136e:	2300      	movs	r3, #0
 8001370:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8

  return HAL_OK;
 8001374:	4618      	mov	r0, r3
}
 8001376:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd);
 8001378:	2002      	movs	r0, #2
}
 800137a:	bd38      	pop	{r3, r4, r5, pc}

0800137c <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800137c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001380:	4604      	mov	r4, r0
  uint16_t store_ep[8];
  uint8_t i;

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_CTR))
 8001382:	6800      	ldr	r0, [r0, #0]
 8001384:	f002 fcac 	bl	8003ce0 <USB_ReadInterrupts>
 8001388:	0403      	lsls	r3, r0, #16
 800138a:	f100 8099 	bmi.w	80014c0 <HAL_PCD_IRQHandler+0x144>
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    (void)PCD_EP_ISR_Handler(hpcd);
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_RESET))
 800138e:	6820      	ldr	r0, [r4, #0]
 8001390:	f002 fca6 	bl	8003ce0 <USB_ReadInterrupts>
 8001394:	0545      	lsls	r5, r0, #21
 8001396:	f100 81d5 	bmi.w	8001744 <HAL_PCD_IRQHandler+0x3c8>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    (void)HAL_PCD_SetAddress(hpcd, 0U);
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_PMAOVR))
 800139a:	6820      	ldr	r0, [r4, #0]
 800139c:	f002 fca0 	bl	8003ce0 <USB_ReadInterrupts>
 80013a0:	f410 4f80 	tst.w	r0, #16384	; 0x4000
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 80013a4:	6820      	ldr	r0, [r4, #0]
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_PMAOVR))
 80013a6:	d007      	beq.n	80013b8 <HAL_PCD_IRQHandler+0x3c>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 80013a8:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80013ac:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80013b0:	041b      	lsls	r3, r3, #16
 80013b2:	0c1b      	lsrs	r3, r3, #16
 80013b4:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ERR))
 80013b8:	f002 fc92 	bl	8003ce0 <USB_ReadInterrupts>
 80013bc:	f410 5f00 	tst.w	r0, #8192	; 0x2000
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 80013c0:	6820      	ldr	r0, [r4, #0]
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ERR))
 80013c2:	d007      	beq.n	80013d4 <HAL_PCD_IRQHandler+0x58>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 80013c4:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80013c8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80013cc:	041b      	lsls	r3, r3, #16
 80013ce:	0c1b      	lsrs	r3, r3, #16
 80013d0:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_WKUP))
 80013d4:	f002 fc84 	bl	8003ce0 <USB_ReadInterrupts>
 80013d8:	04c0      	lsls	r0, r0, #19
 80013da:	f100 8230 	bmi.w	800183e <HAL_PCD_IRQHandler+0x4c2>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SUSP))
 80013de:	6820      	ldr	r0, [r4, #0]
 80013e0:	f002 fc7e 	bl	8003ce0 <USB_ReadInterrupts>
 80013e4:	0501      	lsls	r1, r0, #20
 80013e6:	d555      	bpl.n	8001494 <HAL_PCD_IRQHandler+0x118>
    /* WA: To Clear Wakeup flag if raised with suspend signal */

    /* Store Endpoint register */
    for (i = 0U; i < 8U; i++)
    {
      store_ep[i] = PCD_GET_ENDPOINT(hpcd->Instance, i);
 80013e8:	6823      	ldr	r3, [r4, #0]
 80013ea:	f8b3 8000 	ldrh.w	r8, [r3]
 80013ee:	f8b3 e004 	ldrh.w	lr, [r3, #4]
 80013f2:	f8b3 c008 	ldrh.w	ip, [r3, #8]
 80013f6:	899f      	ldrh	r7, [r3, #12]
 80013f8:	8a1e      	ldrh	r6, [r3, #16]
 80013fa:	8a9d      	ldrh	r5, [r3, #20]
 80013fc:	8b18      	ldrh	r0, [r3, #24]
 80013fe:	8b99      	ldrh	r1, [r3, #28]
    }

    /* FORCE RESET */
    hpcd->Instance->CNTR |= (uint16_t)(USB_CNTR_FRES);
 8001400:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
      store_ep[i] = PCD_GET_ENDPOINT(hpcd->Instance, i);
 8001404:	fa1f f888 	uxth.w	r8, r8
    hpcd->Instance->CNTR |= (uint16_t)(USB_CNTR_FRES);
 8001408:	b292      	uxth	r2, r2
 800140a:	f042 0201 	orr.w	r2, r2, #1
 800140e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

    /* CLEAR RESET */
    hpcd->Instance->CNTR &= (uint16_t)(~USB_CNTR_FRES);
 8001412:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
      store_ep[i] = PCD_GET_ENDPOINT(hpcd->Instance, i);
 8001416:	fa1f fe8e 	uxth.w	lr, lr
    hpcd->Instance->CNTR &= (uint16_t)(~USB_CNTR_FRES);
 800141a:	f022 0201 	bic.w	r2, r2, #1
 800141e:	0412      	lsls	r2, r2, #16
 8001420:	0c12      	lsrs	r2, r2, #16
      store_ep[i] = PCD_GET_ENDPOINT(hpcd->Instance, i);
 8001422:	fa1f fc8c 	uxth.w	ip, ip
 8001426:	b2bf      	uxth	r7, r7
 8001428:	b2b6      	uxth	r6, r6
 800142a:	b2ad      	uxth	r5, r5
 800142c:	b280      	uxth	r0, r0
 800142e:	b289      	uxth	r1, r1
    hpcd->Instance->CNTR &= (uint16_t)(~USB_CNTR_FRES);
 8001430:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

    /* wait for reset flag in ISTR */
    while ((hpcd->Instance->ISTR & USB_ISTR_RESET) == 0U)
 8001434:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8001438:	0552      	lsls	r2, r2, #21
 800143a:	d5fb      	bpl.n	8001434 <HAL_PCD_IRQHandler+0xb8>
    {
    }

    /* Clear Reset Flag */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800143c:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8001440:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001444:	0412      	lsls	r2, r2, #16
 8001446:	0c12      	lsrs	r2, r2, #16
 8001448:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    /* Restore Registre */
    for (i = 0U; i < 8U; i++)
    {
      PCD_SET_ENDPOINT(hpcd->Instance, i, store_ep[i]);
 800144c:	f8a3 8000 	strh.w	r8, [r3]
 8001450:	f8a3 e004 	strh.w	lr, [r3, #4]
 8001454:	f8a3 c008 	strh.w	ip, [r3, #8]
 8001458:	819f      	strh	r7, [r3, #12]
 800145a:	821e      	strh	r6, [r3, #16]
 800145c:	829d      	strh	r5, [r3, #20]
 800145e:	8318      	strh	r0, [r3, #24]
 8001460:	8399      	strh	r1, [r3, #28]
    }

    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 8001462:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LP_MODE;

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SuspendCallback(hpcd);
#else
    HAL_PCD_SuspendCallback(hpcd);
 8001466:	4620      	mov	r0, r4
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 8001468:	b292      	uxth	r2, r2
 800146a:	f042 0208 	orr.w	r2, r2, #8
 800146e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 8001472:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8001476:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800147a:	0412      	lsls	r2, r2, #16
 800147c:	0c12      	lsrs	r2, r2, #16
 800147e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LP_MODE;
 8001482:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8001486:	b292      	uxth	r2, r2
 8001488:	f042 0204 	orr.w	r2, r2, #4
 800148c:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    HAL_PCD_SuspendCallback(hpcd);
 8001490:	f004 f868 	bl	8005564 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SOF))
 8001494:	6820      	ldr	r0, [r4, #0]
 8001496:	f002 fc23 	bl	8003ce0 <USB_ReadInterrupts>
 800149a:	0582      	lsls	r2, r0, #22
 800149c:	f100 81c2 	bmi.w	8001824 <HAL_PCD_IRQHandler+0x4a8>
#else
    HAL_PCD_SOFCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ESOF))
 80014a0:	6820      	ldr	r0, [r4, #0]
 80014a2:	f002 fc1d 	bl	8003ce0 <USB_ReadInterrupts>
 80014a6:	05c3      	lsls	r3, r0, #23
 80014a8:	d508      	bpl.n	80014bc <HAL_PCD_IRQHandler+0x140>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF);
 80014aa:	6822      	ldr	r2, [r4, #0]
 80014ac:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 80014b0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80014b4:	041b      	lsls	r3, r3, #16
 80014b6:	0c1b      	lsrs	r3, r3, #16
 80014b8:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  }
}
 80014bc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  PCD_EPTypeDef *ep;
  uint16_t count, wIstr, wEPVal, TxByteNbre;
  uint8_t epindex;

  /* stay in loop while pending interrupts */
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 80014c0:	6822      	ldr	r2, [r4, #0]
 80014c2:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 80014c6:	4610      	mov	r0, r2
 80014c8:	041f      	lsls	r7, r3, #16
 80014ca:	f57f af61 	bpl.w	8001390 <HAL_PCD_IRQHandler+0x14>
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
      {
        ep = &hpcd->IN_ep[epindex];

        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 80014ce:	f8df 934c 	ldr.w	r9, [pc, #844]	; 800181c <HAL_PCD_IRQHandler+0x4a0>
      }
    }
  }

  /*enable endpoint IN*/
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 80014d2:	f8df a34c 	ldr.w	sl, [pc, #844]	; 8001820 <HAL_PCD_IRQHandler+0x4a4>
 80014d6:	e011      	b.n	80014fc <HAL_PCD_IRQHandler+0x180>
      if ((wIstr & USB_ISTR_DIR) == 0U)
 80014d8:	f011 0110 	ands.w	r1, r1, #16
 80014dc:	f000 8150 	beq.w	8001780 <HAL_PCD_IRQHandler+0x404>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 80014e0:	8801      	ldrh	r1, [r0, #0]
        if ((wEPVal & USB_EP_SETUP) != 0U)
 80014e2:	f411 6500 	ands.w	r5, r1, #2048	; 0x800
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 80014e6:	b28b      	uxth	r3, r1
        if ((wEPVal & USB_EP_SETUP) != 0U)
 80014e8:	f040 8175 	bne.w	80017d6 <HAL_PCD_IRQHandler+0x45a>
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 80014ec:	041e      	lsls	r6, r3, #16
 80014ee:	f100 81ff 	bmi.w	80018f0 <HAL_PCD_IRQHandler+0x574>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 80014f2:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80014f6:	041e      	lsls	r6, r3, #16
 80014f8:	f140 811e 	bpl.w	8001738 <HAL_PCD_IRQHandler+0x3bc>
    wIstr = hpcd->Instance->ISTR;
 80014fc:	f8b0 5044 	ldrh.w	r5, [r0, #68]	; 0x44
 8001500:	b2a9      	uxth	r1, r5
    if (epindex == 0U)
 8001502:	f015 050f 	ands.w	r5, r5, #15
 8001506:	d0e7      	beq.n	80014d8 <HAL_PCD_IRQHandler+0x15c>
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 8001508:	f830 3025 	ldrh.w	r3, [r0, r5, lsl #2]
 800150c:	00ae      	lsls	r6, r5, #2
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800150e:	0419      	lsls	r1, r3, #16
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 8001510:	fa1f f883 	uxth.w	r8, r3
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8001514:	f100 809f 	bmi.w	8001656 <HAL_PCD_IRQHandler+0x2da>
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 8001518:	f018 0f80 	tst.w	r8, #128	; 0x80
 800151c:	d0e9      	beq.n	80014f2 <HAL_PCD_IRQHandler+0x176>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 800151e:	f830 3025 	ldrh.w	r3, [r0, r5, lsl #2]
 8001522:	1977      	adds	r7, r6, r5
 8001524:	b29b      	uxth	r3, r3
 8001526:	ea03 0309 	and.w	r3, r3, r9
 800152a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800152e:	f820 3025 	strh.w	r3, [r0, r5, lsl #2]
        if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_CTRL) ||
 8001532:	eb04 07c7 	add.w	r7, r4, r7, lsl #3
 8001536:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800153a:	2b03      	cmp	r3, #3
 800153c:	f000 80cf 	beq.w	80016de <HAL_PCD_IRQHandler+0x362>
 8001540:	2b00      	cmp	r3, #0
 8001542:	f000 80cc 	beq.w	80016de <HAL_PCD_IRQHandler+0x362>
 8001546:	2b02      	cmp	r3, #2
 8001548:	d103      	bne.n	8001552 <HAL_PCD_IRQHandler+0x1d6>
           ((ep->type == EP_TYPE_BULK) && ((wEPVal & USB_EP_KIND) == 0U)))
 800154a:	f418 7f80 	tst.w	r8, #256	; 0x100
 800154e:	f000 80c6 	beq.w	80016de <HAL_PCD_IRQHandler+0x362>
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001552:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001556:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
 800155a:	b29b      	uxth	r3, r3
 800155c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
  if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 8001560:	f018 0c40 	ands.w	ip, r8, #64	; 0x40
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001564:	eb00 0343 	add.w	r3, r0, r3, lsl #1
  if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 8001568:	f000 8239 	beq.w	80019de <HAL_PCD_IRQHandler+0x662>
    if (ep->xfer_len > TxByteNbre)
 800156c:	eb06 0c05 	add.w	ip, r6, r5
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001570:	f8b3 3404 	ldrh.w	r3, [r3, #1028]	; 0x404
    if (ep->xfer_len > TxByteNbre)
 8001574:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
 8001578:	f8dc e040 	ldr.w	lr, [ip, #64]	; 0x40
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800157c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    if (ep->xfer_len > TxByteNbre)
 8001580:	459e      	cmp	lr, r3
 8001582:	f240 8334 	bls.w	8001bee <HAL_PCD_IRQHandler+0x872>
      ep->xfer_len -= TxByteNbre;
 8001586:	ebae 0e03 	sub.w	lr, lr, r3
 800158a:	f8cc e040 	str.w	lr, [ip, #64]	; 0x40
    if (ep->xfer_len == 0U)
 800158e:	f1be 0f00 	cmp.w	lr, #0
 8001592:	f000 832f 	beq.w	8001bf4 <HAL_PCD_IRQHandler+0x878>
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 8001596:	f418 4f80 	tst.w	r8, #16384	; 0x4000
 800159a:	d00f      	beq.n	80015bc <HAL_PCD_IRQHandler+0x240>
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800159c:	f830 c021 	ldrh.w	ip, [r0, r1, lsl #2]
 80015a0:	f42c 4ce0 	bic.w	ip, ip, #28672	; 0x7000
 80015a4:	f02c 0c70 	bic.w	ip, ip, #112	; 0x70
 80015a8:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80015ac:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80015b0:	f44c 4c40 	orr.w	ip, ip, #49152	; 0xc000
 80015b4:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
 80015b8:	f820 c021 	strh.w	ip, [r0, r1, lsl #2]
      if (ep->xfer_fill_db == 1U)
 80015bc:	eb06 0e05 	add.w	lr, r6, r5
 80015c0:	eb04 0ece 	add.w	lr, r4, lr, lsl #3
 80015c4:	f89e c04c 	ldrb.w	ip, [lr, #76]	; 0x4c
 80015c8:	f1bc 0f01 	cmp.w	ip, #1
 80015cc:	f040 82ff 	bne.w	8001bce <HAL_PCD_IRQHandler+0x852>
        ep->xfer_buff += TxByteNbre;
 80015d0:	f8de 203c 	ldr.w	r2, [lr, #60]	; 0x3c
        if (ep->xfer_len_db >= ep->maxpacket)
 80015d4:	f8de 8048 	ldr.w	r8, [lr, #72]	; 0x48
        ep->xfer_buff += TxByteNbre;
 80015d8:	eb02 0c03 	add.w	ip, r2, r3
        ep->xfer_count += TxByteNbre;
 80015dc:	f8de 2044 	ldr.w	r2, [lr, #68]	; 0x44
        ep->xfer_buff += TxByteNbre;
 80015e0:	f8ce c03c 	str.w	ip, [lr, #60]	; 0x3c
        ep->xfer_count += TxByteNbre;
 80015e4:	441a      	add	r2, r3
 80015e6:	f8ce 2044 	str.w	r2, [lr, #68]	; 0x44
        if (ep->xfer_len_db >= ep->maxpacket)
 80015ea:	f8de 2038 	ldr.w	r2, [lr, #56]	; 0x38
 80015ee:	4590      	cmp	r8, r2
 80015f0:	f0c0 83ce 	bcc.w	8001d90 <HAL_PCD_IRQHandler+0xa14>
          ep->xfer_len_db -= len;
 80015f4:	eba8 0302 	sub.w	r3, r8, r2
 80015f8:	f8ce 3048 	str.w	r3, [lr, #72]	; 0x48
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 80015fc:	b293      	uxth	r3, r2
 80015fe:	f897 e029 	ldrb.w	lr, [r7, #41]	; 0x29
 8001602:	f1be 0f00 	cmp.w	lr, #0
 8001606:	f040 83b6 	bne.w	8001d76 <HAL_PCD_IRQHandler+0x9fa>
 800160a:	f8b0 e050 	ldrh.w	lr, [r0, #80]	; 0x50
 800160e:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8001612:	f201 4804 	addw	r8, r1, #1028	; 0x404
 8001616:	fa1f fe8e 	uxth.w	lr, lr
 800161a:	eb08 010e 	add.w	r1, r8, lr
 800161e:	2a00      	cmp	r2, #0
 8001620:	f040 83e8 	bne.w	8001df4 <HAL_PCD_IRQHandler+0xa78>
 8001624:	f838 200e 	ldrh.w	r2, [r8, lr]
 8001628:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
 800162c:	0412      	lsls	r2, r2, #16
 800162e:	0c12      	lsrs	r2, r2, #16
 8001630:	f828 200e 	strh.w	r2, [r8, lr]
 8001634:	f838 200e 	ldrh.w	r2, [r8, lr]
 8001638:	b292      	uxth	r2, r2
 800163a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800163e:	f828 200e 	strh.w	r2, [r8, lr]
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 8001642:	1972      	adds	r2, r6, r5
 8001644:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8001648:	8e12      	ldrh	r2, [r2, #48]	; 0x30
 800164a:	4661      	mov	r1, ip
 800164c:	f002 fb4e 	bl	8003cec <USB_WritePMA>
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8001650:	6820      	ldr	r0, [r4, #0]
 8001652:	4602      	mov	r2, r0
 8001654:	e2bb      	b.n	8001bce <HAL_PCD_IRQHandler+0x852>
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 8001656:	f640 738f 	movw	r3, #3983	; 0xf8f
 800165a:	f830 2025 	ldrh.w	r2, [r0, r5, lsl #2]
        if (ep->doublebuffer == 0U)
 800165e:	1971      	adds	r1, r6, r5
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 8001660:	4013      	ands	r3, r2
 8001662:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001666:	f820 3025 	strh.w	r3, [r0, r5, lsl #2]
        if (ep->doublebuffer == 0U)
 800166a:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 800166e:	f891 3174 	ldrb.w	r3, [r1, #372]	; 0x174
 8001672:	2b00      	cmp	r3, #0
 8001674:	f040 8101 	bne.w	800187a <HAL_PCD_IRQHandler+0x4fe>
          count = (uint16_t)PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8001678:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800167c:	f891 2168 	ldrb.w	r2, [r1, #360]	; 0x168
 8001680:	b29b      	uxth	r3, r3
 8001682:	3306      	adds	r3, #6
 8001684:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001688:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800168c:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 8001690:	f3c3 0309 	ubfx	r3, r3, #0, #10
        ep->xfer_count += count;
 8001694:	461f      	mov	r7, r3
          if (count != 0U)
 8001696:	2b00      	cmp	r3, #0
 8001698:	f040 8191 	bne.w	80019be <HAL_PCD_IRQHandler+0x642>
        ep->xfer_count += count;
 800169c:	1971      	adds	r1, r6, r5
 800169e:	eb04 03c1 	add.w	r3, r4, r1, lsl #3
 80016a2:	f8d3 2184 	ldr.w	r2, [r3, #388]	; 0x184
 80016a6:	00c9      	lsls	r1, r1, #3
 80016a8:	443a      	add	r2, r7
 80016aa:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
        ep->xfer_buff += count;
 80016ae:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
 80016b2:	443a      	add	r2, r7
 80016b4:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 80016b8:	f8d3 2180 	ldr.w	r2, [r3, #384]	; 0x180
 80016bc:	b122      	cbz	r2, 80016c8 <HAL_PCD_IRQHandler+0x34c>
 80016be:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 80016c2:	42bb      	cmp	r3, r7
 80016c4:	f240 8182 	bls.w	80019cc <HAL_PCD_IRQHandler+0x650>
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 80016c8:	1973      	adds	r3, r6, r5
 80016ca:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80016ce:	4620      	mov	r0, r4
 80016d0:	f893 1168 	ldrb.w	r1, [r3, #360]	; 0x168
 80016d4:	f003 ff1c 	bl	8005510 <HAL_PCD_DataOutStageCallback>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 80016d8:	6820      	ldr	r0, [r4, #0]
 80016da:	4602      	mov	r2, r0
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 80016dc:	e71c      	b.n	8001518 <HAL_PCD_IRQHandler+0x19c>
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016de:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80016e2:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
 80016e6:	b29b      	uxth	r3, r3
 80016e8:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
          if (ep->xfer_len > TxByteNbre)
 80016ec:	442e      	add	r6, r5
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016ee:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80016f2:	f8b3 3404 	ldrh.w	r3, [r3, #1028]	; 0x404
          if (ep->xfer_len > TxByteNbre)
 80016f6:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
 80016fa:	6c32      	ldr	r2, [r6, #64]	; 0x40
 80016fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001700:	429a      	cmp	r2, r3
 8001702:	f240 80ed 	bls.w	80018e0 <HAL_PCD_IRQHandler+0x564>
            ep->xfer_len -= TxByteNbre;
 8001706:	1ad2      	subs	r2, r2, r3
 8001708:	6432      	str	r2, [r6, #64]	; 0x40
          if (ep->xfer_len == 0U)
 800170a:	2a00      	cmp	r2, #0
 800170c:	f000 80ea 	beq.w	80018e4 <HAL_PCD_IRQHandler+0x568>
            ep->xfer_buff += TxByteNbre;
 8001710:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
        ep = &hpcd->IN_ep[epindex];
 8001712:	3501      	adds	r5, #1
            ep->xfer_buff += TxByteNbre;
 8001714:	441a      	add	r2, r3
 8001716:	63f2      	str	r2, [r6, #60]	; 0x3c
            ep->xfer_count += TxByteNbre;
 8001718:	6c72      	ldr	r2, [r6, #68]	; 0x44
        ep = &hpcd->IN_ep[epindex];
 800171a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
            ep->xfer_count += TxByteNbre;
 800171e:	4413      	add	r3, r2
 8001720:	6473      	str	r3, [r6, #68]	; 0x44
            (void)USB_EPStartXfer(hpcd->Instance, ep);
 8001722:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
 8001726:	f001 ff4f 	bl	80035c8 <USB_EPStartXfer>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800172a:	6820      	ldr	r0, [r4, #0]
 800172c:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8001730:	4602      	mov	r2, r0
 8001732:	041e      	lsls	r6, r3, #16
 8001734:	f53f aee2 	bmi.w	80014fc <HAL_PCD_IRQHandler+0x180>
 8001738:	4610      	mov	r0, r2
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_RESET))
 800173a:	f002 fad1 	bl	8003ce0 <USB_ReadInterrupts>
 800173e:	0545      	lsls	r5, r0, #21
 8001740:	f57f ae2b 	bpl.w	800139a <HAL_PCD_IRQHandler+0x1e>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 8001744:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_ResetCallback(hpcd);
 8001746:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 8001748:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 800174c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001750:	041b      	lsls	r3, r3, #16
 8001752:	0c1b      	lsrs	r3, r3, #16
 8001754:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 8001758:	f003 fef2 	bl	8005540 <HAL_PCD_ResetCallback>
  __HAL_LOCK(hpcd);
 800175c:	f894 32a8 	ldrb.w	r3, [r4, #680]	; 0x2a8
 8001760:	2b01      	cmp	r3, #1
 8001762:	f43f ae1a 	beq.w	800139a <HAL_PCD_IRQHandler+0x1e>
  hpcd->USB_Address = address;
 8001766:	2500      	movs	r5, #0
  __HAL_LOCK(hpcd);
 8001768:	2301      	movs	r3, #1
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800176a:	4629      	mov	r1, r5
 800176c:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800176e:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  hpcd->USB_Address = address;
 8001772:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8001776:	f002 faa9 	bl	8003ccc <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800177a:	f884 52a8 	strb.w	r5, [r4, #680]	; 0x2a8
  return HAL_OK;
 800177e:	e60c      	b.n	800139a <HAL_PCD_IRQHandler+0x1e>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001780:	8803      	ldrh	r3, [r0, #0]
 8001782:	b29b      	uxth	r3, r3
 8001784:	ea03 0309 	and.w	r3, r3, r9
 8001788:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800178c:	8003      	strh	r3, [r0, #0]
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800178e:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001792:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 8001796:	b29b      	uxth	r3, r3
 8001798:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800179c:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 80017a0:	f8b0 3404 	ldrh.w	r3, [r0, #1028]	; 0x404
        ep->xfer_buff += ep->xfer_count;
 80017a4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80017a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80017aa:	6463      	str	r3, [r4, #68]	; 0x44
        ep->xfer_buff += ep->xfer_count;
 80017ac:	4413      	add	r3, r2
 80017ae:	63e3      	str	r3, [r4, #60]	; 0x3c
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 80017b0:	4620      	mov	r0, r4
 80017b2:	f003 feb7 	bl	8005524 <HAL_PCD_DataInStageCallback>
        if ((hpcd->USB_Address > 0U) && (ep->xfer_len == 0U))
 80017b6:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80017ba:	b363      	cbz	r3, 8001816 <HAL_PCD_IRQHandler+0x49a>
 80017bc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80017be:	bb53      	cbnz	r3, 8001816 <HAL_PCD_IRQHandler+0x49a>
          hpcd->Instance->DADDR = ((uint16_t)hpcd->USB_Address | USB_DADDR_EF);
 80017c0:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
 80017c4:	6820      	ldr	r0, [r4, #0]
 80017c6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80017ca:	f8a0 204c 	strh.w	r2, [r0, #76]	; 0x4c
 80017ce:	4602      	mov	r2, r0
          hpcd->USB_Address = 0U;
 80017d0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80017d4:	e68d      	b.n	80014f2 <HAL_PCD_IRQHandler+0x176>
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 80017d6:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80017da:	f894 2168 	ldrb.w	r2, [r4, #360]	; 0x168
 80017de:	b29b      	uxth	r3, r3
 80017e0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80017e4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80017e8:	f8b3 340c 	ldrh.w	r3, [r3, #1036]	; 0x40c
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 80017ec:	f8b4 216e 	ldrh.w	r2, [r4, #366]	; 0x16e
 80017f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 80017f4:	f8c4 3184 	str.w	r3, [r4, #388]	; 0x184
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 80017f8:	f504 712c 	add.w	r1, r4, #688	; 0x2b0
 80017fc:	f002 fa86 	bl	8003d0c <USB_ReadPMA>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001800:	f640 738f 	movw	r3, #3983	; 0xf8f
 8001804:	6822      	ldr	r2, [r4, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 8001806:	4620      	mov	r0, r4
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001808:	8811      	ldrh	r1, [r2, #0]
 800180a:	400b      	ands	r3, r1
 800180c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001810:	8013      	strh	r3, [r2, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 8001812:	f003 fe75 	bl	8005500 <HAL_PCD_SetupStageCallback>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 8001816:	6820      	ldr	r0, [r4, #0]
 8001818:	4602      	mov	r2, r0
 800181a:	e66a      	b.n	80014f2 <HAL_PCD_IRQHandler+0x176>
 800181c:	ffff8f0f 	.word	0xffff8f0f
 8001820:	ffff8fbf 	.word	0xffff8fbf
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 8001824:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_SOFCallback(hpcd);
 8001826:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 8001828:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 800182c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001830:	041b      	lsls	r3, r3, #16
 8001832:	0c1b      	lsrs	r3, r3, #16
 8001834:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 8001838:	f003 fe7e 	bl	8005538 <HAL_PCD_SOFCallback>
 800183c:	e630      	b.n	80014a0 <HAL_PCD_IRQHandler+0x124>
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LP_MODE);
 800183e:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_ResumeCallback(hpcd);
 8001840:	4620      	mov	r0, r4
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LP_MODE);
 8001842:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 8001846:	f023 0304 	bic.w	r3, r3, #4
 800184a:	041b      	lsls	r3, r3, #16
 800184c:	0c1b      	lsrs	r3, r3, #16
 800184e:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 8001852:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 8001856:	f023 0308 	bic.w	r3, r3, #8
 800185a:	041b      	lsls	r3, r3, #16
 800185c:	0c1b      	lsrs	r3, r3, #16
 800185e:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    HAL_PCD_ResumeCallback(hpcd);
 8001862:	f003 fe8f 	bl	8005584 <HAL_PCD_ResumeCallback>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 8001866:	6820      	ldr	r0, [r4, #0]
 8001868:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 800186c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8001870:	041b      	lsls	r3, r3, #16
 8001872:	0c1b      	lsrs	r3, r3, #16
 8001874:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 8001878:	e5b2      	b.n	80013e0 <HAL_PCD_IRQHandler+0x64>
          if (ep->type == EP_TYPE_BULK)
 800187a:	f891 316b 	ldrb.w	r3, [r1, #363]	; 0x16b
 800187e:	2b02      	cmp	r3, #2
 8001880:	f000 8125 	beq.w	8001ace <HAL_PCD_IRQHandler+0x752>
            PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 8001884:	f891 2168 	ldrb.w	r2, [r1, #360]	; 0x168
 8001888:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800188c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8001890:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001894:	041b      	lsls	r3, r3, #16
 8001896:	0c1b      	lsrs	r3, r3, #16
 8001898:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800189c:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80018a0:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 80018a4:	f891 2168 	ldrb.w	r2, [r1, #360]	; 0x168
 80018a8:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80018ac:	f413 4f80 	tst.w	r3, #16384	; 0x4000
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80018b0:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80018b4:	b29b      	uxth	r3, r3
            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 80018b6:	d06e      	beq.n	8001996 <HAL_PCD_IRQHandler+0x61a>
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80018b8:	3302      	adds	r3, #2
 80018ba:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80018be:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80018c2:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 80018c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
        ep->xfer_count += count;
 80018ca:	461f      	mov	r7, r3
              if (count != 0U)
 80018cc:	2b00      	cmp	r3, #0
 80018ce:	f43f aee5 	beq.w	800169c <HAL_PCD_IRQHandler+0x320>
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 80018d2:	f8b1 2170 	ldrh.w	r2, [r1, #368]	; 0x170
 80018d6:	f8d1 117c 	ldr.w	r1, [r1, #380]	; 0x17c
 80018da:	f002 fa17 	bl	8003d0c <USB_ReadPMA>
 80018de:	e6dd      	b.n	800169c <HAL_PCD_IRQHandler+0x320>
 80018e0:	2300      	movs	r3, #0
 80018e2:	6433      	str	r3, [r6, #64]	; 0x40
            HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80018e4:	4620      	mov	r0, r4
 80018e6:	f003 fe1d 	bl	8005524 <HAL_PCD_DataInStageCallback>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 80018ea:	6820      	ldr	r0, [r4, #0]
 80018ec:	4602      	mov	r2, r0
 80018ee:	e600      	b.n	80014f2 <HAL_PCD_IRQHandler+0x176>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 80018f0:	f640 738f 	movw	r3, #3983	; 0xf8f
 80018f4:	8802      	ldrh	r2, [r0, #0]
 80018f6:	4013      	ands	r3, r2
 80018f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80018fc:	8003      	strh	r3, [r0, #0]
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 80018fe:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001902:	f894 2168 	ldrb.w	r2, [r4, #360]	; 0x168
 8001906:	b29b      	uxth	r3, r3
 8001908:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800190c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8001910:	f8b3 340c 	ldrh.w	r3, [r3, #1036]	; 0x40c
 8001914:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001918:	f8c4 3184 	str.w	r3, [r4, #388]	; 0x184
          if ((ep->xfer_count != 0U) && (ep->xfer_buff != 0U))
 800191c:	b193      	cbz	r3, 8001944 <HAL_PCD_IRQHandler+0x5c8>
 800191e:	f8d4 117c 	ldr.w	r1, [r4, #380]	; 0x17c
 8001922:	b179      	cbz	r1, 8001944 <HAL_PCD_IRQHandler+0x5c8>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 8001924:	f8b4 216e 	ldrh.w	r2, [r4, #366]	; 0x16e
 8001928:	f002 f9f0 	bl	8003d0c <USB_ReadPMA>
            ep->xfer_buff += ep->xfer_count;
 800192c:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 8001930:	f8d4 2184 	ldr.w	r2, [r4, #388]	; 0x184
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 8001934:	4620      	mov	r0, r4
            ep->xfer_buff += ep->xfer_count;
 8001936:	4413      	add	r3, r2
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 8001938:	4629      	mov	r1, r5
            ep->xfer_buff += ep->xfer_count;
 800193a:	f8c4 317c 	str.w	r3, [r4, #380]	; 0x17c
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800193e:	f003 fde7 	bl	8005510 <HAL_PCD_DataOutStageCallback>
 8001942:	6820      	ldr	r0, [r4, #0]
          if ((PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0) & USB_EP_SETUP) == 0U)
 8001944:	8803      	ldrh	r3, [r0, #0]
 8001946:	4602      	mov	r2, r0
 8001948:	051d      	lsls	r5, r3, #20
 800194a:	f53f add2 	bmi.w	80014f2 <HAL_PCD_IRQHandler+0x176>
            PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800194e:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001952:	f8d4 1178 	ldr.w	r1, [r4, #376]	; 0x178
 8001956:	b29b      	uxth	r3, r3
 8001958:	f200 450c 	addw	r5, r0, #1036	; 0x40c
 800195c:	2900      	cmp	r1, #0
 800195e:	f040 80ab 	bne.w	8001ab8 <HAL_PCD_IRQHandler+0x73c>
 8001962:	5ae9      	ldrh	r1, [r5, r3]
 8001964:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
 8001968:	0409      	lsls	r1, r1, #16
 800196a:	0c09      	lsrs	r1, r1, #16
 800196c:	52e9      	strh	r1, [r5, r3]
 800196e:	5ae9      	ldrh	r1, [r5, r3]
 8001970:	b289      	uxth	r1, r1
 8001972:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8001976:	52e9      	strh	r1, [r5, r3]
            PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 8001978:	8803      	ldrh	r3, [r0, #0]
 800197a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800197e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001982:	041b      	lsls	r3, r3, #16
 8001984:	0c1b      	lsrs	r3, r3, #16
 8001986:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800198a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800198e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001992:	8003      	strh	r3, [r0, #0]
 8001994:	e5ad      	b.n	80014f2 <HAL_PCD_IRQHandler+0x176>
              count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8001996:	3306      	adds	r3, #6
 8001998:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800199c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80019a0:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 80019a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
        ep->xfer_count += count;
 80019a8:	461f      	mov	r7, r3
              if (count != 0U)
 80019aa:	2b00      	cmp	r3, #0
 80019ac:	f43f ae76 	beq.w	800169c <HAL_PCD_IRQHandler+0x320>
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 80019b0:	f8b1 2172 	ldrh.w	r2, [r1, #370]	; 0x172
 80019b4:	f8d1 117c 	ldr.w	r1, [r1, #380]	; 0x17c
 80019b8:	f002 f9a8 	bl	8003d0c <USB_ReadPMA>
 80019bc:	e66e      	b.n	800169c <HAL_PCD_IRQHandler+0x320>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 80019be:	f8b1 216e 	ldrh.w	r2, [r1, #366]	; 0x16e
 80019c2:	f8d1 117c 	ldr.w	r1, [r1, #380]	; 0x17c
 80019c6:	f002 f9a1 	bl	8003d0c <USB_ReadPMA>
 80019ca:	e667      	b.n	800169c <HAL_PCD_IRQHandler+0x320>
        ep = &hpcd->OUT_ep[epindex];
 80019cc:	f501 71b4 	add.w	r1, r1, #360	; 0x168
          (void) USB_EPStartXfer(hpcd->Instance, ep);
 80019d0:	6820      	ldr	r0, [r4, #0]
 80019d2:	4421      	add	r1, r4
 80019d4:	f001 fdf8 	bl	80035c8 <USB_EPStartXfer>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 80019d8:	6820      	ldr	r0, [r4, #0]
 80019da:	4602      	mov	r2, r0
 80019dc:	e59c      	b.n	8001518 <HAL_PCD_IRQHandler+0x19c>
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80019de:	f8b3 e40c 	ldrh.w	lr, [r3, #1036]	; 0x40c
    if (ep->xfer_len >= TxByteNbre)
 80019e2:	1973      	adds	r3, r6, r5
 80019e4:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80019e8:	f8d3 b040 	ldr.w	fp, [r3, #64]	; 0x40
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80019ec:	f3ce 0e09 	ubfx	lr, lr, #0, #10
    if (ep->xfer_len >= TxByteNbre)
 80019f0:	45f3      	cmp	fp, lr
 80019f2:	f0c0 80aa 	bcc.w	8001b4a <HAL_PCD_IRQHandler+0x7ce>
      ep->xfer_len -= TxByteNbre;
 80019f6:	ebab 0c0e 	sub.w	ip, fp, lr
 80019fa:	f8c3 c040 	str.w	ip, [r3, #64]	; 0x40
    if (ep->xfer_len == 0U)
 80019fe:	f1bc 0f00 	cmp.w	ip, #0
 8001a02:	f000 80a4 	beq.w	8001b4e <HAL_PCD_IRQHandler+0x7d2>
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 8001a06:	f418 4f80 	tst.w	r8, #16384	; 0x4000
 8001a0a:	d10d      	bne.n	8001a28 <HAL_PCD_IRQHandler+0x6ac>
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 8001a0c:	f830 3021 	ldrh.w	r3, [r0, r1, lsl #2]
 8001a10:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8001a14:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001a18:	041b      	lsls	r3, r3, #16
 8001a1a:	0c1b      	lsrs	r3, r3, #16
 8001a1c:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8001a20:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001a24:	f820 3021 	strh.w	r3, [r0, r1, lsl #2]
      if (ep->xfer_fill_db == 1U)
 8001a28:	1973      	adds	r3, r6, r5
 8001a2a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8001a2e:	f893 c04c 	ldrb.w	ip, [r3, #76]	; 0x4c
 8001a32:	f1bc 0f01 	cmp.w	ip, #1
 8001a36:	f040 80ca 	bne.w	8001bce <HAL_PCD_IRQHandler+0x852>
        ep->xfer_buff += TxByteNbre;
 8001a3a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
        if (ep->xfer_len_db >= ep->maxpacket)
 8001a3c:	f8d3 8048 	ldr.w	r8, [r3, #72]	; 0x48
        ep->xfer_buff += TxByteNbre;
 8001a40:	eb02 0c0e 	add.w	ip, r2, lr
        ep->xfer_count += TxByteNbre;
 8001a44:	6c5a      	ldr	r2, [r3, #68]	; 0x44
        ep->xfer_buff += TxByteNbre;
 8001a46:	f8c3 c03c 	str.w	ip, [r3, #60]	; 0x3c
        ep->xfer_count += TxByteNbre;
 8001a4a:	4472      	add	r2, lr
 8001a4c:	645a      	str	r2, [r3, #68]	; 0x44
        if (ep->xfer_len_db >= ep->maxpacket)
 8001a4e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001a50:	4590      	cmp	r8, r2
 8001a52:	f0c0 81b3 	bcc.w	8001dbc <HAL_PCD_IRQHandler+0xa40>
          ep->xfer_len_db -= len;
 8001a56:	eba8 0802 	sub.w	r8, r8, r2
 8001a5a:	f8c3 8048 	str.w	r8, [r3, #72]	; 0x48
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001a5e:	fa1f fe82 	uxth.w	lr, r2
 8001a62:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8001a66:	2b00      	cmp	r3, #0
 8001a68:	f040 819b 	bne.w	8001da2 <HAL_PCD_IRQHandler+0xa26>
 8001a6c:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8001a70:	f201 480c 	addw	r8, r1, #1036	; 0x40c
 8001a74:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 8001a78:	b289      	uxth	r1, r1
 8001a7a:	eb08 0301 	add.w	r3, r8, r1
 8001a7e:	2a00      	cmp	r2, #0
 8001a80:	f040 81d8 	bne.w	8001e34 <HAL_PCD_IRQHandler+0xab8>
 8001a84:	f838 3001 	ldrh.w	r3, [r8, r1]
 8001a88:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8001a8c:	041b      	lsls	r3, r3, #16
 8001a8e:	0c1b      	lsrs	r3, r3, #16
 8001a90:	f828 3001 	strh.w	r3, [r8, r1]
 8001a94:	f838 3001 	ldrh.w	r3, [r8, r1]
 8001a98:	b29b      	uxth	r3, r3
 8001a9a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001a9e:	f828 3001 	strh.w	r3, [r8, r1]
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 8001aa2:	1972      	adds	r2, r6, r5
 8001aa4:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8001aa8:	4673      	mov	r3, lr
 8001aaa:	4661      	mov	r1, ip
 8001aac:	8e52      	ldrh	r2, [r2, #50]	; 0x32
 8001aae:	f002 f91d 	bl	8003cec <USB_WritePMA>
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8001ab2:	6820      	ldr	r0, [r4, #0]
 8001ab4:	4602      	mov	r2, r0
 8001ab6:	e08a      	b.n	8001bce <HAL_PCD_IRQHandler+0x852>
            PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8001ab8:	293e      	cmp	r1, #62	; 0x3e
 8001aba:	f200 80cb 	bhi.w	8001c54 <HAL_PCD_IRQHandler+0x8d8>
 8001abe:	084e      	lsrs	r6, r1, #1
 8001ac0:	07c9      	lsls	r1, r1, #31
 8001ac2:	bf48      	it	mi
 8001ac4:	3601      	addmi	r6, #1
 8001ac6:	02b1      	lsls	r1, r6, #10
 8001ac8:	b289      	uxth	r1, r1
 8001aca:	52e9      	strh	r1, [r5, r3]
 8001acc:	e754      	b.n	8001978 <HAL_PCD_IRQHandler+0x5fc>
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001ace:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 8001ad2:	f418 4c80 	ands.w	ip, r8, #16384	; 0x4000
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001ad6:	b29b      	uxth	r3, r3
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 8001ad8:	f000 80c7 	beq.w	8001c6a <HAL_PCD_IRQHandler+0x8ee>
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001adc:	f891 2168 	ldrb.w	r2, [r1, #360]	; 0x168
 8001ae0:	3302      	adds	r3, #2
 8001ae2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001ae6:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8001aea:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
    if (ep->xfer_len >= count)
 8001aee:	f8d1 c180 	ldr.w	ip, [r1, #384]	; 0x180
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001af2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    if (ep->xfer_len >= count)
 8001af6:	459c      	cmp	ip, r3
 8001af8:	461f      	mov	r7, r3
 8001afa:	f0c0 8112 	bcc.w	8001d22 <HAL_PCD_IRQHandler+0x9a6>
      ep->xfer_len -= count;
 8001afe:	ebac 0c03 	sub.w	ip, ip, r3
 8001b02:	f8c1 c180 	str.w	ip, [r1, #384]	; 0x180
    if (ep->xfer_len == 0U)
 8001b06:	f1bc 0f00 	cmp.w	ip, #0
 8001b0a:	f000 810e 	beq.w	8001d2a <HAL_PCD_IRQHandler+0x9ae>
    if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 8001b0e:	f018 0f40 	tst.w	r8, #64	; 0x40
 8001b12:	d00d      	beq.n	8001b30 <HAL_PCD_IRQHandler+0x7b4>
      PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 8001b14:	f830 1022 	ldrh.w	r1, [r0, r2, lsl #2]
 8001b18:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 8001b1c:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 8001b20:	0409      	lsls	r1, r1, #16
 8001b22:	0c09      	lsrs	r1, r1, #16
 8001b24:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8001b28:	f041 01c0 	orr.w	r1, r1, #192	; 0xc0
 8001b2c:	f820 1022 	strh.w	r1, [r0, r2, lsl #2]
    if (count != 0U)
 8001b30:	2b00      	cmp	r3, #0
 8001b32:	f000 80c3 	beq.w	8001cbc <HAL_PCD_IRQHandler+0x940>
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 8001b36:	1971      	adds	r1, r6, r5
 8001b38:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8001b3c:	f8b1 2170 	ldrh.w	r2, [r1, #368]	; 0x170
 8001b40:	f8d1 117c 	ldr.w	r1, [r1, #380]	; 0x17c
 8001b44:	f002 f8e2 	bl	8003d0c <USB_ReadPMA>
 8001b48:	e5a8      	b.n	800169c <HAL_PCD_IRQHandler+0x320>
 8001b4a:	f8c3 c040 	str.w	ip, [r3, #64]	; 0x40
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001b4e:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8001b52:	2b00      	cmp	r3, #0
 8001b54:	f040 80be 	bne.w	8001cd4 <HAL_PCD_IRQHandler+0x958>
 8001b58:	f8b0 5050 	ldrh.w	r5, [r0, #80]	; 0x50
 8001b5c:	010b      	lsls	r3, r1, #4
 8001b5e:	f203 4604 	addw	r6, r3, #1028	; 0x404
 8001b62:	4406      	add	r6, r0
 8001b64:	b2ad      	uxth	r5, r5
 8001b66:	5b72      	ldrh	r2, [r6, r5]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001b68:	f203 430c 	addw	r3, r3, #1036	; 0x40c
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001b6c:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
 8001b70:	0412      	lsls	r2, r2, #16
 8001b72:	0c12      	lsrs	r2, r2, #16
 8001b74:	5372      	strh	r2, [r6, r5]
 8001b76:	5b72      	ldrh	r2, [r6, r5]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001b78:	4403      	add	r3, r0
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001b7a:	b292      	uxth	r2, r2
 8001b7c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001b80:	5372      	strh	r2, [r6, r5]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001b82:	f8b0 0050 	ldrh.w	r0, [r0, #80]	; 0x50
 8001b86:	b280      	uxth	r0, r0
 8001b88:	5a1a      	ldrh	r2, [r3, r0]
 8001b8a:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
 8001b8e:	0412      	lsls	r2, r2, #16
 8001b90:	0c12      	lsrs	r2, r2, #16
 8001b92:	521a      	strh	r2, [r3, r0]
 8001b94:	5a1a      	ldrh	r2, [r3, r0]
 8001b96:	b292      	uxth	r2, r2
 8001b98:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001b9c:	521a      	strh	r2, [r3, r0]
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8001b9e:	4620      	mov	r0, r4
 8001ba0:	f003 fcc0 	bl	8005524 <HAL_PCD_DataInStageCallback>
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 8001ba4:	f418 4f80 	tst.w	r8, #16384	; 0x4000
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 8001ba8:	6820      	ldr	r0, [r4, #0]
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 8001baa:	d183      	bne.n	8001ab4 <HAL_PCD_IRQHandler+0x738>
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 8001bac:	4602      	mov	r2, r0
 8001bae:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
 8001bb2:	f830 3021 	ldrh.w	r3, [r0, r1, lsl #2]
 8001bb6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8001bba:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001bbe:	041b      	lsls	r3, r3, #16
 8001bc0:	0c1b      	lsrs	r3, r3, #16
 8001bc2:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8001bc6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001bca:	f820 3021 	strh.w	r3, [r0, r1, lsl #2]
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8001bce:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
 8001bd2:	f830 3021 	ldrh.w	r3, [r0, r1, lsl #2]
 8001bd6:	b29b      	uxth	r3, r3
 8001bd8:	ea03 030a 	and.w	r3, r3, sl
 8001bdc:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8001be0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001be4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001be8:	f820 3021 	strh.w	r3, [r0, r1, lsl #2]

  return HAL_OK;
 8001bec:	e481      	b.n	80014f2 <HAL_PCD_IRQHandler+0x176>
 8001bee:	2300      	movs	r3, #0
 8001bf0:	f8cc 3040 	str.w	r3, [ip, #64]	; 0x40
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001bf4:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8001bf8:	2b00      	cmp	r3, #0
 8001bfa:	d17f      	bne.n	8001cfc <HAL_PCD_IRQHandler+0x980>
 8001bfc:	f8b0 5050 	ldrh.w	r5, [r0, #80]	; 0x50
 8001c00:	010b      	lsls	r3, r1, #4
 8001c02:	f203 4604 	addw	r6, r3, #1028	; 0x404
 8001c06:	4406      	add	r6, r0
 8001c08:	b2ad      	uxth	r5, r5
 8001c0a:	5b72      	ldrh	r2, [r6, r5]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001c0c:	f203 430c 	addw	r3, r3, #1036	; 0x40c
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001c10:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
 8001c14:	0412      	lsls	r2, r2, #16
 8001c16:	0c12      	lsrs	r2, r2, #16
 8001c18:	5372      	strh	r2, [r6, r5]
 8001c1a:	5b72      	ldrh	r2, [r6, r5]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001c1c:	4403      	add	r3, r0
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001c1e:	b292      	uxth	r2, r2
 8001c20:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001c24:	5372      	strh	r2, [r6, r5]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001c26:	f8b0 0050 	ldrh.w	r0, [r0, #80]	; 0x50
 8001c2a:	b280      	uxth	r0, r0
 8001c2c:	5a1a      	ldrh	r2, [r3, r0]
 8001c2e:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
 8001c32:	0412      	lsls	r2, r2, #16
 8001c34:	0c12      	lsrs	r2, r2, #16
 8001c36:	521a      	strh	r2, [r3, r0]
 8001c38:	5a1a      	ldrh	r2, [r3, r0]
 8001c3a:	b292      	uxth	r2, r2
 8001c3c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001c40:	521a      	strh	r2, [r3, r0]
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8001c42:	4620      	mov	r0, r4
 8001c44:	f003 fc6e 	bl	8005524 <HAL_PCD_DataInStageCallback>
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 8001c48:	f418 4f80 	tst.w	r8, #16384	; 0x4000
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 8001c4c:	6820      	ldr	r0, [r4, #0]
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 8001c4e:	d1ad      	bne.n	8001bac <HAL_PCD_IRQHandler+0x830>
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8001c50:	4602      	mov	r2, r0
 8001c52:	e7bc      	b.n	8001bce <HAL_PCD_IRQHandler+0x852>
            PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8001c54:	094e      	lsrs	r6, r1, #5
 8001c56:	06cf      	lsls	r7, r1, #27
 8001c58:	4987      	ldr	r1, [pc, #540]	; (8001e78 <HAL_PCD_IRQHandler+0xafc>)
 8001c5a:	bf08      	it	eq
 8001c5c:	f106 36ff 	addeq.w	r6, r6, #4294967295
 8001c60:	ea41 2186 	orr.w	r1, r1, r6, lsl #10
 8001c64:	b289      	uxth	r1, r1
 8001c66:	52e9      	strh	r1, [r5, r3]
 8001c68:	e686      	b.n	8001978 <HAL_PCD_IRQHandler+0x5fc>
    count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8001c6a:	f891 2168 	ldrb.w	r2, [r1, #360]	; 0x168
 8001c6e:	3306      	adds	r3, #6
 8001c70:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001c74:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8001c78:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
    if (ep->xfer_len >= count)
 8001c7c:	f8d1 e180 	ldr.w	lr, [r1, #384]	; 0x180
    count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8001c80:	f3c3 0309 	ubfx	r3, r3, #0, #10
    if (ep->xfer_len >= count)
 8001c84:	459e      	cmp	lr, r3
 8001c86:	461f      	mov	r7, r3
 8001c88:	d360      	bcc.n	8001d4c <HAL_PCD_IRQHandler+0x9d0>
      ep->xfer_len -= count;
 8001c8a:	ebae 0e03 	sub.w	lr, lr, r3
 8001c8e:	f8c1 e180 	str.w	lr, [r1, #384]	; 0x180
    if (ep->xfer_len == 0U)
 8001c92:	f1be 0f00 	cmp.w	lr, #0
 8001c96:	d05b      	beq.n	8001d50 <HAL_PCD_IRQHandler+0x9d4>
    if ((wEPVal & USB_EP_DTOG_TX) == 0U)
 8001c98:	f018 0f40 	tst.w	r8, #64	; 0x40
 8001c9c:	d10d      	bne.n	8001cba <HAL_PCD_IRQHandler+0x93e>
      PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 8001c9e:	f830 1022 	ldrh.w	r1, [r0, r2, lsl #2]
 8001ca2:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 8001ca6:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 8001caa:	0409      	lsls	r1, r1, #16
 8001cac:	0c09      	lsrs	r1, r1, #16
 8001cae:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8001cb2:	f041 01c0 	orr.w	r1, r1, #192	; 0xc0
 8001cb6:	f820 1022 	strh.w	r1, [r0, r2, lsl #2]
    if (count != 0U)
 8001cba:	b90b      	cbnz	r3, 8001cc0 <HAL_PCD_IRQHandler+0x944>
 8001cbc:	461f      	mov	r7, r3
 8001cbe:	e4ed      	b.n	800169c <HAL_PCD_IRQHandler+0x320>
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 8001cc0:	1971      	adds	r1, r6, r5
 8001cc2:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8001cc6:	f8b1 2172 	ldrh.w	r2, [r1, #370]	; 0x172
 8001cca:	f8d1 117c 	ldr.w	r1, [r1, #380]	; 0x17c
 8001cce:	f002 f81d 	bl	8003d0c <USB_ReadPMA>
 8001cd2:	e4e3      	b.n	800169c <HAL_PCD_IRQHandler+0x320>
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001cd4:	2b01      	cmp	r3, #1
 8001cd6:	f47f af62 	bne.w	8001b9e <HAL_PCD_IRQHandler+0x822>
 8001cda:	2500      	movs	r5, #0
 8001cdc:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8001ce0:	010b      	lsls	r3, r1, #4
 8001ce2:	f203 4604 	addw	r6, r3, #1028	; 0x404
 8001ce6:	b292      	uxth	r2, r2
 8001ce8:	4406      	add	r6, r0
 8001cea:	52b5      	strh	r5, [r6, r2]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001cec:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8001cf0:	f203 430c 	addw	r3, r3, #1036	; 0x40c
 8001cf4:	4403      	add	r3, r0
 8001cf6:	b292      	uxth	r2, r2
 8001cf8:	529d      	strh	r5, [r3, r2]
 8001cfa:	e750      	b.n	8001b9e <HAL_PCD_IRQHandler+0x822>
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001cfc:	2b01      	cmp	r3, #1
 8001cfe:	d1a0      	bne.n	8001c42 <HAL_PCD_IRQHandler+0x8c6>
 8001d00:	2500      	movs	r5, #0
 8001d02:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8001d06:	010b      	lsls	r3, r1, #4
 8001d08:	f203 4604 	addw	r6, r3, #1028	; 0x404
 8001d0c:	b292      	uxth	r2, r2
 8001d0e:	4406      	add	r6, r0
 8001d10:	52b5      	strh	r5, [r6, r2]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8001d12:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8001d16:	f203 430c 	addw	r3, r3, #1036	; 0x40c
 8001d1a:	4403      	add	r3, r0
 8001d1c:	b292      	uxth	r2, r2
 8001d1e:	529d      	strh	r5, [r3, r2]
 8001d20:	e78f      	b.n	8001c42 <HAL_PCD_IRQHandler+0x8c6>
 8001d22:	f04f 0c00 	mov.w	ip, #0
 8001d26:	f8c1 c180 	str.w	ip, [r1, #384]	; 0x180
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 8001d2a:	f830 1022 	ldrh.w	r1, [r0, r2, lsl #2]
 8001d2e:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8001d32:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 8001d36:	0409      	lsls	r1, r1, #16
 8001d38:	0c09      	lsrs	r1, r1, #16
 8001d3a:	f481 5100 	eor.w	r1, r1, #8192	; 0x2000
 8001d3e:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8001d42:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001d46:	f820 1022 	strh.w	r1, [r0, r2, lsl #2]
 8001d4a:	e6e0      	b.n	8001b0e <HAL_PCD_IRQHandler+0x792>
 8001d4c:	f8c1 c180 	str.w	ip, [r1, #384]	; 0x180
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 8001d50:	f830 1022 	ldrh.w	r1, [r0, r2, lsl #2]
 8001d54:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8001d58:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 8001d5c:	0409      	lsls	r1, r1, #16
 8001d5e:	0c09      	lsrs	r1, r1, #16
 8001d60:	f481 5100 	eor.w	r1, r1, #8192	; 0x2000
 8001d64:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8001d68:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001d6c:	f820 1022 	strh.w	r1, [r0, r2, lsl #2]
 8001d70:	e792      	b.n	8001c98 <HAL_PCD_IRQHandler+0x91c>
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001d72:	fa1f f388 	uxth.w	r3, r8
 8001d76:	f1be 0f01 	cmp.w	lr, #1
 8001d7a:	f47f ac62 	bne.w	8001642 <HAL_PCD_IRQHandler+0x2c6>
 8001d7e:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8001d82:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8001d86:	f201 4104 	addw	r1, r1, #1028	; 0x404
 8001d8a:	b292      	uxth	r2, r2
 8001d8c:	528b      	strh	r3, [r1, r2]
 8001d8e:	e458      	b.n	8001642 <HAL_PCD_IRQHandler+0x2c6>
        else if (ep->xfer_len_db == 0U)
 8001d90:	f1b8 0f00 	cmp.w	r8, #0
 8001d94:	d119      	bne.n	8001dca <HAL_PCD_IRQHandler+0xa4e>
          ep->xfer_fill_db = 0U;
 8001d96:	461a      	mov	r2, r3
 8001d98:	f88e 804c 	strb.w	r8, [lr, #76]	; 0x4c
 8001d9c:	e42f      	b.n	80015fe <HAL_PCD_IRQHandler+0x282>
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001d9e:	fa1f fe88 	uxth.w	lr, r8
 8001da2:	2b01      	cmp	r3, #1
 8001da4:	f47f ae7d 	bne.w	8001aa2 <HAL_PCD_IRQHandler+0x726>
 8001da8:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001dac:	eb00 1201 	add.w	r2, r0, r1, lsl #4
 8001db0:	f202 420c 	addw	r2, r2, #1036	; 0x40c
 8001db4:	b29b      	uxth	r3, r3
 8001db6:	f822 e003 	strh.w	lr, [r2, r3]
 8001dba:	e672      	b.n	8001aa2 <HAL_PCD_IRQHandler+0x726>
        else if (ep->xfer_len_db == 0U)
 8001dbc:	f1b8 0f00 	cmp.w	r8, #0
 8001dc0:	d125      	bne.n	8001e0e <HAL_PCD_IRQHandler+0xa92>
          ep->xfer_fill_db = 0U;
 8001dc2:	4672      	mov	r2, lr
 8001dc4:	f883 804c 	strb.w	r8, [r3, #76]	; 0x4c
 8001dc8:	e64b      	b.n	8001a62 <HAL_PCD_IRQHandler+0x6e6>
          ep->xfer_fill_db = 0U;
 8001dca:	2300      	movs	r3, #0
 8001dcc:	f88e 304c 	strb.w	r3, [lr, #76]	; 0x4c
          ep->xfer_len_db = 0U;
 8001dd0:	f8ce 3048 	str.w	r3, [lr, #72]	; 0x48
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001dd4:	f897 e029 	ldrb.w	lr, [r7, #41]	; 0x29
 8001dd8:	f1be 0f00 	cmp.w	lr, #0
 8001ddc:	d1c9      	bne.n	8001d72 <HAL_PCD_IRQHandler+0x9f6>
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 8001dde:	4642      	mov	r2, r8
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001de0:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001de4:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8001de8:	b29b      	uxth	r3, r3
 8001dea:	f201 4104 	addw	r1, r1, #1028	; 0x404
 8001dee:	4419      	add	r1, r3
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 8001df0:	fa1f f388 	uxth.w	r3, r8
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001df4:	2a3e      	cmp	r2, #62	; 0x3e
 8001df6:	d827      	bhi.n	8001e48 <HAL_PCD_IRQHandler+0xacc>
 8001df8:	ea4f 0e52 	mov.w	lr, r2, lsr #1
 8001dfc:	07d2      	lsls	r2, r2, #31
 8001dfe:	bf48      	it	mi
 8001e00:	f10e 0e01 	addmi.w	lr, lr, #1
 8001e04:	ea4f 228e 	mov.w	r2, lr, lsl #10
 8001e08:	b292      	uxth	r2, r2
 8001e0a:	800a      	strh	r2, [r1, #0]
 8001e0c:	e419      	b.n	8001642 <HAL_PCD_IRQHandler+0x2c6>
          ep->xfer_len_db = 0U;
 8001e0e:	2200      	movs	r2, #0
 8001e10:	649a      	str	r2, [r3, #72]	; 0x48
          ep->xfer_fill_db = 0;
 8001e12:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001e16:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8001e1a:	2b00      	cmp	r3, #0
 8001e1c:	d1bf      	bne.n	8001d9e <HAL_PCD_IRQHandler+0xa22>
 8001e1e:	eb00 1301 	add.w	r3, r0, r1, lsl #4
 8001e22:	f203 420c 	addw	r2, r3, #1036	; 0x40c
 8001e26:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 8001e2a:	fa1f fe88 	uxth.w	lr, r8
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001e2e:	b29b      	uxth	r3, r3
 8001e30:	4413      	add	r3, r2
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 8001e32:	4642      	mov	r2, r8
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001e34:	2a3e      	cmp	r2, #62	; 0x3e
 8001e36:	d814      	bhi.n	8001e62 <HAL_PCD_IRQHandler+0xae6>
 8001e38:	0851      	lsrs	r1, r2, #1
 8001e3a:	07d2      	lsls	r2, r2, #31
 8001e3c:	bf48      	it	mi
 8001e3e:	3101      	addmi	r1, #1
 8001e40:	028a      	lsls	r2, r1, #10
 8001e42:	b292      	uxth	r2, r2
 8001e44:	801a      	strh	r2, [r3, #0]
 8001e46:	e62c      	b.n	8001aa2 <HAL_PCD_IRQHandler+0x726>
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001e48:	ea4f 1e52 	mov.w	lr, r2, lsr #5
 8001e4c:	06d2      	lsls	r2, r2, #27
 8001e4e:	4a0a      	ldr	r2, [pc, #40]	; (8001e78 <HAL_PCD_IRQHandler+0xafc>)
 8001e50:	bf08      	it	eq
 8001e52:	f10e 3eff 	addeq.w	lr, lr, #4294967295
 8001e56:	ea42 228e 	orr.w	r2, r2, lr, lsl #10
 8001e5a:	b292      	uxth	r2, r2
 8001e5c:	800a      	strh	r2, [r1, #0]
 8001e5e:	f7ff bbf0 	b.w	8001642 <HAL_PCD_IRQHandler+0x2c6>
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8001e62:	0951      	lsrs	r1, r2, #5
 8001e64:	06d2      	lsls	r2, r2, #27
 8001e66:	4a04      	ldr	r2, [pc, #16]	; (8001e78 <HAL_PCD_IRQHandler+0xafc>)
 8001e68:	bf08      	it	eq
 8001e6a:	f101 31ff 	addeq.w	r1, r1, #4294967295
 8001e6e:	ea42 2281 	orr.w	r2, r2, r1, lsl #10
 8001e72:	b292      	uxth	r2, r2
 8001e74:	801a      	strh	r2, [r3, #0]
 8001e76:	e614      	b.n	8001aa2 <HAL_PCD_IRQHandler+0x726>
 8001e78:	ffff8000 	.word	0xffff8000

08001e7c <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8001e7c:	f890 22a8 	ldrb.w	r2, [r0, #680]	; 0x2a8
 8001e80:	2a01      	cmp	r2, #1
 8001e82:	d00e      	beq.n	8001ea2 <HAL_PCD_SetAddress+0x26>
{
 8001e84:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 8001e86:	2201      	movs	r2, #1
 8001e88:	4604      	mov	r4, r0
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8001e8a:	6800      	ldr	r0, [r0, #0]
  hpcd->USB_Address = address;
 8001e8c:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
  __HAL_LOCK(hpcd);
 8001e90:	f884 22a8 	strb.w	r2, [r4, #680]	; 0x2a8
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8001e94:	f001 ff1a 	bl	8003ccc <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8001e98:	2300      	movs	r3, #0
 8001e9a:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  return HAL_OK;
 8001e9e:	4618      	mov	r0, r3
}
 8001ea0:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8001ea2:	2002      	movs	r0, #2
}
 8001ea4:	4770      	bx	lr
 8001ea6:	bf00      	nop

08001ea8 <HAL_PCD_EP_Open>:
  if ((ep_addr & 0x80U) == 0x80U)
 8001ea8:	f001 0c07 	and.w	ip, r1, #7
 8001eac:	0609      	lsls	r1, r1, #24
{
 8001eae:	b510      	push	{r4, lr}
 8001eb0:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8001eb2:	d425      	bmi.n	8001f00 <HAL_PCD_EP_Open+0x58>
    ep->is_in = 0U;
 8001eb4:	f04f 0e00 	mov.w	lr, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001eb8:	eb0c 008c 	add.w	r0, ip, ip, lsl #2
 8001ebc:	00c0      	lsls	r0, r0, #3
 8001ebe:	f500 71b4 	add.w	r1, r0, #360	; 0x168
    ep->is_in = 0U;
 8001ec2:	4420      	add	r0, r4
 8001ec4:	f880 e169 	strb.w	lr, [r0, #361]	; 0x169
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001ec8:	4421      	add	r1, r4
  ep->maxpacket = ep_mps;
 8001eca:	610a      	str	r2, [r1, #16]
  if (ep->is_in != 0U)
 8001ecc:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8001ece:	f881 c000 	strb.w	ip, [r1]
  ep->type = ep_type;
 8001ed2:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in != 0U)
 8001ed4:	b10a      	cbz	r2, 8001eda <HAL_PCD_EP_Open+0x32>
    ep->tx_fifo_num = ep->num;
 8001ed6:	f8a1 c00e 	strh.w	ip, [r1, #14]
  if (ep_type == EP_TYPE_BULK)
 8001eda:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8001edc:	bf04      	itt	eq
 8001ede:	2300      	moveq	r3, #0
 8001ee0:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 8001ee2:	f894 32a8 	ldrb.w	r3, [r4, #680]	; 0x2a8
 8001ee6:	2b01      	cmp	r3, #1
 8001ee8:	d019      	beq.n	8001f1e <HAL_PCD_EP_Open+0x76>
 8001eea:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8001eec:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8001eee:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8001ef2:	f001 f915 	bl	8003120 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8001ef6:	2300      	movs	r3, #0
 8001ef8:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  return ret;
 8001efc:	4618      	mov	r0, r3
}
 8001efe:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001f00:	f10c 0101 	add.w	r1, ip, #1
    ep->is_in = 1U;
 8001f04:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8001f08:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 8001f0c:	2001      	movs	r0, #1
 8001f0e:	7048      	strb	r0, [r1, #1]
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001f10:	eb0c 0100 	add.w	r1, ip, r0
 8001f14:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8001f18:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
    ep->is_in = 1U;
 8001f1c:	e7d5      	b.n	8001eca <HAL_PCD_EP_Open+0x22>
  __HAL_LOCK(hpcd);
 8001f1e:	2002      	movs	r0, #2
}
 8001f20:	bd10      	pop	{r4, pc}
 8001f22:	bf00      	nop

08001f24 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80U) == 0x80U)
 8001f24:	060b      	lsls	r3, r1, #24
{
 8001f26:	b510      	push	{r4, lr}
 8001f28:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8001f2a:	d41b      	bmi.n	8001f64 <HAL_PCD_EP_Close+0x40>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001f2c:	f001 0307 	and.w	r3, r1, #7
 8001f30:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8001f34:	00d2      	lsls	r2, r2, #3
 8001f36:	f502 71b4 	add.w	r1, r2, #360	; 0x168
 8001f3a:	4401      	add	r1, r0
    ep->is_in = 0U;
 8001f3c:	4402      	add	r2, r0
 8001f3e:	2000      	movs	r0, #0
 8001f40:	f882 0169 	strb.w	r0, [r2, #361]	; 0x169
  ep->num   = ep_addr & EP_ADDR_MSK;
 8001f44:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8001f46:	f894 32a8 	ldrb.w	r3, [r4, #680]	; 0x2a8
 8001f4a:	2b01      	cmp	r3, #1
 8001f4c:	d019      	beq.n	8001f82 <HAL_PCD_EP_Close+0x5e>
 8001f4e:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8001f50:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8001f52:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8001f56:	f001 fa57 	bl	8003408 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8001f5a:	2300      	movs	r3, #0
 8001f5c:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  return HAL_OK;
 8001f60:	4618      	mov	r0, r3
}
 8001f62:	bd10      	pop	{r4, pc}
    ep->is_in = 1U;
 8001f64:	2001      	movs	r0, #1
 8001f66:	f001 0307 	and.w	r3, r1, #7
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001f6a:	181a      	adds	r2, r3, r0
    ep->is_in = 1U;
 8001f6c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8001f70:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001f74:	4611      	mov	r1, r2
    ep->is_in = 1U;
 8001f76:	7050      	strb	r0, [r2, #1]
  ep->num   = ep_addr & EP_ADDR_MSK;
 8001f78:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8001f7a:	f894 32a8 	ldrb.w	r3, [r4, #680]	; 0x2a8
 8001f7e:	2b01      	cmp	r3, #1
 8001f80:	d1e5      	bne.n	8001f4e <HAL_PCD_EP_Close+0x2a>
 8001f82:	2002      	movs	r0, #2
}
 8001f84:	bd10      	pop	{r4, pc}
 8001f86:	bf00      	nop

08001f88 <HAL_PCD_EP_Receive>:
{
 8001f88:	b510      	push	{r4, lr}
  ep->xfer_count = 0U;
 8001f8a:	2400      	movs	r4, #0
 8001f8c:	f001 0e07 	and.w	lr, r1, #7
  ep->xfer_buff = pBuf;
 8001f90:	eb0e 018e 	add.w	r1, lr, lr, lsl #2
 8001f94:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
  ep->xfer_len = len;
 8001f98:	e9cc 235f 	strd	r2, r3, [ip, #380]	; 0x17c
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8001f9c:	6800      	ldr	r0, [r0, #0]
 8001f9e:	f50c 71b4 	add.w	r1, ip, #360	; 0x168
  ep->xfer_count = 0U;
 8001fa2:	f8cc 4184 	str.w	r4, [ip, #388]	; 0x184
  ep->is_in = 0U;
 8001fa6:	f88c 4169 	strb.w	r4, [ip, #361]	; 0x169
  ep->num = ep_addr & EP_ADDR_MSK;
 8001faa:	f88c e168 	strb.w	lr, [ip, #360]	; 0x168
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8001fae:	f001 fb0b 	bl	80035c8 <USB_EPStartXfer>
}
 8001fb2:	4620      	mov	r0, r4
 8001fb4:	bd10      	pop	{r4, pc}
 8001fb6:	bf00      	nop

08001fb8 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8001fb8:	f001 0107 	and.w	r1, r1, #7
 8001fbc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8001fc0:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
 8001fc4:	f8d1 0184 	ldr.w	r0, [r1, #388]	; 0x184
 8001fc8:	4770      	bx	lr
 8001fca:	bf00      	nop

08001fcc <HAL_PCD_EP_Transmit>:
{
 8001fcc:	b570      	push	{r4, r5, r6, lr}
  ep->xfer_fill_db = 1U;
 8001fce:	2601      	movs	r6, #1
  ep->xfer_count = 0U;
 8001fd0:	2500      	movs	r5, #0
{
 8001fd2:	4604      	mov	r4, r0
 8001fd4:	f001 0e07 	and.w	lr, r1, #7
  ep->xfer_buff = pBuf;
 8001fd8:	eb0e 0c8e 	add.w	ip, lr, lr, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001fdc:	eb0e 0106 	add.w	r1, lr, r6
  ep->xfer_buff = pBuf;
 8001fe0:	eb00 0ccc 	add.w	ip, r0, ip, lsl #3
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001fe4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  ep->xfer_buff = pBuf;
 8001fe8:	f8cc 203c 	str.w	r2, [ip, #60]	; 0x3c
  ep->num = ep_addr & EP_ADDR_MSK;
 8001fec:	f88c e028 	strb.w	lr, [ip, #40]	; 0x28
  ep->xfer_len = len;
 8001ff0:	f8cc 3040 	str.w	r3, [ip, #64]	; 0x40
  ep->xfer_len_db = len;
 8001ff4:	f8cc 3048 	str.w	r3, [ip, #72]	; 0x48
  ep->xfer_fill_db = 1U;
 8001ff8:	f88c 604c 	strb.w	r6, [ip, #76]	; 0x4c
  ep->xfer_count = 0U;
 8001ffc:	f8cc 5044 	str.w	r5, [ip, #68]	; 0x44
  ep->is_in = 1U;
 8002000:	f88c 6029 	strb.w	r6, [ip, #41]	; 0x29
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8002004:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8002008:	6800      	ldr	r0, [r0, #0]
 800200a:	f001 fadd 	bl	80035c8 <USB_EPStartXfer>
}
 800200e:	4628      	mov	r0, r5
 8002010:	bd70      	pop	{r4, r5, r6, pc}
 8002012:	bf00      	nop

08002014 <HAL_PCD_EP_SetStall>:
{
 8002014:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8002016:	6843      	ldr	r3, [r0, #4]
 8002018:	f001 0507 	and.w	r5, r1, #7
 800201c:	429d      	cmp	r5, r3
 800201e:	d82f      	bhi.n	8002080 <HAL_PCD_EP_SetStall+0x6c>
  if ((0x80U & ep_addr) == 0x80U)
 8002020:	060b      	lsls	r3, r1, #24
 8002022:	4604      	mov	r4, r0
 8002024:	d41b      	bmi.n	800205e <HAL_PCD_EP_SetStall+0x4a>
    ep = &hpcd->OUT_ep[ep_addr];
 8002026:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800202a:	00c9      	lsls	r1, r1, #3
 800202c:	f501 72b4 	add.w	r2, r1, #360	; 0x168
    ep->is_in = 0U;
 8002030:	1843      	adds	r3, r0, r1
    ep = &hpcd->OUT_ep[ep_addr];
 8002032:	1881      	adds	r1, r0, r2
    ep->is_in = 0U;
 8002034:	2200      	movs	r2, #0
 8002036:	f883 2169 	strb.w	r2, [r3, #361]	; 0x169
  ep->is_stall = 1U;
 800203a:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 800203c:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 800203e:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8002040:	f894 22a8 	ldrb.w	r2, [r4, #680]	; 0x2a8
 8002044:	429a      	cmp	r2, r3
 8002046:	d019      	beq.n	800207c <HAL_PCD_EP_SetStall+0x68>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8002048:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800204a:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  (void)USB_EPSetStall(hpcd->Instance, ep);
 800204e:	f001 fdc5 	bl	8003bdc <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8002052:	b1bd      	cbz	r5, 8002084 <HAL_PCD_EP_SetStall+0x70>
  __HAL_UNLOCK(hpcd);
 8002054:	2300      	movs	r3, #0
 8002056:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  return HAL_OK;
 800205a:	4618      	mov	r0, r3
}
 800205c:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 800205e:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8002060:	18ab      	adds	r3, r5, r2
    ep->is_in = 1U;
 8002062:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8002066:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 800206a:	705a      	strb	r2, [r3, #1]
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800206c:	4619      	mov	r1, r3
  ep->is_stall = 1U;
 800206e:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8002070:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8002072:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8002074:	f894 22a8 	ldrb.w	r2, [r4, #680]	; 0x2a8
 8002078:	429a      	cmp	r2, r3
 800207a:	d1e5      	bne.n	8002048 <HAL_PCD_EP_SetStall+0x34>
 800207c:	2002      	movs	r0, #2
}
 800207e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8002080:	2001      	movs	r0, #1
}
 8002082:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8002084:	6820      	ldr	r0, [r4, #0]
 8002086:	f504 712c 	add.w	r1, r4, #688	; 0x2b0
 800208a:	f001 fe2d 	bl	8003ce8 <USB_EP0_OutStart>
 800208e:	e7e1      	b.n	8002054 <HAL_PCD_EP_SetStall+0x40>

08002090 <HAL_PCD_EP_ClrStall>:
{
 8002090:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8002092:	6843      	ldr	r3, [r0, #4]
 8002094:	f001 020f 	and.w	r2, r1, #15
 8002098:	429a      	cmp	r2, r3
 800209a:	d832      	bhi.n	8002102 <HAL_PCD_EP_ClrStall+0x72>
  if ((0x80U & ep_addr) == 0x80U)
 800209c:	060b      	lsls	r3, r1, #24
 800209e:	4604      	mov	r4, r0
 80020a0:	d41c      	bmi.n	80020dc <HAL_PCD_EP_ClrStall+0x4c>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80020a2:	f001 0307 	and.w	r3, r1, #7
 80020a6:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80020aa:	00d2      	lsls	r2, r2, #3
 80020ac:	f502 71b4 	add.w	r1, r2, #360	; 0x168
 80020b0:	4401      	add	r1, r0
    ep->is_in = 0U;
 80020b2:	4402      	add	r2, r0
  ep->is_stall = 0U;
 80020b4:	2500      	movs	r5, #0
    ep->is_in = 0U;
 80020b6:	2000      	movs	r0, #0
 80020b8:	f882 0169 	strb.w	r0, [r2, #361]	; 0x169
  ep->num = ep_addr & EP_ADDR_MSK;
 80020bc:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 80020be:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 80020c0:	f894 32a8 	ldrb.w	r3, [r4, #680]	; 0x2a8
 80020c4:	2b01      	cmp	r3, #1
 80020c6:	d01a      	beq.n	80020fe <HAL_PCD_EP_ClrStall+0x6e>
 80020c8:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 80020ca:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 80020cc:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  (void)USB_EPClearStall(hpcd->Instance, ep);
 80020d0:	f001 fdac 	bl	8003c2c <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 80020d4:	f884 52a8 	strb.w	r5, [r4, #680]	; 0x2a8
  return HAL_OK;
 80020d8:	4628      	mov	r0, r5
}
 80020da:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 80020dc:	2001      	movs	r0, #1
 80020de:	f001 0307 	and.w	r3, r1, #7
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80020e2:	181a      	adds	r2, r3, r0
    ep->is_in = 1U;
 80020e4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80020e8:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80020ec:	4611      	mov	r1, r2
  ep->is_stall = 0U;
 80020ee:	2500      	movs	r5, #0
    ep->is_in = 1U;
 80020f0:	7050      	strb	r0, [r2, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 80020f2:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 80020f4:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 80020f6:	f894 32a8 	ldrb.w	r3, [r4, #680]	; 0x2a8
 80020fa:	2b01      	cmp	r3, #1
 80020fc:	d1e4      	bne.n	80020c8 <HAL_PCD_EP_ClrStall+0x38>
 80020fe:	2002      	movs	r0, #2
}
 8002100:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8002102:	2001      	movs	r0, #1
}
 8002104:	bd38      	pop	{r3, r4, r5, pc}
 8002106:	bf00      	nop

08002108 <HAL_PCD_EP_Flush>:
  __HAL_LOCK(hpcd);
 8002108:	f890 32a8 	ldrb.w	r3, [r0, #680]	; 0x2a8
 800210c:	2b01      	cmp	r3, #1
 800210e:	d017      	beq.n	8002140 <HAL_PCD_EP_Flush+0x38>
 8002110:	2301      	movs	r3, #1
{
 8002112:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 8002114:	f880 32a8 	strb.w	r3, [r0, #680]	; 0x2a8
  if ((ep_addr & 0x80U) == 0x80U)
 8002118:	060b      	lsls	r3, r1, #24
 800211a:	4604      	mov	r4, r0
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
 800211c:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0x80U) == 0x80U)
 800211e:	d406      	bmi.n	800212e <HAL_PCD_EP_Flush+0x26>
    (void)USB_FlushRxFifo(hpcd->Instance);
 8002120:	f000 fffc 	bl	800311c <USB_FlushRxFifo>
  __HAL_UNLOCK(hpcd);
 8002124:	2300      	movs	r3, #0
 8002126:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  return HAL_OK;
 800212a:	4618      	mov	r0, r3
}
 800212c:	bd10      	pop	{r4, pc}
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
 800212e:	f001 0107 	and.w	r1, r1, #7
 8002132:	f000 fff1 	bl	8003118 <USB_FlushTxFifo>
  __HAL_UNLOCK(hpcd);
 8002136:	2300      	movs	r3, #0
 8002138:	f884 32a8 	strb.w	r3, [r4, #680]	; 0x2a8
  return HAL_OK;
 800213c:	4618      	mov	r0, r3
}
 800213e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8002140:	2002      	movs	r0, #2
}
 8002142:	4770      	bx	lr

08002144 <HAL_PCDEx_PMAConfig>:
                                       uint16_t ep_kind, uint32_t pmaadress)
{
  PCD_EPTypeDef *ep;

  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 8002144:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002148:	d00b      	beq.n	8002162 <HAL_PCDEx_PMAConfig+0x1e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800214a:	f001 0107 	and.w	r1, r1, #7
 800214e:	3101      	adds	r1, #1
 8002150:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002154:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }

  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 8002158:	b95a      	cbnz	r2, 8002172 <HAL_PCDEx_PMAConfig+0x2e>
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
  }

  return HAL_OK;
}
 800215a:	2000      	movs	r0, #0
    ep->pmaadress = (uint16_t)pmaadress;
 800215c:	80cb      	strh	r3, [r1, #6]
 800215e:	730a      	strb	r2, [r1, #12]
}
 8002160:	4770      	bx	lr
    ep = &hpcd->OUT_ep[ep_addr];
 8002162:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002166:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 800216a:	f501 71b4 	add.w	r1, r1, #360	; 0x168
  if (ep_kind == PCD_SNG_BUF)
 800216e:	2a00      	cmp	r2, #0
 8002170:	d0f3      	beq.n	800215a <HAL_PCDEx_PMAConfig+0x16>
    ep->doublebuffer = 1U;
 8002172:	2201      	movs	r2, #1
}
 8002174:	2000      	movs	r0, #0
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
 8002176:	608b      	str	r3, [r1, #8]
 8002178:	730a      	strb	r2, [r1, #12]
}
 800217a:	4770      	bx	lr

0800217c <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t pll_config;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800217c:	2800      	cmp	r0, #0
 800217e:	f000 81b6 	beq.w	80024ee <HAL_RCC_OscConfig+0x372>
{
 8002182:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002186:	6803      	ldr	r3, [r0, #0]
 8002188:	4604      	mov	r4, r0
 800218a:	07dd      	lsls	r5, r3, #31
{
 800218c:	b082      	sub	sp, #8
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800218e:	d535      	bpl.n	80021fc <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002190:	499a      	ldr	r1, [pc, #616]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 8002192:	684a      	ldr	r2, [r1, #4]
 8002194:	f002 020c 	and.w	r2, r2, #12
 8002198:	2a04      	cmp	r2, #4
 800219a:	f000 80ef 	beq.w	800237c <HAL_RCC_OscConfig+0x200>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800219e:	684a      	ldr	r2, [r1, #4]
 80021a0:	f002 020c 	and.w	r2, r2, #12
 80021a4:	2a08      	cmp	r2, #8
 80021a6:	f000 80e5 	beq.w	8002374 <HAL_RCC_OscConfig+0x1f8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80021aa:	6863      	ldr	r3, [r4, #4]
 80021ac:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80021b0:	d010      	beq.n	80021d4 <HAL_RCC_OscConfig+0x58>
 80021b2:	2b00      	cmp	r3, #0
 80021b4:	f000 810c 	beq.w	80023d0 <HAL_RCC_OscConfig+0x254>
 80021b8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80021bc:	f000 8182 	beq.w	80024c4 <HAL_RCC_OscConfig+0x348>
 80021c0:	4b8e      	ldr	r3, [pc, #568]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 80021c2:	681a      	ldr	r2, [r3, #0]
 80021c4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80021c8:	601a      	str	r2, [r3, #0]
 80021ca:	681a      	ldr	r2, [r3, #0]
 80021cc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80021d0:	601a      	str	r2, [r3, #0]
 80021d2:	e004      	b.n	80021de <HAL_RCC_OscConfig+0x62>
 80021d4:	4a89      	ldr	r2, [pc, #548]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 80021d6:	6813      	ldr	r3, [r2, #0]
 80021d8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80021dc:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80021de:	f7fe fc19 	bl	8000a14 <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021e2:	4e86      	ldr	r6, [pc, #536]	; (80023fc <HAL_RCC_OscConfig+0x280>)
        tickstart = HAL_GetTick();
 80021e4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021e6:	e005      	b.n	80021f4 <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80021e8:	f7fe fc14 	bl	8000a14 <HAL_GetTick>
 80021ec:	1b40      	subs	r0, r0, r5
 80021ee:	2864      	cmp	r0, #100	; 0x64
 80021f0:	f200 80ea 	bhi.w	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021f4:	6833      	ldr	r3, [r6, #0]
 80021f6:	039a      	lsls	r2, r3, #14
 80021f8:	d5f6      	bpl.n	80021e8 <HAL_RCC_OscConfig+0x6c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80021fa:	6823      	ldr	r3, [r4, #0]
 80021fc:	079f      	lsls	r7, r3, #30
 80021fe:	d528      	bpl.n	8002252 <HAL_RCC_OscConfig+0xd6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8002200:	4a7e      	ldr	r2, [pc, #504]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 8002202:	6851      	ldr	r1, [r2, #4]
 8002204:	f011 0f0c 	tst.w	r1, #12
 8002208:	f000 808d 	beq.w	8002326 <HAL_RCC_OscConfig+0x1aa>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800220c:	6851      	ldr	r1, [r2, #4]
 800220e:	f001 010c 	and.w	r1, r1, #12
 8002212:	2908      	cmp	r1, #8
 8002214:	f000 8083 	beq.w	800231e <HAL_RCC_OscConfig+0x1a2>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8002218:	6923      	ldr	r3, [r4, #16]
 800221a:	2b00      	cmp	r3, #0
 800221c:	f000 8118 	beq.w	8002450 <HAL_RCC_OscConfig+0x2d4>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8002220:	2201      	movs	r2, #1
 8002222:	4b77      	ldr	r3, [pc, #476]	; (8002400 <HAL_RCC_OscConfig+0x284>)

        /* Get Start Tick */
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002224:	4e75      	ldr	r6, [pc, #468]	; (80023fc <HAL_RCC_OscConfig+0x280>)
        __HAL_RCC_HSI_ENABLE();
 8002226:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002228:	f7fe fbf4 	bl	8000a14 <HAL_GetTick>
 800222c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800222e:	e005      	b.n	800223c <HAL_RCC_OscConfig+0xc0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002230:	f7fe fbf0 	bl	8000a14 <HAL_GetTick>
 8002234:	1b40      	subs	r0, r0, r5
 8002236:	2802      	cmp	r0, #2
 8002238:	f200 80c6 	bhi.w	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800223c:	6833      	ldr	r3, [r6, #0]
 800223e:	0798      	lsls	r0, r3, #30
 8002240:	d5f6      	bpl.n	8002230 <HAL_RCC_OscConfig+0xb4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002242:	6833      	ldr	r3, [r6, #0]
 8002244:	6962      	ldr	r2, [r4, #20]
 8002246:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800224a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800224e:	6033      	str	r3, [r6, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002250:	6823      	ldr	r3, [r4, #0]
 8002252:	071a      	lsls	r2, r3, #28
 8002254:	d41f      	bmi.n	8002296 <HAL_RCC_OscConfig+0x11a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002256:	075d      	lsls	r5, r3, #29
 8002258:	d542      	bpl.n	80022e0 <HAL_RCC_OscConfig+0x164>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800225a:	4b68      	ldr	r3, [pc, #416]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 800225c:	69da      	ldr	r2, [r3, #28]
 800225e:	00d0      	lsls	r0, r2, #3
 8002260:	d57d      	bpl.n	800235e <HAL_RCC_OscConfig+0x1e2>
    FlagStatus       pwrclkchanged = RESET;
 8002262:	2500      	movs	r5, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002264:	4e67      	ldr	r6, [pc, #412]	; (8002404 <HAL_RCC_OscConfig+0x288>)
 8002266:	6833      	ldr	r3, [r6, #0]
 8002268:	05d9      	lsls	r1, r3, #23
 800226a:	f140 809d 	bpl.w	80023a8 <HAL_RCC_OscConfig+0x22c>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800226e:	68e3      	ldr	r3, [r4, #12]
 8002270:	2b01      	cmp	r3, #1
 8002272:	f000 80fe 	beq.w	8002472 <HAL_RCC_OscConfig+0x2f6>
 8002276:	2b00      	cmp	r3, #0
 8002278:	f000 80ca 	beq.w	8002410 <HAL_RCC_OscConfig+0x294>
 800227c:	2b05      	cmp	r3, #5
 800227e:	4b5f      	ldr	r3, [pc, #380]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 8002280:	6a1a      	ldr	r2, [r3, #32]
 8002282:	f000 812c 	beq.w	80024de <HAL_RCC_OscConfig+0x362>
 8002286:	f022 0201 	bic.w	r2, r2, #1
 800228a:	621a      	str	r2, [r3, #32]
 800228c:	6a1a      	ldr	r2, [r3, #32]
 800228e:	f022 0204 	bic.w	r2, r2, #4
 8002292:	621a      	str	r2, [r3, #32]
 8002294:	e0f2      	b.n	800247c <HAL_RCC_OscConfig+0x300>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002296:	69a3      	ldr	r3, [r4, #24]
 8002298:	2b00      	cmp	r3, #0
 800229a:	d04f      	beq.n	800233c <HAL_RCC_OscConfig+0x1c0>
      __HAL_RCC_LSI_ENABLE();
 800229c:	2201      	movs	r2, #1
 800229e:	4b58      	ldr	r3, [pc, #352]	; (8002400 <HAL_RCC_OscConfig+0x284>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80022a0:	4e56      	ldr	r6, [pc, #344]	; (80023fc <HAL_RCC_OscConfig+0x280>)
      __HAL_RCC_LSI_ENABLE();
 80022a2:	f8c3 2480 	str.w	r2, [r3, #1152]	; 0x480
      tickstart = HAL_GetTick();
 80022a6:	f7fe fbb5 	bl	8000a14 <HAL_GetTick>
 80022aa:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80022ac:	e005      	b.n	80022ba <HAL_RCC_OscConfig+0x13e>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80022ae:	f7fe fbb1 	bl	8000a14 <HAL_GetTick>
 80022b2:	1b40      	subs	r0, r0, r5
 80022b4:	2802      	cmp	r0, #2
 80022b6:	f200 8087 	bhi.w	80023c8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80022ba:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80022bc:	079b      	lsls	r3, r3, #30
 80022be:	d5f6      	bpl.n	80022ae <HAL_RCC_OscConfig+0x132>
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 80022c0:	4b51      	ldr	r3, [pc, #324]	; (8002408 <HAL_RCC_OscConfig+0x28c>)
 80022c2:	4a52      	ldr	r2, [pc, #328]	; (800240c <HAL_RCC_OscConfig+0x290>)
 80022c4:	681b      	ldr	r3, [r3, #0]
 80022c6:	fba2 2303 	umull	r2, r3, r2, r3
 80022ca:	0a5b      	lsrs	r3, r3, #9
 80022cc:	9301      	str	r3, [sp, #4]
  do
  {
    __NOP();
 80022ce:	bf00      	nop
  }
  while (Delay --);
 80022d0:	9b01      	ldr	r3, [sp, #4]
 80022d2:	1e5a      	subs	r2, r3, #1
 80022d4:	9201      	str	r2, [sp, #4]
 80022d6:	2b00      	cmp	r3, #0
 80022d8:	d1f9      	bne.n	80022ce <HAL_RCC_OscConfig+0x152>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80022da:	6823      	ldr	r3, [r4, #0]
 80022dc:	075d      	lsls	r5, r3, #29
 80022de:	d4bc      	bmi.n	800225a <HAL_RCC_OscConfig+0xde>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80022e0:	69e0      	ldr	r0, [r4, #28]
 80022e2:	b1c0      	cbz	r0, 8002316 <HAL_RCC_OscConfig+0x19a>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80022e4:	4d45      	ldr	r5, [pc, #276]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 80022e6:	686b      	ldr	r3, [r5, #4]
 80022e8:	f003 030c 	and.w	r3, r3, #12
 80022ec:	2b08      	cmp	r3, #8
 80022ee:	f000 80d8 	beq.w	80024a2 <HAL_RCC_OscConfig+0x326>
        __HAL_RCC_PLL_DISABLE();
 80022f2:	2200      	movs	r2, #0
 80022f4:	4b42      	ldr	r3, [pc, #264]	; (8002400 <HAL_RCC_OscConfig+0x284>)
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80022f6:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 80022f8:	661a      	str	r2, [r3, #96]	; 0x60
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80022fa:	f000 80fa 	beq.w	80024f2 <HAL_RCC_OscConfig+0x376>
        tickstart = HAL_GetTick();
 80022fe:	f7fe fb89 	bl	8000a14 <HAL_GetTick>
 8002302:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002304:	e004      	b.n	8002310 <HAL_RCC_OscConfig+0x194>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002306:	f7fe fb85 	bl	8000a14 <HAL_GetTick>
 800230a:	1b00      	subs	r0, r0, r4
 800230c:	2802      	cmp	r0, #2
 800230e:	d85b      	bhi.n	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002310:	682b      	ldr	r3, [r5, #0]
 8002312:	019b      	lsls	r3, r3, #6
 8002314:	d4f7      	bmi.n	8002306 <HAL_RCC_OscConfig+0x18a>
  return HAL_OK;
 8002316:	2000      	movs	r0, #0
}
 8002318:	b002      	add	sp, #8
 800231a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800231e:	6852      	ldr	r2, [r2, #4]
 8002320:	03d6      	lsls	r6, r2, #15
 8002322:	f53f af79 	bmi.w	8002218 <HAL_RCC_OscConfig+0x9c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002326:	4a35      	ldr	r2, [pc, #212]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 8002328:	6812      	ldr	r2, [r2, #0]
 800232a:	0795      	lsls	r5, r2, #30
 800232c:	d530      	bpl.n	8002390 <HAL_RCC_OscConfig+0x214>
 800232e:	6922      	ldr	r2, [r4, #16]
 8002330:	2a01      	cmp	r2, #1
 8002332:	d02d      	beq.n	8002390 <HAL_RCC_OscConfig+0x214>
        return HAL_ERROR;
 8002334:	2001      	movs	r0, #1
}
 8002336:	b002      	add	sp, #8
 8002338:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 800233c:	4a30      	ldr	r2, [pc, #192]	; (8002400 <HAL_RCC_OscConfig+0x284>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800233e:	4e2f      	ldr	r6, [pc, #188]	; (80023fc <HAL_RCC_OscConfig+0x280>)
      __HAL_RCC_LSI_DISABLE();
 8002340:	f8c2 3480 	str.w	r3, [r2, #1152]	; 0x480
      tickstart = HAL_GetTick();
 8002344:	f7fe fb66 	bl	8000a14 <HAL_GetTick>
 8002348:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800234a:	e004      	b.n	8002356 <HAL_RCC_OscConfig+0x1da>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800234c:	f7fe fb62 	bl	8000a14 <HAL_GetTick>
 8002350:	1b40      	subs	r0, r0, r5
 8002352:	2802      	cmp	r0, #2
 8002354:	d838      	bhi.n	80023c8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002356:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002358:	079f      	lsls	r7, r3, #30
 800235a:	d4f7      	bmi.n	800234c <HAL_RCC_OscConfig+0x1d0>
 800235c:	e7bd      	b.n	80022da <HAL_RCC_OscConfig+0x15e>
      __HAL_RCC_PWR_CLK_ENABLE();
 800235e:	69da      	ldr	r2, [r3, #28]
      pwrclkchanged = SET;
 8002360:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8002362:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002366:	61da      	str	r2, [r3, #28]
 8002368:	69db      	ldr	r3, [r3, #28]
 800236a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800236e:	9300      	str	r3, [sp, #0]
 8002370:	9b00      	ldr	r3, [sp, #0]
      pwrclkchanged = SET;
 8002372:	e777      	b.n	8002264 <HAL_RCC_OscConfig+0xe8>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8002374:	684a      	ldr	r2, [r1, #4]
 8002376:	03d0      	lsls	r0, r2, #15
 8002378:	f57f af17 	bpl.w	80021aa <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800237c:	4a1f      	ldr	r2, [pc, #124]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 800237e:	6812      	ldr	r2, [r2, #0]
 8002380:	0391      	lsls	r1, r2, #14
 8002382:	f57f af3b 	bpl.w	80021fc <HAL_RCC_OscConfig+0x80>
 8002386:	6862      	ldr	r2, [r4, #4]
 8002388:	2a00      	cmp	r2, #0
 800238a:	f47f af37 	bne.w	80021fc <HAL_RCC_OscConfig+0x80>
 800238e:	e7d1      	b.n	8002334 <HAL_RCC_OscConfig+0x1b8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002390:	491a      	ldr	r1, [pc, #104]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 8002392:	6960      	ldr	r0, [r4, #20]
 8002394:	680a      	ldr	r2, [r1, #0]
 8002396:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800239a:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 800239e:	600a      	str	r2, [r1, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80023a0:	071a      	lsls	r2, r3, #28
 80023a2:	f57f af58 	bpl.w	8002256 <HAL_RCC_OscConfig+0xda>
 80023a6:	e776      	b.n	8002296 <HAL_RCC_OscConfig+0x11a>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80023a8:	6833      	ldr	r3, [r6, #0]
 80023aa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80023ae:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80023b0:	f7fe fb30 	bl	8000a14 <HAL_GetTick>
 80023b4:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80023b6:	6833      	ldr	r3, [r6, #0]
 80023b8:	05da      	lsls	r2, r3, #23
 80023ba:	f53f af58 	bmi.w	800226e <HAL_RCC_OscConfig+0xf2>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80023be:	f7fe fb29 	bl	8000a14 <HAL_GetTick>
 80023c2:	1bc0      	subs	r0, r0, r7
 80023c4:	2864      	cmp	r0, #100	; 0x64
 80023c6:	d9f6      	bls.n	80023b6 <HAL_RCC_OscConfig+0x23a>
            return HAL_TIMEOUT;
 80023c8:	2003      	movs	r0, #3
}
 80023ca:	b002      	add	sp, #8
 80023cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80023d0:	4d0a      	ldr	r5, [pc, #40]	; (80023fc <HAL_RCC_OscConfig+0x280>)
 80023d2:	682b      	ldr	r3, [r5, #0]
 80023d4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80023d8:	602b      	str	r3, [r5, #0]
 80023da:	682b      	ldr	r3, [r5, #0]
 80023dc:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80023e0:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80023e2:	f7fe fb17 	bl	8000a14 <HAL_GetTick>
 80023e6:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80023e8:	e004      	b.n	80023f4 <HAL_RCC_OscConfig+0x278>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80023ea:	f7fe fb13 	bl	8000a14 <HAL_GetTick>
 80023ee:	1b80      	subs	r0, r0, r6
 80023f0:	2864      	cmp	r0, #100	; 0x64
 80023f2:	d8e9      	bhi.n	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80023f4:	682b      	ldr	r3, [r5, #0]
 80023f6:	039b      	lsls	r3, r3, #14
 80023f8:	d4f7      	bmi.n	80023ea <HAL_RCC_OscConfig+0x26e>
 80023fa:	e6fe      	b.n	80021fa <HAL_RCC_OscConfig+0x7e>
 80023fc:	40021000 	.word	0x40021000
 8002400:	42420000 	.word	0x42420000
 8002404:	40007000 	.word	0x40007000
 8002408:	20000000 	.word	0x20000000
 800240c:	10624dd3 	.word	0x10624dd3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002410:	4e50      	ldr	r6, [pc, #320]	; (8002554 <HAL_RCC_OscConfig+0x3d8>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002412:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002416:	6a33      	ldr	r3, [r6, #32]
 8002418:	f023 0301 	bic.w	r3, r3, #1
 800241c:	6233      	str	r3, [r6, #32]
 800241e:	6a33      	ldr	r3, [r6, #32]
 8002420:	f023 0304 	bic.w	r3, r3, #4
 8002424:	6233      	str	r3, [r6, #32]
      tickstart = HAL_GetTick();
 8002426:	f7fe faf5 	bl	8000a14 <HAL_GetTick>
 800242a:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800242c:	e004      	b.n	8002438 <HAL_RCC_OscConfig+0x2bc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800242e:	f7fe faf1 	bl	8000a14 <HAL_GetTick>
 8002432:	1bc0      	subs	r0, r0, r7
 8002434:	4540      	cmp	r0, r8
 8002436:	d8c7      	bhi.n	80023c8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002438:	6a33      	ldr	r3, [r6, #32]
 800243a:	0798      	lsls	r0, r3, #30
 800243c:	d4f7      	bmi.n	800242e <HAL_RCC_OscConfig+0x2b2>
    if (pwrclkchanged == SET)
 800243e:	2d00      	cmp	r5, #0
 8002440:	f43f af4e 	beq.w	80022e0 <HAL_RCC_OscConfig+0x164>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002444:	4a43      	ldr	r2, [pc, #268]	; (8002554 <HAL_RCC_OscConfig+0x3d8>)
 8002446:	69d3      	ldr	r3, [r2, #28]
 8002448:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800244c:	61d3      	str	r3, [r2, #28]
 800244e:	e747      	b.n	80022e0 <HAL_RCC_OscConfig+0x164>
        __HAL_RCC_HSI_DISABLE();
 8002450:	4a41      	ldr	r2, [pc, #260]	; (8002558 <HAL_RCC_OscConfig+0x3dc>)
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002452:	4e40      	ldr	r6, [pc, #256]	; (8002554 <HAL_RCC_OscConfig+0x3d8>)
        __HAL_RCC_HSI_DISABLE();
 8002454:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002456:	f7fe fadd 	bl	8000a14 <HAL_GetTick>
 800245a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800245c:	e004      	b.n	8002468 <HAL_RCC_OscConfig+0x2ec>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800245e:	f7fe fad9 	bl	8000a14 <HAL_GetTick>
 8002462:	1b40      	subs	r0, r0, r5
 8002464:	2802      	cmp	r0, #2
 8002466:	d8af      	bhi.n	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002468:	6833      	ldr	r3, [r6, #0]
 800246a:	0799      	lsls	r1, r3, #30
 800246c:	d4f7      	bmi.n	800245e <HAL_RCC_OscConfig+0x2e2>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800246e:	6823      	ldr	r3, [r4, #0]
 8002470:	e6ef      	b.n	8002252 <HAL_RCC_OscConfig+0xd6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002472:	4a38      	ldr	r2, [pc, #224]	; (8002554 <HAL_RCC_OscConfig+0x3d8>)
 8002474:	6a13      	ldr	r3, [r2, #32]
 8002476:	f043 0301 	orr.w	r3, r3, #1
 800247a:	6213      	str	r3, [r2, #32]
      tickstart = HAL_GetTick();
 800247c:	f7fe faca 	bl	8000a14 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002480:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8002484:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002486:	4f33      	ldr	r7, [pc, #204]	; (8002554 <HAL_RCC_OscConfig+0x3d8>)
 8002488:	e004      	b.n	8002494 <HAL_RCC_OscConfig+0x318>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800248a:	f7fe fac3 	bl	8000a14 <HAL_GetTick>
 800248e:	1b80      	subs	r0, r0, r6
 8002490:	4540      	cmp	r0, r8
 8002492:	d899      	bhi.n	80023c8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002494:	6a3b      	ldr	r3, [r7, #32]
 8002496:	079b      	lsls	r3, r3, #30
 8002498:	d5f7      	bpl.n	800248a <HAL_RCC_OscConfig+0x30e>
    if (pwrclkchanged == SET)
 800249a:	2d00      	cmp	r5, #0
 800249c:	f43f af20 	beq.w	80022e0 <HAL_RCC_OscConfig+0x164>
 80024a0:	e7d0      	b.n	8002444 <HAL_RCC_OscConfig+0x2c8>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80024a2:	2801      	cmp	r0, #1
 80024a4:	f43f af38 	beq.w	8002318 <HAL_RCC_OscConfig+0x19c>
        pll_config = RCC->CFGR;
 80024a8:	686b      	ldr	r3, [r5, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80024aa:	6a22      	ldr	r2, [r4, #32]
 80024ac:	f403 3180 	and.w	r1, r3, #65536	; 0x10000
 80024b0:	4291      	cmp	r1, r2
 80024b2:	f47f af3f 	bne.w	8002334 <HAL_RCC_OscConfig+0x1b8>
 80024b6:	6a60      	ldr	r0, [r4, #36]	; 0x24
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 80024b8:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
  return HAL_OK;
 80024bc:	1a18      	subs	r0, r3, r0
 80024be:	bf18      	it	ne
 80024c0:	2001      	movne	r0, #1
 80024c2:	e729      	b.n	8002318 <HAL_RCC_OscConfig+0x19c>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80024c4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80024c8:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 80024cc:	681a      	ldr	r2, [r3, #0]
 80024ce:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80024d2:	601a      	str	r2, [r3, #0]
 80024d4:	681a      	ldr	r2, [r3, #0]
 80024d6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80024da:	601a      	str	r2, [r3, #0]
 80024dc:	e67f      	b.n	80021de <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024de:	f042 0204 	orr.w	r2, r2, #4
 80024e2:	621a      	str	r2, [r3, #32]
 80024e4:	6a1a      	ldr	r2, [r3, #32]
 80024e6:	f042 0201 	orr.w	r2, r2, #1
 80024ea:	621a      	str	r2, [r3, #32]
 80024ec:	e7c6      	b.n	800247c <HAL_RCC_OscConfig+0x300>
    return HAL_ERROR;
 80024ee:	2001      	movs	r0, #1
}
 80024f0:	4770      	bx	lr
        tickstart = HAL_GetTick();
 80024f2:	f7fe fa8f 	bl	8000a14 <HAL_GetTick>
 80024f6:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80024f8:	e005      	b.n	8002506 <HAL_RCC_OscConfig+0x38a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80024fa:	f7fe fa8b 	bl	8000a14 <HAL_GetTick>
 80024fe:	1b80      	subs	r0, r0, r6
 8002500:	2802      	cmp	r0, #2
 8002502:	f63f af61 	bhi.w	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002506:	682b      	ldr	r3, [r5, #0]
 8002508:	0199      	lsls	r1, r3, #6
 800250a:	d4f6      	bmi.n	80024fa <HAL_RCC_OscConfig+0x37e>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 800250c:	6a23      	ldr	r3, [r4, #32]
 800250e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002512:	d105      	bne.n	8002520 <HAL_RCC_OscConfig+0x3a4>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8002514:	686a      	ldr	r2, [r5, #4]
 8002516:	68a1      	ldr	r1, [r4, #8]
 8002518:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800251c:	430a      	orrs	r2, r1
 800251e:	606a      	str	r2, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8002520:	2001      	movs	r0, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002522:	4d0c      	ldr	r5, [pc, #48]	; (8002554 <HAL_RCC_OscConfig+0x3d8>)
 8002524:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002526:	686a      	ldr	r2, [r5, #4]
 8002528:	430b      	orrs	r3, r1
 800252a:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
        __HAL_RCC_PLL_ENABLE();
 800252e:	490a      	ldr	r1, [pc, #40]	; (8002558 <HAL_RCC_OscConfig+0x3dc>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002530:	4313      	orrs	r3, r2
 8002532:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8002534:	6608      	str	r0, [r1, #96]	; 0x60
        tickstart = HAL_GetTick();
 8002536:	f7fe fa6d 	bl	8000a14 <HAL_GetTick>
 800253a:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800253c:	e005      	b.n	800254a <HAL_RCC_OscConfig+0x3ce>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800253e:	f7fe fa69 	bl	8000a14 <HAL_GetTick>
 8002542:	1b00      	subs	r0, r0, r4
 8002544:	2802      	cmp	r0, #2
 8002546:	f63f af3f 	bhi.w	80023c8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800254a:	682b      	ldr	r3, [r5, #0]
 800254c:	019a      	lsls	r2, r3, #6
 800254e:	d5f6      	bpl.n	800253e <HAL_RCC_OscConfig+0x3c2>
 8002550:	e6e1      	b.n	8002316 <HAL_RCC_OscConfig+0x19a>
 8002552:	bf00      	nop
 8002554:	40021000 	.word	0x40021000
 8002558:	42420000 	.word	0x42420000

0800255c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 800255c:	2800      	cmp	r0, #0
 800255e:	f000 80b1 	beq.w	80026c4 <HAL_RCC_ClockConfig+0x168>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002562:	4a5e      	ldr	r2, [pc, #376]	; (80026dc <HAL_RCC_ClockConfig+0x180>)
{
 8002564:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002568:	6813      	ldr	r3, [r2, #0]
 800256a:	4604      	mov	r4, r0
 800256c:	f003 0307 	and.w	r3, r3, #7
 8002570:	428b      	cmp	r3, r1
 8002572:	460d      	mov	r5, r1
{
 8002574:	b086      	sub	sp, #24
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002576:	d20d      	bcs.n	8002594 <HAL_RCC_ClockConfig+0x38>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002578:	6813      	ldr	r3, [r2, #0]
 800257a:	f023 0307 	bic.w	r3, r3, #7
 800257e:	430b      	orrs	r3, r1
 8002580:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002582:	6813      	ldr	r3, [r2, #0]
 8002584:	f003 0307 	and.w	r3, r3, #7
 8002588:	428b      	cmp	r3, r1
 800258a:	d003      	beq.n	8002594 <HAL_RCC_ClockConfig+0x38>
    return HAL_ERROR;
 800258c:	2001      	movs	r0, #1
}
 800258e:	b006      	add	sp, #24
 8002590:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002594:	6823      	ldr	r3, [r4, #0]
 8002596:	079e      	lsls	r6, r3, #30
 8002598:	d514      	bpl.n	80025c4 <HAL_RCC_ClockConfig+0x68>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800259a:	0758      	lsls	r0, r3, #29
 800259c:	d504      	bpl.n	80025a8 <HAL_RCC_ClockConfig+0x4c>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800259e:	4950      	ldr	r1, [pc, #320]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
 80025a0:	684a      	ldr	r2, [r1, #4]
 80025a2:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 80025a6:	604a      	str	r2, [r1, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80025a8:	0719      	lsls	r1, r3, #28
 80025aa:	d504      	bpl.n	80025b6 <HAL_RCC_ClockConfig+0x5a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80025ac:	494c      	ldr	r1, [pc, #304]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
 80025ae:	684a      	ldr	r2, [r1, #4]
 80025b0:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 80025b4:	604a      	str	r2, [r1, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80025b6:	494a      	ldr	r1, [pc, #296]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
 80025b8:	68a0      	ldr	r0, [r4, #8]
 80025ba:	684a      	ldr	r2, [r1, #4]
 80025bc:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80025c0:	4302      	orrs	r2, r0
 80025c2:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80025c4:	07da      	lsls	r2, r3, #31
 80025c6:	d520      	bpl.n	800260a <HAL_RCC_ClockConfig+0xae>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80025c8:	6862      	ldr	r2, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80025ca:	4b45      	ldr	r3, [pc, #276]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80025cc:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80025ce:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80025d0:	d07a      	beq.n	80026c8 <HAL_RCC_ClockConfig+0x16c>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80025d2:	2a02      	cmp	r2, #2
 80025d4:	d073      	beq.n	80026be <HAL_RCC_ClockConfig+0x162>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80025d6:	079e      	lsls	r6, r3, #30
 80025d8:	d5d8      	bpl.n	800258c <HAL_RCC_ClockConfig+0x30>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80025da:	4e41      	ldr	r6, [pc, #260]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80025dc:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80025e0:	6873      	ldr	r3, [r6, #4]
 80025e2:	f023 0303 	bic.w	r3, r3, #3
 80025e6:	4313      	orrs	r3, r2
 80025e8:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 80025ea:	f7fe fa13 	bl	8000a14 <HAL_GetTick>
 80025ee:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80025f0:	e004      	b.n	80025fc <HAL_RCC_ClockConfig+0xa0>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80025f2:	f7fe fa0f 	bl	8000a14 <HAL_GetTick>
 80025f6:	1bc0      	subs	r0, r0, r7
 80025f8:	4540      	cmp	r0, r8
 80025fa:	d868      	bhi.n	80026ce <HAL_RCC_ClockConfig+0x172>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80025fc:	6873      	ldr	r3, [r6, #4]
 80025fe:	6862      	ldr	r2, [r4, #4]
 8002600:	f003 030c 	and.w	r3, r3, #12
 8002604:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8002608:	d1f3      	bne.n	80025f2 <HAL_RCC_ClockConfig+0x96>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800260a:	4a34      	ldr	r2, [pc, #208]	; (80026dc <HAL_RCC_ClockConfig+0x180>)
 800260c:	6813      	ldr	r3, [r2, #0]
 800260e:	f003 0307 	and.w	r3, r3, #7
 8002612:	42ab      	cmp	r3, r5
 8002614:	d909      	bls.n	800262a <HAL_RCC_ClockConfig+0xce>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002616:	6813      	ldr	r3, [r2, #0]
 8002618:	f023 0307 	bic.w	r3, r3, #7
 800261c:	432b      	orrs	r3, r5
 800261e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002620:	6813      	ldr	r3, [r2, #0]
 8002622:	f003 0307 	and.w	r3, r3, #7
 8002626:	42ab      	cmp	r3, r5
 8002628:	d1b0      	bne.n	800258c <HAL_RCC_ClockConfig+0x30>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800262a:	6823      	ldr	r3, [r4, #0]
 800262c:	0758      	lsls	r0, r3, #29
 800262e:	d506      	bpl.n	800263e <HAL_RCC_ClockConfig+0xe2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002630:	492b      	ldr	r1, [pc, #172]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
 8002632:	68e0      	ldr	r0, [r4, #12]
 8002634:	684a      	ldr	r2, [r1, #4]
 8002636:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800263a:	4302      	orrs	r2, r0
 800263c:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800263e:	0719      	lsls	r1, r3, #28
 8002640:	d507      	bpl.n	8002652 <HAL_RCC_ClockConfig+0xf6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002642:	4a27      	ldr	r2, [pc, #156]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
 8002644:	6921      	ldr	r1, [r4, #16]
 8002646:	6853      	ldr	r3, [r2, #4]
 8002648:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 800264c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002650:	6053      	str	r3, [r2, #4]
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8002652:	f240 2401 	movw	r4, #513	; 0x201
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8002656:	4b23      	ldr	r3, [pc, #140]	; (80026e4 <HAL_RCC_ClockConfig+0x188>)
 8002658:	ad06      	add	r5, sp, #24
 800265a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800265c:	e905 000f 	stmdb	r5, {r0, r1, r2, r3}
  tmpreg = RCC->CFGR;
 8002660:	491f      	ldr	r1, [pc, #124]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8002662:	f8ad 4004 	strh.w	r4, [sp, #4]
  tmpreg = RCC->CFGR;
 8002666:	684a      	ldr	r2, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8002668:	f002 030c 	and.w	r3, r2, #12
 800266c:	2b08      	cmp	r3, #8
 800266e:	d011      	beq.n	8002694 <HAL_RCC_ClockConfig+0x138>
      sysclockfreq = HSE_VALUE;
 8002670:	4b1d      	ldr	r3, [pc, #116]	; (80026e8 <HAL_RCC_ClockConfig+0x18c>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002672:	4a1b      	ldr	r2, [pc, #108]	; (80026e0 <HAL_RCC_ClockConfig+0x184>)
 8002674:	481d      	ldr	r0, [pc, #116]	; (80026ec <HAL_RCC_ClockConfig+0x190>)
 8002676:	6852      	ldr	r2, [r2, #4]
  HAL_InitTick(uwTickPrio);
 8002678:	491d      	ldr	r1, [pc, #116]	; (80026f0 <HAL_RCC_ClockConfig+0x194>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800267a:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800267e:	5c80      	ldrb	r0, [r0, r2]
 8002680:	4a1c      	ldr	r2, [pc, #112]	; (80026f4 <HAL_RCC_ClockConfig+0x198>)
 8002682:	40c3      	lsrs	r3, r0
  HAL_InitTick(uwTickPrio);
 8002684:	6808      	ldr	r0, [r1, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002686:	6013      	str	r3, [r2, #0]
  HAL_InitTick(uwTickPrio);
 8002688:	f7fe f982 	bl	8000990 <HAL_InitTick>
  return HAL_OK;
 800268c:	2000      	movs	r0, #0
}
 800268e:	b006      	add	sp, #24
 8002690:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8002694:	f3c2 4383 	ubfx	r3, r2, #18, #4
 8002698:	3318      	adds	r3, #24
 800269a:	446b      	add	r3, sp
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 800269c:	03d2      	lsls	r2, r2, #15
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 800269e:	f813 3c10 	ldrb.w	r3, [r3, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 80026a2:	d516      	bpl.n	80026d2 <HAL_RCC_ClockConfig+0x176>
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 80026a4:	684a      	ldr	r2, [r1, #4]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 80026a6:	4910      	ldr	r1, [pc, #64]	; (80026e8 <HAL_RCC_ClockConfig+0x18c>)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 80026a8:	f3c2 4240 	ubfx	r2, r2, #17, #1
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 80026ac:	fb01 f303 	mul.w	r3, r1, r3
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 80026b0:	3218      	adds	r2, #24
 80026b2:	446a      	add	r2, sp
 80026b4:	f812 2c14 	ldrb.w	r2, [r2, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 80026b8:	fbb3 f3f2 	udiv	r3, r3, r2
 80026bc:	e7d9      	b.n	8002672 <HAL_RCC_ClockConfig+0x116>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80026be:	019f      	lsls	r7, r3, #6
 80026c0:	d48b      	bmi.n	80025da <HAL_RCC_ClockConfig+0x7e>
 80026c2:	e763      	b.n	800258c <HAL_RCC_ClockConfig+0x30>
    return HAL_ERROR;
 80026c4:	2001      	movs	r0, #1
}
 80026c6:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80026c8:	039b      	lsls	r3, r3, #14
 80026ca:	d486      	bmi.n	80025da <HAL_RCC_ClockConfig+0x7e>
 80026cc:	e75e      	b.n	800258c <HAL_RCC_ClockConfig+0x30>
        return HAL_TIMEOUT;
 80026ce:	2003      	movs	r0, #3
 80026d0:	e75d      	b.n	800258e <HAL_RCC_ClockConfig+0x32>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 80026d2:	4a09      	ldr	r2, [pc, #36]	; (80026f8 <HAL_RCC_ClockConfig+0x19c>)
 80026d4:	fb02 f303 	mul.w	r3, r2, r3
 80026d8:	e7cb      	b.n	8002672 <HAL_RCC_ClockConfig+0x116>
 80026da:	bf00      	nop
 80026dc:	40022000 	.word	0x40022000
 80026e0:	40021000 	.word	0x40021000
 80026e4:	080068b8 	.word	0x080068b8
 80026e8:	007a1200 	.word	0x007a1200
 80026ec:	080068a0 	.word	0x080068a0
 80026f0:	20000008 	.word	0x20000008
 80026f4:	20000000 	.word	0x20000000
 80026f8:	003d0900 	.word	0x003d0900

080026fc <HAL_RCC_MCOConfig>:
{
 80026fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef gpio = {0U};
 80026fe:	2200      	movs	r2, #0
  gpio.Pin       = MCO1_PIN;
 8002700:	f44f 7680 	mov.w	r6, #256	; 0x100
 8002704:	2702      	movs	r7, #2
  gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
 8002706:	2303      	movs	r3, #3
{
 8002708:	b087      	sub	sp, #28
  gpio.Pin       = MCO1_PIN;
 800270a:	e9cd 6702 	strd	r6, r7, [sp, #8]
  gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
 800270e:	e9cd 2304 	strd	r2, r3, [sp, #16]
  MCO1_CLK_ENABLE();
 8002712:	4c0b      	ldr	r4, [pc, #44]	; (8002740 <HAL_RCC_MCOConfig+0x44>)
{
 8002714:	460d      	mov	r5, r1
  MCO1_CLK_ENABLE();
 8002716:	69a3      	ldr	r3, [r4, #24]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
 8002718:	480a      	ldr	r0, [pc, #40]	; (8002744 <HAL_RCC_MCOConfig+0x48>)
  MCO1_CLK_ENABLE();
 800271a:	f043 0304 	orr.w	r3, r3, #4
 800271e:	61a3      	str	r3, [r4, #24]
 8002720:	69a3      	ldr	r3, [r4, #24]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
 8002722:	a902      	add	r1, sp, #8
  MCO1_CLK_ENABLE();
 8002724:	f003 0304 	and.w	r3, r3, #4
 8002728:	9301      	str	r3, [sp, #4]
 800272a:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
 800272c:	f7fe fc7c 	bl	8001028 <HAL_GPIO_Init>
  __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
 8002730:	6863      	ldr	r3, [r4, #4]
 8002732:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8002736:	432b      	orrs	r3, r5
 8002738:	6063      	str	r3, [r4, #4]
}
 800273a:	b007      	add	sp, #28
 800273c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800273e:	bf00      	nop
 8002740:	40021000 	.word	0x40021000
 8002744:	40010800 	.word	0x40010800

08002748 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8002748:	4b04      	ldr	r3, [pc, #16]	; (800275c <HAL_RCC_GetPCLK1Freq+0x14>)
  return SystemCoreClock;
 800274a:	4a05      	ldr	r2, [pc, #20]	; (8002760 <HAL_RCC_GetPCLK1Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800274c:	685b      	ldr	r3, [r3, #4]
 800274e:	4905      	ldr	r1, [pc, #20]	; (8002764 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8002750:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8002754:	5ccb      	ldrb	r3, [r1, r3]
 8002756:	6810      	ldr	r0, [r2, #0]
}
 8002758:	40d8      	lsrs	r0, r3
 800275a:	4770      	bx	lr
 800275c:	40021000 	.word	0x40021000
 8002760:	20000000 	.word	0x20000000
 8002764:	080068b0 	.word	0x080068b0

08002768 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002768:	4b04      	ldr	r3, [pc, #16]	; (800277c <HAL_RCC_GetPCLK2Freq+0x14>)
  return SystemCoreClock;
 800276a:	4a05      	ldr	r2, [pc, #20]	; (8002780 <HAL_RCC_GetPCLK2Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800276c:	685b      	ldr	r3, [r3, #4]
 800276e:	4905      	ldr	r1, [pc, #20]	; (8002784 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002770:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8002774:	5ccb      	ldrb	r3, [r1, r3]
 8002776:	6810      	ldr	r0, [r2, #0]
}
 8002778:	40d8      	lsrs	r0, r3
 800277a:	4770      	bx	lr
 800277c:	40021000 	.word	0x40021000
 8002780:	20000000 	.word	0x20000000
 8002784:	080068b0 	.word	0x080068b0

08002788 <HAL_RCCEx_PeriphCLKConfig>:
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002788:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800278c:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 800278e:	6800      	ldr	r0, [r0, #0]
{
 8002790:	b082      	sub	sp, #8
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8002792:	07c1      	lsls	r1, r0, #31
 8002794:	d52c      	bpl.n	80027f0 <HAL_RCCEx_PeriphCLKConfig+0x68>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002796:	4b3a      	ldr	r3, [pc, #232]	; (8002880 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 8002798:	69da      	ldr	r2, [r3, #28]
 800279a:	00d2      	lsls	r2, r2, #3
 800279c:	d53f      	bpl.n	800281e <HAL_RCCEx_PeriphCLKConfig+0x96>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800279e:	4d39      	ldr	r5, [pc, #228]	; (8002884 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
    FlagStatus pwrclkchanged = RESET;
 80027a0:	2600      	movs	r6, #0
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80027a2:	682b      	ldr	r3, [r5, #0]
 80027a4:	05df      	lsls	r7, r3, #23
 80027a6:	d548      	bpl.n	800283a <HAL_RCCEx_PeriphCLKConfig+0xb2>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 80027a8:	4d35      	ldr	r5, [pc, #212]	; (8002880 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 80027aa:	6a2b      	ldr	r3, [r5, #32]
    if ((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80027ac:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80027b0:	d011      	beq.n	80027d6 <HAL_RCCEx_PeriphCLKConfig+0x4e>
 80027b2:	6861      	ldr	r1, [r4, #4]
 80027b4:	f401 7240 	and.w	r2, r1, #768	; 0x300
 80027b8:	429a      	cmp	r2, r3
 80027ba:	d00d      	beq.n	80027d8 <HAL_RCCEx_PeriphCLKConfig+0x50>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 80027bc:	2701      	movs	r7, #1
      __HAL_RCC_BACKUPRESET_RELEASE();
 80027be:	2000      	movs	r0, #0
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80027c0:	6a2b      	ldr	r3, [r5, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 80027c2:	4a31      	ldr	r2, [pc, #196]	; (8002888 <HAL_RCCEx_PeriphCLKConfig+0x100>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80027c4:	f423 7140 	bic.w	r1, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 80027c8:	f8c2 7440 	str.w	r7, [r2, #1088]	; 0x440
      __HAL_RCC_BACKUPRESET_RELEASE();
 80027cc:	f8c2 0440 	str.w	r0, [r2, #1088]	; 0x440
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 80027d0:	6229      	str	r1, [r5, #32]

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 80027d2:	07d9      	lsls	r1, r3, #31
 80027d4:	d444      	bmi.n	8002860 <HAL_RCCEx_PeriphCLKConfig+0xd8>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80027d6:	6861      	ldr	r1, [r4, #4]
 80027d8:	4a29      	ldr	r2, [pc, #164]	; (8002880 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 80027da:	6a13      	ldr	r3, [r2, #32]
 80027dc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80027e0:	430b      	orrs	r3, r1
 80027e2:	6213      	str	r3, [r2, #32]

    /* Require to disable power clock if necessary */
    if (pwrclkchanged == SET)
 80027e4:	b11e      	cbz	r6, 80027ee <HAL_RCCEx_PeriphCLKConfig+0x66>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80027e6:	69d3      	ldr	r3, [r2, #28]
 80027e8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80027ec:	61d3      	str	r3, [r2, #28]
    }
  }

  /*------------------------------ ADC clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80027ee:	6820      	ldr	r0, [r4, #0]
 80027f0:	0783      	lsls	r3, r0, #30
 80027f2:	d506      	bpl.n	8002802 <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80027f4:	4922      	ldr	r1, [pc, #136]	; (8002880 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 80027f6:	68a3      	ldr	r3, [r4, #8]
 80027f8:	684a      	ldr	r2, [r1, #4]
 80027fa:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 80027fe:	431a      	orrs	r2, r3
 8002800:	604a      	str	r2, [r1, #4]

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /*------------------------------ USB clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8002802:	f010 0010 	ands.w	r0, r0, #16
 8002806:	d007      	beq.n	8002818 <HAL_RCCEx_PeriphCLKConfig+0x90>
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
 8002808:	2000      	movs	r0, #0
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800280a:	4a1d      	ldr	r2, [pc, #116]	; (8002880 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 800280c:	68e1      	ldr	r1, [r4, #12]
 800280e:	6853      	ldr	r3, [r2, #4]
 8002810:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8002814:	430b      	orrs	r3, r1
 8002816:	6053      	str	r3, [r2, #4]
}
 8002818:	b002      	add	sp, #8
 800281a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 800281e:	69da      	ldr	r2, [r3, #28]
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002820:	4d18      	ldr	r5, [pc, #96]	; (8002884 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
      __HAL_RCC_PWR_CLK_ENABLE();
 8002822:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002826:	61da      	str	r2, [r3, #28]
 8002828:	69db      	ldr	r3, [r3, #28]
      pwrclkchanged = SET;
 800282a:	2601      	movs	r6, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 800282c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002830:	9301      	str	r3, [sp, #4]
 8002832:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002834:	682b      	ldr	r3, [r5, #0]
 8002836:	05df      	lsls	r7, r3, #23
 8002838:	d4b6      	bmi.n	80027a8 <HAL_RCCEx_PeriphCLKConfig+0x20>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800283a:	682b      	ldr	r3, [r5, #0]
 800283c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002840:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8002842:	f7fe f8e7 	bl	8000a14 <HAL_GetTick>
 8002846:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002848:	682b      	ldr	r3, [r5, #0]
 800284a:	05d8      	lsls	r0, r3, #23
 800284c:	d4ac      	bmi.n	80027a8 <HAL_RCCEx_PeriphCLKConfig+0x20>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800284e:	f7fe f8e1 	bl	8000a14 <HAL_GetTick>
 8002852:	1bc3      	subs	r3, r0, r7
 8002854:	2b64      	cmp	r3, #100	; 0x64
 8002856:	d9f7      	bls.n	8002848 <HAL_RCCEx_PeriphCLKConfig+0xc0>
          return HAL_TIMEOUT;
 8002858:	2003      	movs	r0, #3
}
 800285a:	b002      	add	sp, #8
 800285c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        tickstart = HAL_GetTick();
 8002860:	f7fe f8d8 	bl	8000a14 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002864:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8002868:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800286a:	e004      	b.n	8002876 <HAL_RCCEx_PeriphCLKConfig+0xee>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800286c:	f7fe f8d2 	bl	8000a14 <HAL_GetTick>
 8002870:	1bc0      	subs	r0, r0, r7
 8002872:	4540      	cmp	r0, r8
 8002874:	d8f0      	bhi.n	8002858 <HAL_RCCEx_PeriphCLKConfig+0xd0>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002876:	6a2b      	ldr	r3, [r5, #32]
 8002878:	079a      	lsls	r2, r3, #30
 800287a:	d5f7      	bpl.n	800286c <HAL_RCCEx_PeriphCLKConfig+0xe4>
 800287c:	e7ab      	b.n	80027d6 <HAL_RCCEx_PeriphCLKConfig+0x4e>
 800287e:	bf00      	nop
 8002880:	40021000 	.word	0x40021000
 8002884:	40007000 	.word	0x40007000
 8002888:	42420000 	.word	0x42420000

0800288c <SPI_WaitFlagStateUntilTimeout.constprop.1>:
  * @param  State flag state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 800288c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002890:	461d      	mov	r5, r3
 8002892:	4616      	mov	r6, r2
 8002894:	b082      	sub	sp, #8
 8002896:	460c      	mov	r4, r1
 8002898:	4607      	mov	r7, r0
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 800289a:	f7fe f8bb 	bl	8000a14 <HAL_GetTick>
 800289e:	4435      	add	r5, r6
 80028a0:	1a2d      	subs	r5, r5, r0
  tmp_tickstart = HAL_GetTick();
 80028a2:	f7fe f8b7 	bl	8000a14 <HAL_GetTick>
 80028a6:	4680      	mov	r8, r0

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 80028a8:	4b26      	ldr	r3, [pc, #152]	; (8002944 <SPI_WaitFlagStateUntilTimeout.constprop.1+0xb8>)
 80028aa:	681b      	ldr	r3, [r3, #0]
 80028ac:	f3c3 33cb 	ubfx	r3, r3, #15, #12
 80028b0:	fb05 f303 	mul.w	r3, r5, r3
 80028b4:	9301      	str	r3, [sp, #4]
 80028b6:	1c73      	adds	r3, r6, #1

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80028b8:	6839      	ldr	r1, [r7, #0]
 80028ba:	d107      	bne.n	80028cc <SPI_WaitFlagStateUntilTimeout.constprop.1+0x40>
 80028bc:	688b      	ldr	r3, [r1, #8]
 80028be:	ea34 0303 	bics.w	r3, r4, r3
 80028c2:	d0fb      	beq.n	80028bc <SPI_WaitFlagStateUntilTimeout.constprop.1+0x30>
      }
      count--;
    }
  }

  return HAL_OK;
 80028c4:	2000      	movs	r0, #0
}
 80028c6:	b002      	add	sp, #8
 80028c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80028cc:	688b      	ldr	r3, [r1, #8]
 80028ce:	ea34 0303 	bics.w	r3, r4, r3
 80028d2:	d1f7      	bne.n	80028c4 <SPI_WaitFlagStateUntilTimeout.constprop.1+0x38>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 80028d4:	f7fe f89e 	bl	8000a14 <HAL_GetTick>
 80028d8:	eba0 0308 	sub.w	r3, r0, r8
 80028dc:	42ab      	cmp	r3, r5
 80028de:	d207      	bcs.n	80028f0 <SPI_WaitFlagStateUntilTimeout.constprop.1+0x64>
      if(count == 0U)
 80028e0:	9b01      	ldr	r3, [sp, #4]
        tmp_timeout = 0U;
 80028e2:	2b00      	cmp	r3, #0
      count--;
 80028e4:	9b01      	ldr	r3, [sp, #4]
        tmp_timeout = 0U;
 80028e6:	bf08      	it	eq
 80028e8:	2500      	moveq	r5, #0
      count--;
 80028ea:	3b01      	subs	r3, #1
 80028ec:	9301      	str	r3, [sp, #4]
 80028ee:	e7e2      	b.n	80028b6 <SPI_WaitFlagStateUntilTimeout.constprop.1+0x2a>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80028f0:	e9d7 3100 	ldrd	r3, r1, [r7]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80028f4:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80028f6:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80028fa:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80028fe:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002900:	d014      	beq.n	800292c <SPI_WaitFlagStateUntilTimeout.constprop.1+0xa0>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002902:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002904:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002908:	d007      	beq.n	800291a <SPI_WaitFlagStateUntilTimeout.constprop.1+0x8e>
        hspi->State = HAL_SPI_STATE_READY;
 800290a:	2201      	movs	r2, #1
        __HAL_UNLOCK(hspi);
 800290c:	2300      	movs	r3, #0
 800290e:	2003      	movs	r0, #3
        hspi->State = HAL_SPI_STATE_READY;
 8002910:	f887 2051 	strb.w	r2, [r7, #81]	; 0x51
        __HAL_UNLOCK(hspi);
 8002914:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
        return HAL_TIMEOUT;
 8002918:	e7d5      	b.n	80028c6 <SPI_WaitFlagStateUntilTimeout.constprop.1+0x3a>
          SPI_RESET_CRC(hspi);
 800291a:	681a      	ldr	r2, [r3, #0]
 800291c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002920:	601a      	str	r2, [r3, #0]
 8002922:	681a      	ldr	r2, [r3, #0]
 8002924:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002928:	601a      	str	r2, [r3, #0]
 800292a:	e7ee      	b.n	800290a <SPI_WaitFlagStateUntilTimeout.constprop.1+0x7e>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800292c:	68ba      	ldr	r2, [r7, #8]
 800292e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8002932:	d002      	beq.n	800293a <SPI_WaitFlagStateUntilTimeout.constprop.1+0xae>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002934:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8002938:	d1e3      	bne.n	8002902 <SPI_WaitFlagStateUntilTimeout.constprop.1+0x76>
          __HAL_SPI_DISABLE(hspi);
 800293a:	681a      	ldr	r2, [r3, #0]
 800293c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002940:	601a      	str	r2, [r3, #0]
 8002942:	e7de      	b.n	8002902 <SPI_WaitFlagStateUntilTimeout.constprop.1+0x76>
 8002944:	20000000 	.word	0x20000000

08002948 <HAL_SPI_Init>:
  if (hspi == NULL)
 8002948:	2800      	cmp	r0, #0
 800294a:	d058      	beq.n	80029fe <HAL_SPI_Init+0xb6>
{
 800294c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800294e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002950:	4604      	mov	r4, r0
 8002952:	2b00      	cmp	r3, #0
 8002954:	d044      	beq.n	80029e0 <HAL_SPI_Init+0x98>
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8002956:	2300      	movs	r3, #0
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8002958:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800295c:	2300      	movs	r3, #0
  if (hspi->State == HAL_SPI_STATE_RESET)
 800295e:	f894 2051 	ldrb.w	r2, [r4, #81]	; 0x51
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002962:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002964:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 8002968:	2a00      	cmp	r2, #0
 800296a:	d03f      	beq.n	80029ec <HAL_SPI_Init+0xa4>
 800296c:	469c      	mov	ip, r3
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800296e:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
  hspi->State = HAL_SPI_STATE_BUSY;
 8002972:	2602      	movs	r6, #2
  hspi->State     = HAL_SPI_STATE_READY;
 8002974:	f04f 0e01 	mov.w	lr, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002978:	2500      	movs	r5, #0
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800297a:	f402 4204 	and.w	r2, r2, #33792	; 0x8400
 800297e:	f403 7382 	and.w	r3, r3, #260	; 0x104
 8002982:	4313      	orrs	r3, r2
 8002984:	68e2      	ldr	r2, [r4, #12]
 8002986:	69a0      	ldr	r0, [r4, #24]
 8002988:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 800298c:	4313      	orrs	r3, r2
 800298e:	6922      	ldr	r2, [r4, #16]
  hspi->State = HAL_SPI_STATE_BUSY;
 8002990:	f884 6051 	strb.w	r6, [r4, #81]	; 0x51
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8002994:	4032      	ands	r2, r6
 8002996:	4313      	orrs	r3, r2
 8002998:	6962      	ldr	r2, [r4, #20]
  __HAL_SPI_DISABLE(hspi);
 800299a:	6821      	ldr	r1, [r4, #0]
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800299c:	ea02 020e 	and.w	r2, r2, lr
 80029a0:	431a      	orrs	r2, r3
 80029a2:	69e3      	ldr	r3, [r4, #28]
 80029a4:	6a26      	ldr	r6, [r4, #32]
 80029a6:	f003 0738 	and.w	r7, r3, #56	; 0x38
 80029aa:	f400 7300 	and.w	r3, r0, #512	; 0x200
 80029ae:	4313      	orrs	r3, r2
 80029b0:	f006 0680 	and.w	r6, r6, #128	; 0x80
  __HAL_SPI_DISABLE(hspi);
 80029b4:	680a      	ldr	r2, [r1, #0]
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80029b6:	433b      	orrs	r3, r7
 80029b8:	4333      	orrs	r3, r6
  WRITE_REG(hspi->Instance->CR2, ((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE));
 80029ba:	0c00      	lsrs	r0, r0, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80029bc:	ea43 030c 	orr.w	r3, r3, ip
  WRITE_REG(hspi->Instance->CR2, ((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE));
 80029c0:	f000 0004 	and.w	r0, r0, #4
  __HAL_SPI_DISABLE(hspi);
 80029c4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80029c8:	600a      	str	r2, [r1, #0]
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80029ca:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, ((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE));
 80029cc:	6048      	str	r0, [r1, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80029ce:	69cb      	ldr	r3, [r1, #28]
  return HAL_OK;
 80029d0:	4628      	mov	r0, r5
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80029d2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80029d6:	61cb      	str	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80029d8:	6565      	str	r5, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80029da:	f884 e051 	strb.w	lr, [r4, #81]	; 0x51
}
 80029de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80029e0:	6842      	ldr	r2, [r0, #4]
 80029e2:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80029e6:	d0b9      	beq.n	800295c <HAL_SPI_Init+0x14>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80029e8:	61c3      	str	r3, [r0, #28]
 80029ea:	e7b7      	b.n	800295c <HAL_SPI_Init+0x14>
    HAL_SPI_MspInit(hspi);
 80029ec:	4620      	mov	r0, r4
    hspi->Lock = HAL_UNLOCKED;
 80029ee:	f884 1050 	strb.w	r1, [r4, #80]	; 0x50
    HAL_SPI_MspInit(hspi);
 80029f2:	f7fd fea9 	bl	8000748 <HAL_SPI_MspInit>
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80029f6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80029f8:	f403 5c00 	and.w	ip, r3, #8192	; 0x2000
 80029fc:	e7b7      	b.n	800296e <HAL_SPI_Init+0x26>
    return HAL_ERROR;
 80029fe:	2001      	movs	r0, #1
}
 8002a00:	4770      	bx	lr
 8002a02:	bf00      	nop

08002a04 <HAL_SPI_Transmit>:
{
 8002a04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a08:	461d      	mov	r5, r3
  __HAL_LOCK(hspi);
 8002a0a:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
{
 8002a0e:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8002a10:	2b01      	cmp	r3, #1
 8002a12:	d074      	beq.n	8002afe <HAL_SPI_Transmit+0xfa>
 8002a14:	2301      	movs	r3, #1
 8002a16:	4604      	mov	r4, r0
 8002a18:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
 8002a1c:	4688      	mov	r8, r1
 8002a1e:	4617      	mov	r7, r2
  tickstart = HAL_GetTick();
 8002a20:	f7fd fff8 	bl	8000a14 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8002a24:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
  tickstart = HAL_GetTick();
 8002a28:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8002a2a:	2b01      	cmp	r3, #1
 8002a2c:	b2d8      	uxtb	r0, r3
 8002a2e:	d009      	beq.n	8002a44 <HAL_SPI_Transmit+0x40>
    errorcode = HAL_BUSY;
 8002a30:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002a32:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8002a34:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8002a36:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8002a3a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 8002a3e:	b002      	add	sp, #8
 8002a40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8002a44:	f1b8 0f00 	cmp.w	r8, #0
 8002a48:	d0f3      	beq.n	8002a32 <HAL_SPI_Transmit+0x2e>
 8002a4a:	2f00      	cmp	r7, #0
 8002a4c:	d0f1      	beq.n	8002a32 <HAL_SPI_Transmit+0x2e>
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002a4e:	2300      	movs	r3, #0
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002a50:	2203      	movs	r2, #3
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002a52:	63a3      	str	r3, [r4, #56]	; 0x38
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002a54:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
  hspi->RxXferSize  = 0U;
 8002a58:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002a5a:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->TxISR       = NULL;
 8002a5c:	6463      	str	r3, [r4, #68]	; 0x44
  hspi->TxXferCount = Size;
 8002a5e:	86e7      	strh	r7, [r4, #54]	; 0x36
  hspi->RxISR       = NULL;
 8002a60:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->RxXferCount = 0U;
 8002a62:	87e3      	strh	r3, [r4, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a64:	68a3      	ldr	r3, [r4, #8]
    __HAL_SPI_DISABLE(hspi);
 8002a66:	6820      	ldr	r0, [r4, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a68:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    __HAL_SPI_DISABLE(hspi);
 8002a6c:	4602      	mov	r2, r0
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002a6e:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
  hspi->TxXferSize  = Size;
 8002a72:	86a7      	strh	r7, [r4, #52]	; 0x34
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a74:	d076      	beq.n	8002b64 <HAL_SPI_Transmit+0x160>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002a76:	6803      	ldr	r3, [r0, #0]
 8002a78:	065b      	lsls	r3, r3, #25
 8002a7a:	d403      	bmi.n	8002a84 <HAL_SPI_Transmit+0x80>
    __HAL_SPI_ENABLE(hspi);
 8002a7c:	6803      	ldr	r3, [r0, #0]
 8002a7e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002a82:	6003      	str	r3, [r0, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8002a84:	68e3      	ldr	r3, [r4, #12]
 8002a86:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002a8a:	6863      	ldr	r3, [r4, #4]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8002a8c:	d03b      	beq.n	8002b06 <HAL_SPI_Transmit+0x102>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	f000 808a 	beq.w	8002ba8 <HAL_SPI_Transmit+0x1a4>
 8002a94:	2f01      	cmp	r7, #1
 8002a96:	f000 8087 	beq.w	8002ba8 <HAL_SPI_Transmit+0x1a4>
    while (hspi->TxXferCount > 0U)
 8002a9a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002a9c:	b29b      	uxth	r3, r3
 8002a9e:	b1bb      	cbz	r3, 8002ad0 <HAL_SPI_Transmit+0xcc>
 8002aa0:	2d00      	cmp	r5, #0
 8002aa2:	f000 80be 	beq.w	8002c22 <HAL_SPI_Transmit+0x21e>
 8002aa6:	1c6f      	adds	r7, r5, #1
 8002aa8:	d173      	bne.n	8002b92 <HAL_SPI_Transmit+0x18e>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002aaa:	6823      	ldr	r3, [r4, #0]
 8002aac:	689a      	ldr	r2, [r3, #8]
 8002aae:	0790      	lsls	r0, r2, #30
 8002ab0:	f140 8085 	bpl.w	8002bbe <HAL_SPI_Transmit+0x1ba>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002ab4:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002ab6:	7812      	ldrb	r2, [r2, #0]
 8002ab8:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8002aba:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002abc:	6b23      	ldr	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002abe:	3901      	subs	r1, #1
 8002ac0:	b289      	uxth	r1, r1
 8002ac2:	86e1      	strh	r1, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 8002ac4:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002ac6:	3301      	adds	r3, #1
    while (hspi->TxXferCount > 0U)
 8002ac8:	b289      	uxth	r1, r1
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002aca:	6323      	str	r3, [r4, #48]	; 0x30
    while (hspi->TxXferCount > 0U)
 8002acc:	2900      	cmp	r1, #0
 8002ace:	d1ec      	bne.n	8002aaa <HAL_SPI_Transmit+0xa6>
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002ad0:	4633      	mov	r3, r6
 8002ad2:	462a      	mov	r2, r5
 8002ad4:	2180      	movs	r1, #128	; 0x80
 8002ad6:	4620      	mov	r0, r4
 8002ad8:	f7ff fed8 	bl	800288c <SPI_WaitFlagStateUntilTimeout.constprop.1>
 8002adc:	2800      	cmp	r0, #0
 8002ade:	f040 80b9 	bne.w	8002c54 <HAL_SPI_Transmit+0x250>
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002ae2:	68a3      	ldr	r3, [r4, #8]
 8002ae4:	b933      	cbnz	r3, 8002af4 <HAL_SPI_Transmit+0xf0>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002ae6:	6822      	ldr	r2, [r4, #0]
 8002ae8:	9301      	str	r3, [sp, #4]
 8002aea:	68d3      	ldr	r3, [r2, #12]
 8002aec:	9301      	str	r3, [sp, #4]
 8002aee:	6893      	ldr	r3, [r2, #8]
 8002af0:	9301      	str	r3, [sp, #4]
 8002af2:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002af4:	6d60      	ldr	r0, [r4, #84]	; 0x54
    errorcode = HAL_BUSY;
 8002af6:	3800      	subs	r0, #0
 8002af8:	bf18      	it	ne
 8002afa:	2001      	movne	r0, #1
error:
 8002afc:	e799      	b.n	8002a32 <HAL_SPI_Transmit+0x2e>
  __HAL_LOCK(hspi);
 8002afe:	2002      	movs	r0, #2
}
 8002b00:	b002      	add	sp, #8
 8002b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002b06:	2b00      	cmp	r3, #0
 8002b08:	d179      	bne.n	8002bfe <HAL_SPI_Transmit+0x1fa>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002b0a:	4641      	mov	r1, r8
 8002b0c:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002b10:	60c3      	str	r3, [r0, #12]
      hspi->TxXferCount--;
 8002b12:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002b14:	6321      	str	r1, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002b16:	3b01      	subs	r3, #1
 8002b18:	b29b      	uxth	r3, r3
 8002b1a:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 8002b1c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002b1e:	b29b      	uxth	r3, r3
 8002b20:	2b00      	cmp	r3, #0
 8002b22:	d0d5      	beq.n	8002ad0 <HAL_SPI_Transmit+0xcc>
 8002b24:	2d00      	cmp	r5, #0
 8002b26:	f000 8091 	beq.w	8002c4c <HAL_SPI_Transmit+0x248>
 8002b2a:	1c69      	adds	r1, r5, #1
 8002b2c:	d15e      	bne.n	8002bec <HAL_SPI_Transmit+0x1e8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002b2e:	6883      	ldr	r3, [r0, #8]
 8002b30:	079a      	lsls	r2, r3, #30
 8002b32:	d50f      	bpl.n	8002b54 <HAL_SPI_Transmit+0x150>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002b34:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002b36:	f832 3b02 	ldrh.w	r3, [r2], #2
 8002b3a:	60c3      	str	r3, [r0, #12]
        hspi->TxXferCount--;
 8002b3c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002b3e:	6322      	str	r2, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002b40:	3b01      	subs	r3, #1
 8002b42:	b29b      	uxth	r3, r3
 8002b44:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 8002b46:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002b48:	b29b      	uxth	r3, r3
 8002b4a:	2b00      	cmp	r3, #0
 8002b4c:	d0c0      	beq.n	8002ad0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002b4e:	6883      	ldr	r3, [r0, #8]
 8002b50:	079a      	lsls	r2, r3, #30
 8002b52:	d4ef      	bmi.n	8002b34 <HAL_SPI_Transmit+0x130>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002b54:	f7fd ff5e 	bl	8000a14 <HAL_GetTick>
    while (hspi->TxXferCount > 0U)
 8002b58:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002b5a:	b29b      	uxth	r3, r3
 8002b5c:	2b00      	cmp	r3, #0
 8002b5e:	d0b7      	beq.n	8002ad0 <HAL_SPI_Transmit+0xcc>
 8002b60:	6820      	ldr	r0, [r4, #0]
 8002b62:	e7e4      	b.n	8002b2e <HAL_SPI_Transmit+0x12a>
    __HAL_SPI_DISABLE(hspi);
 8002b64:	6803      	ldr	r3, [r0, #0]
 8002b66:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002b6a:	6003      	str	r3, [r0, #0]
    SPI_1LINE_TX(hspi);
 8002b6c:	6803      	ldr	r3, [r0, #0]
 8002b6e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002b72:	6003      	str	r3, [r0, #0]
 8002b74:	e77f      	b.n	8002a76 <HAL_SPI_Transmit+0x72>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002b76:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002b78:	7812      	ldrb	r2, [r2, #0]
 8002b7a:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8002b7c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002b7e:	6b22      	ldr	r2, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002b80:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002b82:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8002b84:	b29b      	uxth	r3, r3
 8002b86:	86e3      	strh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002b88:	6322      	str	r2, [r4, #48]	; 0x30
    while (hspi->TxXferCount > 0U)
 8002b8a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002b8c:	b29b      	uxth	r3, r3
 8002b8e:	2b00      	cmp	r3, #0
 8002b90:	d09e      	beq.n	8002ad0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002b92:	6823      	ldr	r3, [r4, #0]
 8002b94:	689a      	ldr	r2, [r3, #8]
 8002b96:	0791      	lsls	r1, r2, #30
 8002b98:	d4ed      	bmi.n	8002b76 <HAL_SPI_Transmit+0x172>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002b9a:	f7fd ff3b 	bl	8000a14 <HAL_GetTick>
 8002b9e:	1b83      	subs	r3, r0, r6
 8002ba0:	429d      	cmp	r5, r3
 8002ba2:	d8f2      	bhi.n	8002b8a <HAL_SPI_Transmit+0x186>
          errorcode = HAL_TIMEOUT;
 8002ba4:	2003      	movs	r0, #3
 8002ba6:	e744      	b.n	8002a32 <HAL_SPI_Transmit+0x2e>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002ba8:	f898 3000 	ldrb.w	r3, [r8]
 8002bac:	7303      	strb	r3, [r0, #12]
      hspi->TxXferCount--;
 8002bae:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002bb0:	6b22      	ldr	r2, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002bb2:	3b01      	subs	r3, #1
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002bb4:	3201      	adds	r2, #1
      hspi->TxXferCount--;
 8002bb6:	b29b      	uxth	r3, r3
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002bb8:	6322      	str	r2, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002bba:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002bbc:	e76d      	b.n	8002a9a <HAL_SPI_Transmit+0x96>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002bbe:	f7fd ff29 	bl	8000a14 <HAL_GetTick>
    while (hspi->TxXferCount > 0U)
 8002bc2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002bc4:	b29b      	uxth	r3, r3
 8002bc6:	2b00      	cmp	r3, #0
 8002bc8:	f47f af6f 	bne.w	8002aaa <HAL_SPI_Transmit+0xa6>
 8002bcc:	e780      	b.n	8002ad0 <HAL_SPI_Transmit+0xcc>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002bce:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002bd0:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002bd4:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8002bd6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002bd8:	6321      	str	r1, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002bda:	3b01      	subs	r3, #1
 8002bdc:	b29b      	uxth	r3, r3
 8002bde:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 8002be0:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002be2:	b29b      	uxth	r3, r3
 8002be4:	2b00      	cmp	r3, #0
 8002be6:	f43f af73 	beq.w	8002ad0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002bea:	6822      	ldr	r2, [r4, #0]
 8002bec:	6893      	ldr	r3, [r2, #8]
 8002bee:	079b      	lsls	r3, r3, #30
 8002bf0:	d4ed      	bmi.n	8002bce <HAL_SPI_Transmit+0x1ca>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002bf2:	f7fd ff0f 	bl	8000a14 <HAL_GetTick>
 8002bf6:	1b83      	subs	r3, r0, r6
 8002bf8:	429d      	cmp	r5, r3
 8002bfa:	d9d3      	bls.n	8002ba4 <HAL_SPI_Transmit+0x1a0>
 8002bfc:	e7f0      	b.n	8002be0 <HAL_SPI_Transmit+0x1dc>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002bfe:	2f01      	cmp	r7, #1
 8002c00:	d18c      	bne.n	8002b1c <HAL_SPI_Transmit+0x118>
 8002c02:	e782      	b.n	8002b0a <HAL_SPI_Transmit+0x106>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002c04:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002c06:	7812      	ldrb	r2, [r2, #0]
 8002c08:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8002c0a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002c0c:	6b22      	ldr	r2, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002c0e:	3b01      	subs	r3, #1
 8002c10:	b29b      	uxth	r3, r3
 8002c12:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 8002c14:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002c16:	3201      	adds	r2, #1
    while (hspi->TxXferCount > 0U)
 8002c18:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002c1a:	6322      	str	r2, [r4, #48]	; 0x30
    while (hspi->TxXferCount > 0U)
 8002c1c:	2b00      	cmp	r3, #0
 8002c1e:	f43f af57 	beq.w	8002ad0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002c22:	6823      	ldr	r3, [r4, #0]
 8002c24:	689a      	ldr	r2, [r3, #8]
 8002c26:	0792      	lsls	r2, r2, #30
 8002c28:	d4ec      	bmi.n	8002c04 <HAL_SPI_Transmit+0x200>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002c2a:	f7fd fef3 	bl	8000a14 <HAL_GetTick>
 8002c2e:	e7b9      	b.n	8002ba4 <HAL_SPI_Transmit+0x1a0>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002c30:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002c32:	f832 3b02 	ldrh.w	r3, [r2], #2
 8002c36:	60c3      	str	r3, [r0, #12]
        hspi->TxXferCount--;
 8002c38:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002c3a:	6322      	str	r2, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002c3c:	3b01      	subs	r3, #1
 8002c3e:	b29b      	uxth	r3, r3
 8002c40:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 8002c42:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002c44:	b29b      	uxth	r3, r3
 8002c46:	2b00      	cmp	r3, #0
 8002c48:	f43f af42 	beq.w	8002ad0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002c4c:	6883      	ldr	r3, [r0, #8]
 8002c4e:	079f      	lsls	r7, r3, #30
 8002c50:	d5eb      	bpl.n	8002c2a <HAL_SPI_Transmit+0x226>
 8002c52:	e7ed      	b.n	8002c30 <HAL_SPI_Transmit+0x22c>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002c54:	2220      	movs	r2, #32
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002c56:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002c58:	4313      	orrs	r3, r2
 8002c5a:	6563      	str	r3, [r4, #84]	; 0x54
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002c5c:	6562      	str	r2, [r4, #84]	; 0x54
 8002c5e:	e740      	b.n	8002ae2 <HAL_SPI_Transmit+0xde>

08002c60 <HAL_SPI_TransmitReceive>:
{
 8002c60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002c64:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8002c66:	f890 0050 	ldrb.w	r0, [r0, #80]	; 0x50
{
 8002c6a:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8002c6c:	2801      	cmp	r0, #1
{
 8002c6e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  __HAL_LOCK(hspi);
 8002c70:	f000 8089 	beq.w	8002d86 <HAL_SPI_TransmitReceive+0x126>
 8002c74:	4698      	mov	r8, r3
 8002c76:	2301      	movs	r3, #1
 8002c78:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tickstart = HAL_GetTick();
 8002c7c:	468a      	mov	sl, r1
 8002c7e:	4691      	mov	r9, r2
 8002c80:	f7fd fec8 	bl	8000a14 <HAL_GetTick>
  tmp_state           = hspi->State;
 8002c84:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  tickstart = HAL_GetTick();
 8002c88:	4606      	mov	r6, r0
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8002c8a:	2f01      	cmp	r7, #1
  tmp_mode            = hspi->Init.Mode;
 8002c8c:	6863      	ldr	r3, [r4, #4]
  tmp_state           = hspi->State;
 8002c8e:	b2f9      	uxtb	r1, r7
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8002c90:	d011      	beq.n	8002cb6 <HAL_SPI_TransmitReceive+0x56>
 8002c92:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8002c96:	d009      	beq.n	8002cac <HAL_SPI_TransmitReceive+0x4c>
    errorcode = HAL_BUSY;
 8002c98:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002c9a:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8002c9c:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8002c9e:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8002ca2:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 8002ca6:	b002      	add	sp, #8
 8002ca8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8002cac:	68a2      	ldr	r2, [r4, #8]
 8002cae:	2a00      	cmp	r2, #0
 8002cb0:	d1f2      	bne.n	8002c98 <HAL_SPI_TransmitReceive+0x38>
 8002cb2:	2904      	cmp	r1, #4
 8002cb4:	d1f0      	bne.n	8002c98 <HAL_SPI_TransmitReceive+0x38>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8002cb6:	f1ba 0f00 	cmp.w	sl, #0
 8002cba:	d068      	beq.n	8002d8e <HAL_SPI_TransmitReceive+0x12e>
 8002cbc:	f1b9 0f00 	cmp.w	r9, #0
 8002cc0:	d065      	beq.n	8002d8e <HAL_SPI_TransmitReceive+0x12e>
 8002cc2:	f1b8 0f00 	cmp.w	r8, #0
 8002cc6:	d062      	beq.n	8002d8e <HAL_SPI_TransmitReceive+0x12e>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8002cc8:	f894 2051 	ldrb.w	r2, [r4, #81]	; 0x51
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002ccc:	6820      	ldr	r0, [r4, #0]
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8002cce:	2a04      	cmp	r2, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8002cd0:	bf1c      	itt	ne
 8002cd2:	2205      	movne	r2, #5
 8002cd4:	f884 2051 	strbne.w	r2, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002cd8:	2200      	movs	r2, #0
 8002cda:	6562      	str	r2, [r4, #84]	; 0x54
  hspi->RxXferCount = Size;
 8002cdc:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->TxXferCount = Size;
 8002ce0:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36
  hspi->TxISR       = NULL;
 8002ce4:	e9c4 2210 	strd	r2, r2, [r4, #64]	; 0x40
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002ce8:	6802      	ldr	r2, [r0, #0]
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8002cea:	f8c4 9038 	str.w	r9, [r4, #56]	; 0x38
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002cee:	0652      	lsls	r2, r2, #25
  hspi->RxXferSize  = Size;
 8002cf0:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8002cf4:	f8c4 a030 	str.w	sl, [r4, #48]	; 0x30
  hspi->TxXferSize  = Size;
 8002cf8:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002cfc:	d403      	bmi.n	8002d06 <HAL_SPI_TransmitReceive+0xa6>
    __HAL_SPI_ENABLE(hspi);
 8002cfe:	6802      	ldr	r2, [r0, #0]
 8002d00:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002d04:	6002      	str	r2, [r0, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8002d06:	68e2      	ldr	r2, [r4, #12]
 8002d08:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8002d0c:	d04f      	beq.n	8002dae <HAL_SPI_TransmitReceive+0x14e>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002d0e:	2b00      	cmp	r3, #0
 8002d10:	d03f      	beq.n	8002d92 <HAL_SPI_TransmitReceive+0x132>
 8002d12:	f1b8 0f01 	cmp.w	r8, #1
 8002d16:	d03c      	beq.n	8002d92 <HAL_SPI_TransmitReceive+0x132>
        txallowed = 1U;
 8002d18:	2701      	movs	r7, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002d1a:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8002d1c:	b292      	uxth	r2, r2
 8002d1e:	b91a      	cbnz	r2, 8002d28 <HAL_SPI_TransmitReceive+0xc8>
 8002d20:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002d22:	b29b      	uxth	r3, r3
 8002d24:	2b00      	cmp	r3, #0
 8002d26:	d07f      	beq.n	8002e28 <HAL_SPI_TransmitReceive+0x1c8>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002d28:	6823      	ldr	r3, [r4, #0]
 8002d2a:	689a      	ldr	r2, [r3, #8]
 8002d2c:	0792      	lsls	r2, r2, #30
 8002d2e:	d50f      	bpl.n	8002d50 <HAL_SPI_TransmitReceive+0xf0>
 8002d30:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8002d32:	b292      	uxth	r2, r2
 8002d34:	b162      	cbz	r2, 8002d50 <HAL_SPI_TransmitReceive+0xf0>
 8002d36:	b15f      	cbz	r7, 8002d50 <HAL_SPI_TransmitReceive+0xf0>
        txallowed = 0U;
 8002d38:	2700      	movs	r7, #0
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8002d3a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002d3c:	7812      	ldrb	r2, [r2, #0]
 8002d3e:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8002d40:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr++;
 8002d42:	6b22      	ldr	r2, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002d44:	3b01      	subs	r3, #1
 8002d46:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr++;
 8002d48:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8002d4a:	86e3      	strh	r3, [r4, #54]	; 0x36
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002d4c:	6823      	ldr	r3, [r4, #0]
        hspi->pTxBuffPtr++;
 8002d4e:	6322      	str	r2, [r4, #48]	; 0x30
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002d50:	689a      	ldr	r2, [r3, #8]
 8002d52:	f012 0201 	ands.w	r2, r2, #1
 8002d56:	d00d      	beq.n	8002d74 <HAL_SPI_TransmitReceive+0x114>
 8002d58:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
 8002d5a:	b289      	uxth	r1, r1
 8002d5c:	b151      	cbz	r1, 8002d74 <HAL_SPI_TransmitReceive+0x114>
        txallowed = 1U;
 8002d5e:	4617      	mov	r7, r2
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8002d60:	68da      	ldr	r2, [r3, #12]
 8002d62:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002d64:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 8002d66:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002d68:	3301      	adds	r3, #1
 8002d6a:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002d6c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002d6e:	3b01      	subs	r3, #1
 8002d70:	b29b      	uxth	r3, r3
 8002d72:	87e3      	strh	r3, [r4, #62]	; 0x3e
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8002d74:	f7fd fe4e 	bl	8000a14 <HAL_GetTick>
 8002d78:	1b80      	subs	r0, r0, r6
 8002d7a:	42a8      	cmp	r0, r5
 8002d7c:	d314      	bcc.n	8002da8 <HAL_SPI_TransmitReceive+0x148>
 8002d7e:	1c6b      	adds	r3, r5, #1
 8002d80:	d0cb      	beq.n	8002d1a <HAL_SPI_TransmitReceive+0xba>
        errorcode = HAL_TIMEOUT;
 8002d82:	2003      	movs	r0, #3
 8002d84:	e789      	b.n	8002c9a <HAL_SPI_TransmitReceive+0x3a>
  __HAL_LOCK(hspi);
 8002d86:	2002      	movs	r0, #2
}
 8002d88:	b002      	add	sp, #8
 8002d8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    errorcode = HAL_ERROR;
 8002d8e:	2001      	movs	r0, #1
 8002d90:	e783      	b.n	8002c9a <HAL_SPI_TransmitReceive+0x3a>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002d92:	f89a 3000 	ldrb.w	r3, [sl]
 8002d96:	7303      	strb	r3, [r0, #12]
      hspi->TxXferCount--;
 8002d98:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002d9a:	6b22      	ldr	r2, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002d9c:	3b01      	subs	r3, #1
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002d9e:	3201      	adds	r2, #1
      hspi->TxXferCount--;
 8002da0:	b29b      	uxth	r3, r3
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002da2:	6322      	str	r2, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002da4:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002da6:	e7b7      	b.n	8002d18 <HAL_SPI_TransmitReceive+0xb8>
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8002da8:	2d00      	cmp	r5, #0
 8002daa:	d1b6      	bne.n	8002d1a <HAL_SPI_TransmitReceive+0xba>
 8002dac:	e7e9      	b.n	8002d82 <HAL_SPI_TransmitReceive+0x122>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002dae:	2b00      	cmp	r3, #0
 8002db0:	d14e      	bne.n	8002e50 <HAL_SPI_TransmitReceive+0x1f0>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002db2:	4651      	mov	r1, sl
 8002db4:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002db8:	60c3      	str	r3, [r0, #12]
      hspi->TxXferCount--;
 8002dba:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002dbc:	6321      	str	r1, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002dbe:	3b01      	subs	r3, #1
 8002dc0:	b29b      	uxth	r3, r3
 8002dc2:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002dc4:	1c6b      	adds	r3, r5, #1
{
 8002dc6:	f04f 0701 	mov.w	r7, #1
 8002dca:	d025      	beq.n	8002e18 <HAL_SPI_TransmitReceive+0x1b8>
 8002dcc:	e044      	b.n	8002e58 <HAL_SPI_TransmitReceive+0x1f8>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002dce:	6822      	ldr	r2, [r4, #0]
 8002dd0:	6893      	ldr	r3, [r2, #8]
 8002dd2:	0798      	lsls	r0, r3, #30
 8002dd4:	d50d      	bpl.n	8002df2 <HAL_SPI_TransmitReceive+0x192>
 8002dd6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002dd8:	b29b      	uxth	r3, r3
 8002dda:	b153      	cbz	r3, 8002df2 <HAL_SPI_TransmitReceive+0x192>
 8002ddc:	b14f      	cbz	r7, 8002df2 <HAL_SPI_TransmitReceive+0x192>
        txallowed = 0U;
 8002dde:	2700      	movs	r7, #0
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002de0:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002de2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002de6:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8002de8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002dea:	6321      	str	r1, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002dec:	3b01      	subs	r3, #1
 8002dee:	b29b      	uxth	r3, r3
 8002df0:	86e3      	strh	r3, [r4, #54]	; 0x36
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002df2:	6893      	ldr	r3, [r2, #8]
 8002df4:	f013 0301 	ands.w	r3, r3, #1
 8002df8:	d00c      	beq.n	8002e14 <HAL_SPI_TransmitReceive+0x1b4>
 8002dfa:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
 8002dfc:	b289      	uxth	r1, r1
 8002dfe:	b149      	cbz	r1, 8002e14 <HAL_SPI_TransmitReceive+0x1b4>
        txallowed = 1U;
 8002e00:	461f      	mov	r7, r3
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8002e02:	68d3      	ldr	r3, [r2, #12]
 8002e04:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002e06:	f822 3b02 	strh.w	r3, [r2], #2
        hspi->RxXferCount--;
 8002e0a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8002e0c:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002e0e:	3b01      	subs	r3, #1
 8002e10:	b29b      	uxth	r3, r3
 8002e12:	87e3      	strh	r3, [r4, #62]	; 0x3e
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8002e14:	f7fd fdfe 	bl	8000a14 <HAL_GetTick>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002e18:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002e1a:	b29b      	uxth	r3, r3
 8002e1c:	2b00      	cmp	r3, #0
 8002e1e:	d1d6      	bne.n	8002dce <HAL_SPI_TransmitReceive+0x16e>
 8002e20:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e22:	b29b      	uxth	r3, r3
 8002e24:	2b00      	cmp	r3, #0
 8002e26:	d1d2      	bne.n	8002dce <HAL_SPI_TransmitReceive+0x16e>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002e28:	4633      	mov	r3, r6
 8002e2a:	462a      	mov	r2, r5
 8002e2c:	2180      	movs	r1, #128	; 0x80
 8002e2e:	4620      	mov	r0, r4
 8002e30:	f7ff fd2c 	bl	800288c <SPI_WaitFlagStateUntilTimeout.constprop.1>
 8002e34:	2800      	cmp	r0, #0
 8002e36:	d13f      	bne.n	8002eb8 <HAL_SPI_TransmitReceive+0x258>
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002e38:	68a3      	ldr	r3, [r4, #8]
 8002e3a:	2b00      	cmp	r3, #0
 8002e3c:	f47f af2d 	bne.w	8002c9a <HAL_SPI_TransmitReceive+0x3a>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002e40:	6823      	ldr	r3, [r4, #0]
 8002e42:	9001      	str	r0, [sp, #4]
 8002e44:	68da      	ldr	r2, [r3, #12]
 8002e46:	9201      	str	r2, [sp, #4]
 8002e48:	689b      	ldr	r3, [r3, #8]
 8002e4a:	9301      	str	r3, [sp, #4]
 8002e4c:	9b01      	ldr	r3, [sp, #4]
 8002e4e:	e724      	b.n	8002c9a <HAL_SPI_TransmitReceive+0x3a>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002e50:	f1b8 0f01 	cmp.w	r8, #1
 8002e54:	d1b6      	bne.n	8002dc4 <HAL_SPI_TransmitReceive+0x164>
 8002e56:	e7ac      	b.n	8002db2 <HAL_SPI_TransmitReceive+0x152>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002e58:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002e5a:	b29b      	uxth	r3, r3
 8002e5c:	b91b      	cbnz	r3, 8002e66 <HAL_SPI_TransmitReceive+0x206>
 8002e5e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e60:	b29b      	uxth	r3, r3
 8002e62:	2b00      	cmp	r3, #0
 8002e64:	d0e0      	beq.n	8002e28 <HAL_SPI_TransmitReceive+0x1c8>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002e66:	6822      	ldr	r2, [r4, #0]
 8002e68:	6893      	ldr	r3, [r2, #8]
 8002e6a:	0799      	lsls	r1, r3, #30
 8002e6c:	d50d      	bpl.n	8002e8a <HAL_SPI_TransmitReceive+0x22a>
 8002e6e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002e70:	b29b      	uxth	r3, r3
 8002e72:	b153      	cbz	r3, 8002e8a <HAL_SPI_TransmitReceive+0x22a>
 8002e74:	b14f      	cbz	r7, 8002e8a <HAL_SPI_TransmitReceive+0x22a>
        txallowed = 0U;
 8002e76:	2700      	movs	r7, #0
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002e78:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e7a:	f833 1b02 	ldrh.w	r1, [r3], #2
 8002e7e:	60d1      	str	r1, [r2, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002e80:	6323      	str	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002e82:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002e84:	3b01      	subs	r3, #1
 8002e86:	b29b      	uxth	r3, r3
 8002e88:	86e3      	strh	r3, [r4, #54]	; 0x36
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002e8a:	6893      	ldr	r3, [r2, #8]
 8002e8c:	f013 0301 	ands.w	r3, r3, #1
 8002e90:	d00c      	beq.n	8002eac <HAL_SPI_TransmitReceive+0x24c>
 8002e92:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
 8002e94:	b289      	uxth	r1, r1
 8002e96:	b149      	cbz	r1, 8002eac <HAL_SPI_TransmitReceive+0x24c>
        txallowed = 1U;
 8002e98:	461f      	mov	r7, r3
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8002e9a:	68d3      	ldr	r3, [r2, #12]
 8002e9c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002e9e:	f822 3b02 	strh.w	r3, [r2], #2
        hspi->RxXferCount--;
 8002ea2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8002ea4:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002ea6:	3b01      	subs	r3, #1
 8002ea8:	b29b      	uxth	r3, r3
 8002eaa:	87e3      	strh	r3, [r4, #62]	; 0x3e
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8002eac:	f7fd fdb2 	bl	8000a14 <HAL_GetTick>
 8002eb0:	1b80      	subs	r0, r0, r6
 8002eb2:	42a8      	cmp	r0, r5
 8002eb4:	d3d0      	bcc.n	8002e58 <HAL_SPI_TransmitReceive+0x1f8>
 8002eb6:	e764      	b.n	8002d82 <HAL_SPI_TransmitReceive+0x122>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002eb8:	2220      	movs	r2, #32
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002eba:	6d63      	ldr	r3, [r4, #84]	; 0x54
    errorcode = HAL_ERROR;
 8002ebc:	2001      	movs	r0, #1
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002ebe:	4313      	orrs	r3, r2
 8002ec0:	6563      	str	r3, [r4, #84]	; 0x54
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002ec2:	6562      	str	r2, [r4, #84]	; 0x54
    goto error;
 8002ec4:	e6e9      	b.n	8002c9a <HAL_SPI_TransmitReceive+0x3a>
 8002ec6:	bf00      	nop

08002ec8 <HAL_UART_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if (huart == NULL)
 8002ec8:	2800      	cmp	r0, #0
 8002eca:	d064      	beq.n	8002f96 <HAL_UART_Init+0xce>
{
 8002ecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
#if defined(USART_CR1_OVER8)
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
#endif /* USART_CR1_OVER8 */

  if (huart->gState == HAL_UART_STATE_RESET)
 8002ece:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002ed2:	4604      	mov	r4, r0
 8002ed4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002ed8:	2b00      	cmp	r3, #0
 8002eda:	d054      	beq.n	8002f86 <HAL_UART_Init+0xbe>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002edc:	e9d4 2702 	ldrd	r2, r7, [r4, #8]
  huart->gState = HAL_UART_STATE_BUSY;
 8002ee0:	2124      	movs	r1, #36	; 0x24
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002ee2:	6920      	ldr	r0, [r4, #16]
  __HAL_UART_DISABLE(huart);
 8002ee4:	6823      	ldr	r3, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002ee6:	4302      	orrs	r2, r0
 8002ee8:	6960      	ldr	r0, [r4, #20]
  huart->gState = HAL_UART_STATE_BUSY;
 8002eea:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002eee:	4302      	orrs	r2, r0
  __HAL_UART_DISABLE(huart);
 8002ef0:	68d8      	ldr	r0, [r3, #12]
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002ef2:	69a6      	ldr	r6, [r4, #24]
  __HAL_UART_DISABLE(huart);
 8002ef4:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
 8002ef8:	60d8      	str	r0, [r3, #12]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002efa:	6919      	ldr	r1, [r3, #16]


  if(huart->Instance == USART1)
 8002efc:	4d27      	ldr	r5, [pc, #156]	; (8002f9c <HAL_UART_Init+0xd4>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002efe:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
 8002f02:	4339      	orrs	r1, r7
 8002f04:	6119      	str	r1, [r3, #16]
  MODIFY_REG(huart->Instance->CR1,
 8002f06:	68d9      	ldr	r1, [r3, #12]
  if(huart->Instance == USART1)
 8002f08:	42ab      	cmp	r3, r5
  MODIFY_REG(huart->Instance->CR1,
 8002f0a:	f421 51b0 	bic.w	r1, r1, #5632	; 0x1600
 8002f0e:	f021 010c 	bic.w	r1, r1, #12
 8002f12:	ea42 0201 	orr.w	r2, r2, r1
 8002f16:	60da      	str	r2, [r3, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002f18:	695a      	ldr	r2, [r3, #20]
 8002f1a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002f1e:	ea42 0206 	orr.w	r2, r2, r6
 8002f22:	615a      	str	r2, [r3, #20]
  if(huart->Instance == USART1)
 8002f24:	d034      	beq.n	8002f90 <HAL_UART_Init+0xc8>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 8002f26:	f7ff fc0f 	bl	8002748 <HAL_RCC_GetPCLK1Freq>
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8002f2a:	6862      	ldr	r2, [r4, #4]
 8002f2c:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8002f30:	0092      	lsls	r2, r2, #2
 8002f32:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8002f36:	fbb3 f3f2 	udiv	r3, r3, r2
 8002f3a:	2664      	movs	r6, #100	; 0x64
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002f3c:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_READY;
 8002f3e:	f04f 0c20 	mov.w	ip, #32
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8002f42:	4817      	ldr	r0, [pc, #92]	; (8002fa0 <HAL_UART_Init+0xd8>)
 8002f44:	6821      	ldr	r1, [r4, #0]
 8002f46:	fba0 7203 	umull	r7, r2, r0, r3
 8002f4a:	0952      	lsrs	r2, r2, #5
 8002f4c:	fb06 3312 	mls	r3, r6, r2, r3
 8002f50:	011b      	lsls	r3, r3, #4
 8002f52:	3332      	adds	r3, #50	; 0x32
 8002f54:	fba0 0303 	umull	r0, r3, r0, r3
 8002f58:	0112      	lsls	r2, r2, #4
 8002f5a:	eb02 1353 	add.w	r3, r2, r3, lsr #5
 8002f5e:	608b      	str	r3, [r1, #8]
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002f60:	690b      	ldr	r3, [r1, #16]
  return HAL_OK;
 8002f62:	4628      	mov	r0, r5
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002f64:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8002f68:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002f6a:	694b      	ldr	r3, [r1, #20]
 8002f6c:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8002f70:	614b      	str	r3, [r1, #20]
  __HAL_UART_ENABLE(huart);
 8002f72:	68cb      	ldr	r3, [r1, #12]
 8002f74:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002f78:	60cb      	str	r3, [r1, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002f7a:	6425      	str	r5, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 8002f7c:	f884 c03d 	strb.w	ip, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 8002f80:	f884 c03e 	strb.w	ip, [r4, #62]	; 0x3e
}
 8002f84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    huart->Lock = HAL_UNLOCKED;
 8002f86:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 8002f8a:	f7fd fc33 	bl	80007f4 <HAL_UART_MspInit>
 8002f8e:	e7a5      	b.n	8002edc <HAL_UART_Init+0x14>
    pclk = HAL_RCC_GetPCLK2Freq();
 8002f90:	f7ff fbea 	bl	8002768 <HAL_RCC_GetPCLK2Freq>
 8002f94:	e7c9      	b.n	8002f2a <HAL_UART_Init+0x62>
    return HAL_ERROR;
 8002f96:	2001      	movs	r0, #1
}
 8002f98:	4770      	bx	lr
 8002f9a:	bf00      	nop
 8002f9c:	40013800 	.word	0x40013800
 8002fa0:	51eb851f 	.word	0x51eb851f

08002fa4 <HAL_UART_Transmit>:
{
 8002fa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002fa8:	461d      	mov	r5, r3
  if (huart->gState == HAL_UART_STATE_READY)
 8002faa:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002fae:	2b20      	cmp	r3, #32
 8002fb0:	d168      	bne.n	8003084 <HAL_UART_Transmit+0xe0>
    if ((pData == NULL) || (Size == 0U))
 8002fb2:	4688      	mov	r8, r1
 8002fb4:	2900      	cmp	r1, #0
 8002fb6:	d040      	beq.n	800303a <HAL_UART_Transmit+0x96>
 8002fb8:	4617      	mov	r7, r2
 8002fba:	2a00      	cmp	r2, #0
 8002fbc:	d03d      	beq.n	800303a <HAL_UART_Transmit+0x96>
    __HAL_LOCK(huart);
 8002fbe:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8002fc2:	4604      	mov	r4, r0
 8002fc4:	2b01      	cmp	r3, #1
 8002fc6:	d05d      	beq.n	8003084 <HAL_UART_Transmit+0xe0>
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002fc8:	2321      	movs	r3, #33	; 0x21
    __HAL_LOCK(huart);
 8002fca:	2201      	movs	r2, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002fcc:	f04f 0900 	mov.w	r9, #0
    __HAL_LOCK(huart);
 8002fd0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002fd4:	f8c0 9040 	str.w	r9, [r0, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002fd8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    tickstart = HAL_GetTick();
 8002fdc:	f7fd fd1a 	bl	8000a14 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002fe0:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 8002fe2:	4606      	mov	r6, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002fe4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize = Size;
 8002fe8:	84a7      	strh	r7, [r4, #36]	; 0x24
    huart->TxXferCount = Size;
 8002fea:	84e7      	strh	r7, [r4, #38]	; 0x26
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002fec:	d04d      	beq.n	800308a <HAL_UART_Transmit+0xe6>
    __HAL_UNLOCK(huart);
 8002fee:	2300      	movs	r3, #0
 8002ff0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    while (huart->TxXferCount > 0U)
 8002ff4:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 8002ff6:	b29b      	uxth	r3, r3
 8002ff8:	2b00      	cmp	r3, #0
 8002ffa:	d058      	beq.n	80030ae <HAL_UART_Transmit+0x10a>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8002ffc:	6823      	ldr	r3, [r4, #0]
 8002ffe:	1c69      	adds	r1, r5, #1
 8003000:	d11e      	bne.n	8003040 <HAL_UART_Transmit+0x9c>
 8003002:	681a      	ldr	r2, [r3, #0]
 8003004:	0612      	lsls	r2, r2, #24
 8003006:	d5fc      	bpl.n	8003002 <HAL_UART_Transmit+0x5e>
      if (pdata8bits == NULL)
 8003008:	f1b8 0f00 	cmp.w	r8, #0
 800300c:	d035      	beq.n	800307a <HAL_UART_Transmit+0xd6>
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 800300e:	f818 2b01 	ldrb.w	r2, [r8], #1
 8003012:	605a      	str	r2, [r3, #4]
      huart->TxXferCount--;
 8003014:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8003016:	3a01      	subs	r2, #1
 8003018:	b292      	uxth	r2, r2
 800301a:	84e2      	strh	r2, [r4, #38]	; 0x26
    while (huart->TxXferCount > 0U)
 800301c:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 800301e:	b292      	uxth	r2, r2
 8003020:	2a00      	cmp	r2, #0
 8003022:	d1ec      	bne.n	8002ffe <HAL_UART_Transmit+0x5a>
 8003024:	1c68      	adds	r0, r5, #1
 8003026:	d136      	bne.n	8003096 <HAL_UART_Transmit+0xf2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8003028:	681a      	ldr	r2, [r3, #0]
 800302a:	0651      	lsls	r1, r2, #25
 800302c:	d5fc      	bpl.n	8003028 <HAL_UART_Transmit+0x84>
    huart->gState = HAL_UART_STATE_READY;
 800302e:	2320      	movs	r3, #32
 8003030:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    return HAL_OK;
 8003034:	2000      	movs	r0, #0
}
 8003036:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      return  HAL_ERROR;
 800303a:	2001      	movs	r0, #1
}
 800303c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8003040:	681a      	ldr	r2, [r3, #0]
 8003042:	0617      	lsls	r7, r2, #24
 8003044:	d4e0      	bmi.n	8003008 <HAL_UART_Transmit+0x64>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8003046:	b12d      	cbz	r5, 8003054 <HAL_UART_Transmit+0xb0>
 8003048:	f7fd fce4 	bl	8000a14 <HAL_GetTick>
 800304c:	1b80      	subs	r0, r0, r6
 800304e:	4285      	cmp	r5, r0
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8003050:	6823      	ldr	r3, [r4, #0]
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8003052:	d2d4      	bcs.n	8002ffe <HAL_UART_Transmit+0x5a>
        huart->gState  = HAL_UART_STATE_READY;
 8003054:	2120      	movs	r1, #32
        __HAL_UNLOCK(huart);
 8003056:	2500      	movs	r5, #0
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8003058:	68da      	ldr	r2, [r3, #12]
      return HAL_TIMEOUT;
 800305a:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800305c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8003060:	60da      	str	r2, [r3, #12]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003062:	695a      	ldr	r2, [r3, #20]
 8003064:	f022 0201 	bic.w	r2, r2, #1
 8003068:	615a      	str	r2, [r3, #20]
        huart->gState  = HAL_UART_STATE_READY;
 800306a:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
        __HAL_UNLOCK(huart);
 800306e:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
        huart->RxState = HAL_UART_STATE_READY;
 8003072:	f884 103e 	strb.w	r1, [r4, #62]	; 0x3e
}
 8003076:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 800307a:	f839 2b02 	ldrh.w	r2, [r9], #2
 800307e:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8003082:	e7c6      	b.n	8003012 <HAL_UART_Transmit+0x6e>
    return HAL_BUSY;
 8003084:	2002      	movs	r0, #2
}
 8003086:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800308a:	6923      	ldr	r3, [r4, #16]
 800308c:	2b00      	cmp	r3, #0
 800308e:	d1ae      	bne.n	8002fee <HAL_UART_Transmit+0x4a>
 8003090:	46c1      	mov	r9, r8
      pdata8bits  = NULL;
 8003092:	4698      	mov	r8, r3
 8003094:	e7ab      	b.n	8002fee <HAL_UART_Transmit+0x4a>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8003096:	681a      	ldr	r2, [r3, #0]
 8003098:	0652      	lsls	r2, r2, #25
 800309a:	d4c8      	bmi.n	800302e <HAL_UART_Transmit+0x8a>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800309c:	2d00      	cmp	r5, #0
 800309e:	d0d9      	beq.n	8003054 <HAL_UART_Transmit+0xb0>
 80030a0:	f7fd fcb8 	bl	8000a14 <HAL_GetTick>
 80030a4:	1b83      	subs	r3, r0, r6
 80030a6:	429d      	cmp	r5, r3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80030a8:	6823      	ldr	r3, [r4, #0]
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80030aa:	d2bb      	bcs.n	8003024 <HAL_UART_Transmit+0x80>
 80030ac:	e7d2      	b.n	8003054 <HAL_UART_Transmit+0xb0>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80030ae:	6823      	ldr	r3, [r4, #0]
 80030b0:	e7b8      	b.n	8003024 <HAL_UART_Transmit+0x80>
 80030b2:	bf00      	nop

080030b4 <USB_CoreInit>:
  * @param  cfg pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 80030b4:	b084      	sub	sp, #16
 80030b6:	a801      	add	r0, sp, #4
 80030b8:	e880 000e 	stmia.w	r0, {r1, r2, r3}
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 80030bc:	b004      	add	sp, #16
 80030be:	2000      	movs	r0, #0
 80030c0:	4770      	bx	lr
 80030c2:	bf00      	nop

080030c4 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_TypeDef *USBx)
{
 80030c4:	4603      	mov	r3, r0
  uint32_t winterruptmask;

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 80030c6:	2200      	movs	r2, #0
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM;

  /* Set interrupt mask */
  USBx->CNTR = (uint16_t)winterruptmask;
 80030c8:	f44f 413f 	mov.w	r1, #48896	; 0xbf00
  USBx->ISTR = 0U;
 80030cc:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

  return HAL_OK;
}
 80030d0:	4610      	mov	r0, r2
  USBx->CNTR = (uint16_t)winterruptmask;
 80030d2:	f8a3 1040 	strh.w	r1, [r3, #64]	; 0x40
}
 80030d6:	4770      	bx	lr

080030d8 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_TypeDef *USBx)
{
 80030d8:	4603      	mov	r3, r0
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 80030da:	f244 02ff 	movw	r2, #16639	; 0x40ff
 80030de:	f8b3 1040 	ldrh.w	r1, [r3, #64]	; 0x40

  return HAL_OK;
}
 80030e2:	2000      	movs	r0, #0
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 80030e4:	400a      	ands	r2, r1
 80030e6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
}
 80030ea:	4770      	bx	lr

080030ec <USB_SetCurrentMode>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 80030ec:	2000      	movs	r0, #0
 80030ee:	4770      	bx	lr

080030f0 <USB_DevInit>:
  * @param  cfg  pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 80030f0:	b084      	sub	sp, #16
 80030f2:	f10d 0c04 	add.w	ip, sp, #4
 80030f6:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
 80030fa:	4603      	mov	r3, r0
  /* Init Device */
  /* CNTR_FRES = 1 */
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;

  /* CNTR_FRES = 0 */
  USBx->CNTR = 0U;
 80030fc:	2200      	movs	r2, #0
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 80030fe:	2101      	movs	r1, #1

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;

  return HAL_OK;
}
 8003100:	4610      	mov	r0, r2
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 8003102:	f8a3 1040 	strh.w	r1, [r3, #64]	; 0x40
}
 8003106:	b004      	add	sp, #16
  USBx->CNTR = 0U;
 8003108:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
  USBx->ISTR = 0U;
 800310c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  USBx->BTABLE = BTABLE_ADDRESS;
 8003110:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
}
 8003114:	4770      	bx	lr
 8003116:	bf00      	nop

08003118 <USB_FlushTxFifo>:
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 8003118:	2000      	movs	r0, #0
 800311a:	4770      	bx	lr

0800311c <USB_FlushRxFifo>:
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 800311c:	2000      	movs	r0, #0
 800311e:	4770      	bx	lr

08003120 <USB_ActivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8003120:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef ret = HAL_OK;
  uint16_t wEpRegVal;

  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 8003122:	780a      	ldrb	r2, [r1, #0]

  /* initialize Endpoint */
  switch (ep->type)
 8003124:	f891 e003 	ldrb.w	lr, [r1, #3]
  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 8003128:	f830 c022 	ldrh.w	ip, [r0, r2, lsl #2]
{
 800312c:	4603      	mov	r3, r0
  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 800312e:	f42c 4cec 	bic.w	ip, ip, #30208	; 0x7600
 8003132:	f02c 0c70 	bic.w	ip, ip, #112	; 0x70
 8003136:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800313a:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
  switch (ep->type)
 800313e:	f1be 0f03 	cmp.w	lr, #3
 8003142:	f200 815a 	bhi.w	80033fa <USB_ActivateEndpoint+0x2da>
 8003146:	e8df f00e 	tbb	[pc, lr]
 800314a:	4e52      	.short	0x4e52
 800314c:	0204      	.short	0x0204
    case EP_TYPE_BULK:
      wEpRegVal |= USB_EP_BULK;
      break;

    case EP_TYPE_INTR:
      wEpRegVal |= USB_EP_INTERRUPT;
 800314e:	f44c 6cc0 	orr.w	ip, ip, #1536	; 0x600
  HAL_StatusTypeDef ret = HAL_OK;
 8003152:	2000      	movs	r0, #0
    default:
      ret = HAL_ERROR;
      break;
  }

  PCD_SET_ENDPOINT(USBx, ep->num, (wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX));
 8003154:	f248 0580 	movw	r5, #32896	; 0x8080
 8003158:	ea4c 0c05 	orr.w	ip, ip, r5
 800315c:	f823 c022 	strh.w	ip, [r3, r2, lsl #2]

  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 8003160:	f833 c022 	ldrh.w	ip, [r3, r2, lsl #2]
 8003164:	4ca6      	ldr	r4, [pc, #664]	; (8003400 <USB_ActivateEndpoint+0x2e0>)
 8003166:	fa1f fc8c 	uxth.w	ip, ip
 800316a:	ea0c 0c04 	and.w	ip, ip, r4
 800316e:	ea4c 0c02 	orr.w	ip, ip, r2
 8003172:	ea45 050c 	orr.w	r5, r5, ip
 8003176:	f823 5022 	strh.w	r5, [r3, r2, lsl #2]

  if (ep->doublebuffer == 0U)
 800317a:	7b0d      	ldrb	r5, [r1, #12]
 800317c:	2d00      	cmp	r5, #0
 800317e:	d17e      	bne.n	800327e <USB_ActivateEndpoint+0x15e>
  {
    if (ep->is_in != 0U)
 8003180:	784d      	ldrb	r5, [r1, #1]
 8003182:	2d00      	cmp	r5, #0
 8003184:	f000 80dd 	beq.w	8003342 <USB_ActivateEndpoint+0x222>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8003188:	88c9      	ldrh	r1, [r1, #6]
 800318a:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
 800318e:	0849      	lsrs	r1, r1, #1
 8003190:	eb03 1602 	add.w	r6, r3, r2, lsl #4
 8003194:	0049      	lsls	r1, r1, #1
 8003196:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800319a:	b2ad      	uxth	r5, r5
 800319c:	5371      	strh	r1, [r6, r5]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800319e:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80031a2:	064e      	lsls	r6, r1, #25
 80031a4:	d509      	bpl.n	80031ba <USB_ActivateEndpoint+0x9a>
 80031a6:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80031aa:	b289      	uxth	r1, r1
 80031ac:	400c      	ands	r4, r1
 80031ae:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 80031b2:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
 80031b6:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]

      if (ep->type != EP_TYPE_ISOC)
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 80031ba:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
      if (ep->type != EP_TYPE_ISOC)
 80031be:	f1be 0f01 	cmp.w	lr, #1
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 80031c2:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 80031c6:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 80031ca:	ea4f 4101 	mov.w	r1, r1, lsl #16
 80031ce:	ea4f 4111 	mov.w	r1, r1, lsr #16
      if (ep->type != EP_TYPE_ISOC)
 80031d2:	d04d      	beq.n	8003270 <USB_ActivateEndpoint+0x150>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 80031d4:	f081 0120 	eor.w	r1, r1, #32
 80031d8:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 80031dc:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80031e0:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }

  return ret;
}
 80031e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_StatusTypeDef ret = HAL_OK;
 80031e6:	2000      	movs	r0, #0
      wEpRegVal |= USB_EP_ISOCHRONOUS;
 80031e8:	f44c 6c80 	orr.w	ip, ip, #1024	; 0x400
      break;
 80031ec:	e7b2      	b.n	8003154 <USB_ActivateEndpoint+0x34>
  HAL_StatusTypeDef ret = HAL_OK;
 80031ee:	4670      	mov	r0, lr
      wEpRegVal |= USB_EP_CONTROL;
 80031f0:	f44c 7c00 	orr.w	ip, ip, #512	; 0x200
      break;
 80031f4:	e7ae      	b.n	8003154 <USB_ActivateEndpoint+0x34>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80031f6:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80031fa:	044d      	lsls	r5, r1, #17
 80031fc:	d509      	bpl.n	8003212 <USB_ActivateEndpoint+0xf2>
 80031fe:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 8003202:	b289      	uxth	r1, r1
 8003204:	400c      	ands	r4, r1
 8003206:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 800320a:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 800320e:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003212:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 8003216:	0649      	lsls	r1, r1, #25
 8003218:	d50d      	bpl.n	8003236 <USB_ActivateEndpoint+0x116>
 800321a:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 800321e:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 8003222:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 8003226:	0409      	lsls	r1, r1, #16
 8003228:	0c09      	lsrs	r1, r1, #16
 800322a:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 800322e:	f041 01c0 	orr.w	r1, r1, #192	; 0xc0
 8003232:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 8003236:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
      if (ep->type != EP_TYPE_ISOC)
 800323a:	f1be 0f01 	cmp.w	lr, #1
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800323e:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 8003242:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8003246:	ea4f 4101 	mov.w	r1, r1, lsl #16
 800324a:	ea4f 4111 	mov.w	r1, r1, lsr #16
 800324e:	bf18      	it	ne
 8003250:	f081 0120 	eorne.w	r1, r1, #32
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003254:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8003258:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800325c:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8003260:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 8003264:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8003268:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 800326c:	0409      	lsls	r1, r1, #16
 800326e:	0c09      	lsrs	r1, r1, #16
 8003270:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8003274:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8003278:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
}
 800327c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PCD_SET_EP_DBUF(USBx, ep->num);
 800327e:	f833 c022 	ldrh.w	ip, [r3, r2, lsl #2]
 8003282:	eb03 1702 	add.w	r7, r3, r2, lsl #4
 8003286:	fa1f fc8c 	uxth.w	ip, ip
 800328a:	ea0c 0c04 	and.w	ip, ip, r4
 800328e:	f44c 4c01 	orr.w	ip, ip, #33024	; 0x8100
 8003292:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
 8003296:	f823 c022 	strh.w	ip, [r3, r2, lsl #2]
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 800329a:	f8b3 c050 	ldrh.w	ip, [r3, #80]	; 0x50
 800329e:	890e      	ldrh	r6, [r1, #8]
 80032a0:	fa1f fc8c 	uxth.w	ip, ip
 80032a4:	0876      	lsrs	r6, r6, #1
 80032a6:	44bc      	add	ip, r7
 80032a8:	0076      	lsls	r6, r6, #1
 80032aa:	f8ac 6400 	strh.w	r6, [ip, #1024]	; 0x400
 80032ae:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 80032b2:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
 80032b6:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
 80032ba:	b2ad      	uxth	r5, r5
 80032bc:	443d      	add	r5, r7
 80032be:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80032c2:	f8a5 c408 	strh.w	ip, [r5, #1032]	; 0x408
    if (ep->is_in == 0U)
 80032c6:	7849      	ldrb	r1, [r1, #1]
 80032c8:	2900      	cmp	r1, #0
 80032ca:	d194      	bne.n	80031f6 <USB_ActivateEndpoint+0xd6>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80032cc:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80032d0:	044f      	lsls	r7, r1, #17
 80032d2:	d509      	bpl.n	80032e8 <USB_ActivateEndpoint+0x1c8>
 80032d4:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80032d8:	b289      	uxth	r1, r1
 80032da:	400c      	ands	r4, r1
 80032dc:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 80032e0:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 80032e4:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80032e8:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80032ec:	064e      	lsls	r6, r1, #25
 80032ee:	d50d      	bpl.n	800330c <USB_ActivateEndpoint+0x1ec>
 80032f0:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80032f4:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 80032f8:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 80032fc:	0409      	lsls	r1, r1, #16
 80032fe:	0c09      	lsrs	r1, r1, #16
 8003300:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8003304:	f041 01c0 	orr.w	r1, r1, #192	; 0xc0
 8003308:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800330c:	f248 0480 	movw	r4, #32896	; 0x8080
 8003310:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 8003314:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8003318:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 800331c:	0409      	lsls	r1, r1, #16
 800331e:	0c09      	lsrs	r1, r1, #16
 8003320:	f481 5140 	eor.w	r1, r1, #12288	; 0x3000
 8003324:	4321      	orrs	r1, r4
 8003326:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800332a:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 800332e:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 8003332:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8003336:	0409      	lsls	r1, r1, #16
 8003338:	0c09      	lsrs	r1, r1, #16
 800333a:	4321      	orrs	r1, r4
 800333c:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
}
 8003340:	bdf0      	pop	{r4, r5, r6, r7, pc}
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8003342:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
 8003346:	88cd      	ldrh	r5, [r1, #6]
 8003348:	eb03 1702 	add.w	r7, r3, r2, lsl #4
 800334c:	b2a4      	uxth	r4, r4
 800334e:	086d      	lsrs	r5, r5, #1
 8003350:	006d      	lsls	r5, r5, #1
 8003352:	443c      	add	r4, r7
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8003354:	690e      	ldr	r6, [r1, #16]
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8003356:	f8a4 5408 	strh.w	r5, [r4, #1032]	; 0x408
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 800335a:	f8b3 1050 	ldrh.w	r1, [r3, #80]	; 0x50
 800335e:	b289      	uxth	r1, r1
 8003360:	4439      	add	r1, r7
 8003362:	b366      	cbz	r6, 80033be <USB_ActivateEndpoint+0x29e>
 8003364:	2e3e      	cmp	r6, #62	; 0x3e
 8003366:	d83c      	bhi.n	80033e2 <USB_ActivateEndpoint+0x2c2>
 8003368:	0874      	lsrs	r4, r6, #1
 800336a:	07f5      	lsls	r5, r6, #31
 800336c:	bf48      	it	mi
 800336e:	3401      	addmi	r4, #1
 8003370:	02a4      	lsls	r4, r4, #10
 8003372:	b2a4      	uxth	r4, r4
 8003374:	f8a1 440c 	strh.w	r4, [r1, #1036]	; 0x40c
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003378:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 800337c:	0449      	lsls	r1, r1, #17
 800337e:	d50d      	bpl.n	800339c <USB_ActivateEndpoint+0x27c>
 8003380:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 8003384:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 8003388:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 800338c:	0409      	lsls	r1, r1, #16
 800338e:	0c09      	lsrs	r1, r1, #16
 8003390:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 8003394:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8003398:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800339c:	f833 1022 	ldrh.w	r1, [r3, r2, lsl #2]
 80033a0:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 80033a4:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 80033a8:	0409      	lsls	r1, r1, #16
 80033aa:	0c09      	lsrs	r1, r1, #16
 80033ac:	f481 5140 	eor.w	r1, r1, #12288	; 0x3000
 80033b0:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 80033b4:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80033b8:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
}
 80033bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 80033be:	f8b1 440c 	ldrh.w	r4, [r1, #1036]	; 0x40c
 80033c2:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
 80033c6:	0424      	lsls	r4, r4, #16
 80033c8:	0c24      	lsrs	r4, r4, #16
 80033ca:	f8a1 440c 	strh.w	r4, [r1, #1036]	; 0x40c
 80033ce:	f8b1 440c 	ldrh.w	r4, [r1, #1036]	; 0x40c
 80033d2:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 80033d6:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 80033da:	b2a4      	uxth	r4, r4
 80033dc:	f8a1 440c 	strh.w	r4, [r1, #1036]	; 0x40c
 80033e0:	e7ca      	b.n	8003378 <USB_ActivateEndpoint+0x258>
 80033e2:	0975      	lsrs	r5, r6, #5
 80033e4:	06f4      	lsls	r4, r6, #27
 80033e6:	4c07      	ldr	r4, [pc, #28]	; (8003404 <USB_ActivateEndpoint+0x2e4>)
 80033e8:	bf08      	it	eq
 80033ea:	f105 35ff 	addeq.w	r5, r5, #4294967295
 80033ee:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
 80033f2:	b2a4      	uxth	r4, r4
 80033f4:	f8a1 440c 	strh.w	r4, [r1, #1036]	; 0x40c
 80033f8:	e7be      	b.n	8003378 <USB_ActivateEndpoint+0x258>
  switch (ep->type)
 80033fa:	2001      	movs	r0, #1
 80033fc:	e6aa      	b.n	8003154 <USB_ActivateEndpoint+0x34>
 80033fe:	bf00      	nop
 8003400:	ffff8f8f 	.word	0xffff8f8f
 8003404:	ffff8000 	.word	0xffff8000

08003408 <USB_DeactivateEndpoint>:
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->doublebuffer == 0U)
 8003408:	7b0b      	ldrb	r3, [r1, #12]
 800340a:	b9cb      	cbnz	r3, 8003440 <USB_DeactivateEndpoint+0x38>
  {
    if (ep->is_in != 0U)
 800340c:	784b      	ldrb	r3, [r1, #1]
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800340e:	780a      	ldrb	r2, [r1, #0]
    if (ep->is_in != 0U)
 8003410:	2b00      	cmp	r3, #0
 8003412:	f000 80b1 	beq.w	8003578 <USB_DeactivateEndpoint+0x170>
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003416:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800341a:	0659      	lsls	r1, r3, #25
 800341c:	f100 80c5 	bmi.w	80035aa <USB_DeactivateEndpoint+0x1a2>

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003420:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003424:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003428:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800342c:	041b      	lsls	r3, r3, #16
 800342e:	0c1b      	lsrs	r3, r3, #16
 8003430:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003434:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003438:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }

  return HAL_OK;
}
 800343c:	2000      	movs	r0, #0
 800343e:	4770      	bx	lr
    if (ep->is_in == 0U)
 8003440:	784b      	ldrb	r3, [r1, #1]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003442:	780a      	ldrb	r2, [r1, #0]
    if (ep->is_in == 0U)
 8003444:	2b00      	cmp	r3, #0
 8003446:	d14b      	bne.n	80034e0 <USB_DeactivateEndpoint+0xd8>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003448:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800344c:	0459      	lsls	r1, r3, #17
 800344e:	d50d      	bpl.n	800346c <USB_DeactivateEndpoint+0x64>
 8003450:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003454:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003458:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800345c:	041b      	lsls	r3, r3, #16
 800345e:	0c1b      	lsrs	r3, r3, #16
 8003460:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003464:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003468:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800346c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003470:	065b      	lsls	r3, r3, #25
 8003472:	d50d      	bpl.n	8003490 <USB_DeactivateEndpoint+0x88>
 8003474:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003478:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800347c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003480:	041b      	lsls	r3, r3, #16
 8003482:	0c1b      	lsrs	r3, r3, #16
 8003484:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003488:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800348c:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8003490:	f248 0180 	movw	r1, #32896	; 0x8080
      PCD_TX_DTOG(USBx, ep->num);
 8003494:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003498:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800349c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80034a0:	041b      	lsls	r3, r3, #16
 80034a2:	0c1b      	lsrs	r3, r3, #16
 80034a4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80034a8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80034ac:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 80034b0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80034b4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80034b8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80034bc:	041b      	lsls	r3, r3, #16
 80034be:	0c1b      	lsrs	r3, r3, #16
 80034c0:	430b      	orrs	r3, r1
 80034c2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 80034c6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80034ca:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80034ce:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80034d2:	041b      	lsls	r3, r3, #16
 80034d4:	0c1b      	lsrs	r3, r3, #16
 80034d6:	430b      	orrs	r3, r1
 80034d8:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 80034dc:	2000      	movs	r0, #0
 80034de:	4770      	bx	lr
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80034e0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80034e4:	0459      	lsls	r1, r3, #17
 80034e6:	d50d      	bpl.n	8003504 <USB_DeactivateEndpoint+0xfc>
 80034e8:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80034ec:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80034f0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80034f4:	041b      	lsls	r3, r3, #16
 80034f6:	0c1b      	lsrs	r3, r3, #16
 80034f8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80034fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003500:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003504:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003508:	065b      	lsls	r3, r3, #25
 800350a:	d50d      	bpl.n	8003528 <USB_DeactivateEndpoint+0x120>
 800350c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003510:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003514:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003518:	041b      	lsls	r3, r3, #16
 800351a:	0c1b      	lsrs	r3, r3, #16
 800351c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003520:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003524:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003528:	f248 0180 	movw	r1, #32896	; 0x8080
      PCD_RX_DTOG(USBx, ep->num);
 800352c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003530:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003534:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003538:	041b      	lsls	r3, r3, #16
 800353a:	0c1b      	lsrs	r3, r3, #16
 800353c:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003540:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003544:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003548:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800354c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003550:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003554:	041b      	lsls	r3, r3, #16
 8003556:	0c1b      	lsrs	r3, r3, #16
 8003558:	430b      	orrs	r3, r1
 800355a:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800355e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003562:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003566:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800356a:	041b      	lsls	r3, r3, #16
 800356c:	0c1b      	lsrs	r3, r3, #16
 800356e:	430b      	orrs	r3, r1
 8003570:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003574:	2000      	movs	r0, #0
 8003576:	4770      	bx	lr
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003578:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800357c:	045b      	lsls	r3, r3, #17
 800357e:	d50d      	bpl.n	800359c <USB_DeactivateEndpoint+0x194>
 8003580:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003584:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003588:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800358c:	041b      	lsls	r3, r3, #16
 800358e:	0c1b      	lsrs	r3, r3, #16
 8003590:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003594:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003598:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800359c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80035a0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80035a4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80035a8:	e740      	b.n	800342c <USB_DeactivateEndpoint+0x24>
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80035aa:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80035ae:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80035b2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80035b6:	041b      	lsls	r3, r3, #16
 80035b8:	0c1b      	lsrs	r3, r3, #16
 80035ba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80035be:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80035c2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 80035c6:	e72b      	b.n	8003420 <USB_DeactivateEndpoint+0x18>

080035c8 <USB_EPStartXfer>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80035c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t len;
  uint16_t pmabuffer;
  uint16_t wEPVal;

  /* IN endpoint */
  if (ep->is_in == 1U)
 80035cc:	784b      	ldrb	r3, [r1, #1]
{
 80035ce:	4602      	mov	r2, r0
  if (ep->is_in == 1U)
 80035d0:	2b01      	cmp	r3, #1
 80035d2:	d06b      	beq.n	80036ac <USB_EPStartXfer+0xe4>

    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
  }
  else /* OUT endpoint */
  {
    if (ep->doublebuffer == 0U)
 80035d4:	7b08      	ldrb	r0, [r1, #12]
 80035d6:	2800      	cmp	r0, #0
 80035d8:	d037      	beq.n	800364a <USB_EPStartXfer+0x82>
    }
    else
    {
      /* First Transfer Coming From HAL_PCD_EP_Receive & From ISR */
      /* Set the Double buffer counter */
      if (ep->type == EP_TYPE_BULK)
 80035da:	78c8      	ldrb	r0, [r1, #3]
 80035dc:	2802      	cmp	r0, #2
 80035de:	f000 812d 	beq.w	800383c <USB_EPStartXfer+0x274>
            PCD_FreeUserBuffer(USBx, ep->num, 0U);
          }
        }
      }
      /* iso out double */
      else if (ep->type == EP_TYPE_ISOC)
 80035e2:	2801      	cmp	r0, #1
 80035e4:	f040 810a 	bne.w	80037fc <USB_EPStartXfer+0x234>
      {
        /* Multi packet transfer */
        if (ep->xfer_len > ep->maxpacket)
 80035e8:	6988      	ldr	r0, [r1, #24]
 80035ea:	690c      	ldr	r4, [r1, #16]
 80035ec:	42a0      	cmp	r0, r4
          ep->xfer_len -= len;
        }
        else
        {
          len = ep->xfer_len;
          ep->xfer_len = 0U;
 80035ee:	bf94      	ite	ls
 80035f0:	2500      	movls	r5, #0
          ep->xfer_len -= len;
 80035f2:	1b05      	subhi	r5, r0, r4
 80035f4:	618d      	str	r5, [r1, #24]
 80035f6:	bf88      	it	hi
 80035f8:	4620      	movhi	r0, r4
        }
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 80035fa:	2b00      	cmp	r3, #0
 80035fc:	f040 811b 	bne.w	8003836 <USB_EPStartXfer+0x26e>
 8003600:	f8b2 4050 	ldrh.w	r4, [r2, #80]	; 0x50
 8003604:	780b      	ldrb	r3, [r1, #0]
 8003606:	b2a4      	uxth	r4, r4
 8003608:	f202 4504 	addw	r5, r2, #1028	; 0x404
 800360c:	011b      	lsls	r3, r3, #4
 800360e:	442c      	add	r4, r5
 8003610:	2800      	cmp	r0, #0
 8003612:	f000 8251 	beq.w	8003ab8 <USB_EPStartXfer+0x4f0>
 8003616:	283e      	cmp	r0, #62	; 0x3e
 8003618:	f200 80f3 	bhi.w	8003802 <USB_EPStartXfer+0x23a>
 800361c:	0845      	lsrs	r5, r0, #1
 800361e:	462e      	mov	r6, r5
 8003620:	f010 0001 	ands.w	r0, r0, #1
 8003624:	bf18      	it	ne
 8003626:	1c6e      	addne	r6, r5, #1
 8003628:	02b6      	lsls	r6, r6, #10
 800362a:	b2b6      	uxth	r6, r6
 800362c:	52e6      	strh	r6, [r4, r3]
 800362e:	f8b2 4050 	ldrh.w	r4, [r2, #80]	; 0x50
 8003632:	b2a6      	uxth	r6, r4
 8003634:	f202 440c 	addw	r4, r2, #1036	; 0x40c
 8003638:	4434      	add	r4, r6
 800363a:	b100      	cbz	r0, 800363e <USB_EPStartXfer+0x76>
 800363c:	3501      	adds	r5, #1
 800363e:	02ad      	lsls	r5, r5, #10
 8003640:	b2a8      	uxth	r0, r5
 8003642:	52e0      	strh	r0, [r4, r3]
 8003644:	f891 c000 	ldrb.w	ip, [r1]
 8003648:	e01d      	b.n	8003686 <USB_EPStartXfer+0xbe>
      if (ep->xfer_len > ep->maxpacket)
 800364a:	698c      	ldr	r4, [r1, #24]
 800364c:	690b      	ldr	r3, [r1, #16]
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 800364e:	780d      	ldrb	r5, [r1, #0]
      if (ep->xfer_len > ep->maxpacket)
 8003650:	429c      	cmp	r4, r3
        ep->xfer_len -= len;
 8003652:	bf84      	itt	hi
 8003654:	1ae0      	subhi	r0, r4, r3
 8003656:	461c      	movhi	r4, r3
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 8003658:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 800365c:	6188      	str	r0, [r1, #24]
 800365e:	b29b      	uxth	r3, r3
 8003660:	f202 400c 	addw	r0, r2, #1036	; 0x40c
 8003664:	012d      	lsls	r5, r5, #4
 8003666:	4403      	add	r3, r0
 8003668:	2c00      	cmp	r4, #0
 800366a:	f000 80b7 	beq.w	80037dc <USB_EPStartXfer+0x214>
 800366e:	2c3e      	cmp	r4, #62	; 0x3e
 8003670:	f200 8129 	bhi.w	80038c6 <USB_EPStartXfer+0x2fe>
 8003674:	0860      	lsrs	r0, r4, #1
 8003676:	07e4      	lsls	r4, r4, #31
 8003678:	bf48      	it	mi
 800367a:	3001      	addmi	r0, #1
 800367c:	0280      	lsls	r0, r0, #10
 800367e:	b280      	uxth	r0, r0
 8003680:	52e8      	strh	r0, [r5, r3]
 8003682:	f891 c000 	ldrb.w	ip, [r1]
      {
        return HAL_ERROR;
      }
    }

    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8003686:	f832 302c 	ldrh.w	r3, [r2, ip, lsl #2]
  }

  return HAL_OK;
 800368a:	2000      	movs	r0, #0
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800368c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003690:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003694:	041b      	lsls	r3, r3, #16
 8003696:	0c1b      	lsrs	r3, r3, #16
 8003698:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800369c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80036a0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80036a4:	f822 302c 	strh.w	r3, [r2, ip, lsl #2]
}
 80036a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (ep->xfer_len > ep->maxpacket)
 80036ac:	690d      	ldr	r5, [r1, #16]
 80036ae:	6988      	ldr	r0, [r1, #24]
    if (ep->doublebuffer == 0U)
 80036b0:	7b0b      	ldrb	r3, [r1, #12]
 80036b2:	42a8      	cmp	r0, r5
 80036b4:	bf28      	it	cs
 80036b6:	4628      	movcs	r0, r5
 80036b8:	2b00      	cmp	r3, #0
 80036ba:	d05d      	beq.n	8003778 <USB_EPStartXfer+0x1b0>
      if (ep->type == EP_TYPE_BULK)
 80036bc:	78cb      	ldrb	r3, [r1, #3]
 80036be:	2b02      	cmp	r3, #2
 80036c0:	f000 810e 	beq.w	80038e0 <USB_EPStartXfer+0x318>
        PCD_SET_EP_DBUF(USBx, ep->num);
 80036c4:	f891 8000 	ldrb.w	r8, [r1]
        ep->xfer_len_db -= len;
 80036c8:	6a0b      	ldr	r3, [r1, #32]
        PCD_SET_EP_DBUF(USBx, ep->num);
 80036ca:	f832 4028 	ldrh.w	r4, [r2, r8, lsl #2]
        ep->xfer_len_db -= len;
 80036ce:	1a1b      	subs	r3, r3, r0
        PCD_SET_EP_DBUF(USBx, ep->num);
 80036d0:	f424 44e0 	bic.w	r4, r4, #28672	; 0x7000
 80036d4:	f024 0470 	bic.w	r4, r4, #112	; 0x70
 80036d8:	0424      	lsls	r4, r4, #16
 80036da:	0c24      	lsrs	r4, r4, #16
 80036dc:	f444 4401 	orr.w	r4, r4, #33024	; 0x8100
 80036e0:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 80036e4:	f822 4028 	strh.w	r4, [r2, r8, lsl #2]
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 80036e8:	f832 4028 	ldrh.w	r4, [r2, r8, lsl #2]
        ep->xfer_len_db -= len;
 80036ec:	620b      	str	r3, [r1, #32]
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 80036ee:	f014 0f40 	tst.w	r4, #64	; 0x40
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80036f2:	f8b2 4050 	ldrh.w	r4, [r2, #80]	; 0x50
 80036f6:	ea4f 1808 	mov.w	r8, r8, lsl #4
 80036fa:	b2a6      	uxth	r6, r4
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 80036fc:	f000 814a 	beq.w	8003994 <USB_EPStartXfer+0x3cc>
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8003700:	f202 440c 	addw	r4, r2, #1036	; 0x40c
 8003704:	4434      	add	r4, r6
 8003706:	b286      	uxth	r6, r0
 8003708:	f824 6008 	strh.w	r6, [r4, r8]
  uint32_t BaseAddr = (uint32_t)USBx;
  uint32_t i, temp1, temp2;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800370c:	894c      	ldrh	r4, [r1, #10]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 800370e:	3601      	adds	r6, #1
 8003710:	f502 6780 	add.w	r7, r2, #1024	; 0x400

  for (i = n; i != 0U; i--)
 8003714:	0876      	lsrs	r6, r6, #1
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8003716:	f8d1 9014 	ldr.w	r9, [r1, #20]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800371a:	eb07 0444 	add.w	r4, r7, r4, lsl #1
  for (i = n; i != 0U; i--)
 800371e:	d008      	beq.n	8003732 <USB_EPStartXfer+0x16a>
  uint8_t *pBuf = pbUsrBuf;
 8003720:	46cc      	mov	ip, r9
 8003722:	eb04 0686 	add.w	r6, r4, r6, lsl #2
  {
    temp1 = *pBuf;
 8003726:	f83c eb02 	ldrh.w	lr, [ip], #2
    pBuf++;
    temp2 = temp1 | ((uint16_t)((uint16_t) *pBuf << 8));
    *pdwVal = (uint16_t)temp2;
 800372a:	f824 eb04 	strh.w	lr, [r4], #4
  for (i = n; i != 0U; i--)
 800372e:	42a6      	cmp	r6, r4
 8003730:	d1f9      	bne.n	8003726 <USB_EPStartXfer+0x15e>
          ep->xfer_buff += len;
 8003732:	eb09 0400 	add.w	r4, r9, r0
          if (ep->xfer_len_db > ep->maxpacket)
 8003736:	429d      	cmp	r5, r3
          ep->xfer_buff += len;
 8003738:	614c      	str	r4, [r1, #20]
          if (ep->xfer_len_db > ep->maxpacket)
 800373a:	f0c0 81b7 	bcc.w	8003aac <USB_EPStartXfer+0x4e4>
            ep->xfer_len_db = 0U;
 800373e:	2500      	movs	r5, #0
 8003740:	620d      	str	r5, [r1, #32]
          if (len > 0U)
 8003742:	2b00      	cmp	r3, #0
 8003744:	d036      	beq.n	80037b4 <USB_EPStartXfer+0x1ec>
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003746:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 800374a:	b285      	uxth	r5, r0
 800374c:	f202 4004 	addw	r0, r2, #1028	; 0x404
 8003750:	4428      	add	r0, r5
 8003752:	b29d      	uxth	r5, r3
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003754:	462b      	mov	r3, r5
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003756:	f820 5008 	strh.w	r5, [r0, r8]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800375a:	8908      	ldrh	r0, [r1, #8]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 800375c:	3301      	adds	r3, #1
  for (i = n; i != 0U; i--)
 800375e:	085b      	lsrs	r3, r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003760:	eb07 0040 	add.w	r0, r7, r0, lsl #1
  for (i = n; i != 0U; i--)
 8003764:	d026      	beq.n	80037b4 <USB_EPStartXfer+0x1ec>
 8003766:	eb00 0583 	add.w	r5, r0, r3, lsl #2
    temp1 = *pBuf;
 800376a:	f834 3b02 	ldrh.w	r3, [r4], #2
    *pdwVal = (uint16_t)temp2;
 800376e:	f820 3b04 	strh.w	r3, [r0], #4
  for (i = n; i != 0U; i--)
 8003772:	4285      	cmp	r5, r0
 8003774:	d1f9      	bne.n	800376a <USB_EPStartXfer+0x1a2>
 8003776:	e01d      	b.n	80037b4 <USB_EPStartXfer+0x1ec>
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, (uint16_t)len);
 8003778:	b284      	uxth	r4, r0
 800377a:	694b      	ldr	r3, [r1, #20]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800377c:	88cd      	ldrh	r5, [r1, #6]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 800377e:	f104 0e01 	add.w	lr, r4, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003782:	f502 6080 	add.w	r0, r2, #1024	; 0x400
  for (i = n; i != 0U; i--)
 8003786:	ea5f 0e5e 	movs.w	lr, lr, lsr #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800378a:	eb00 0045 	add.w	r0, r0, r5, lsl #1
  for (i = n; i != 0U; i--)
 800378e:	bf18      	it	ne
 8003790:	eb03 0e4e 	addne.w	lr, r3, lr, lsl #1
 8003794:	d005      	beq.n	80037a2 <USB_EPStartXfer+0x1da>
    temp1 = *pBuf;
 8003796:	f833 cb02 	ldrh.w	ip, [r3], #2
  for (i = n; i != 0U; i--)
 800379a:	4573      	cmp	r3, lr
    *pdwVal = (uint16_t)temp2;
 800379c:	f820 cb04 	strh.w	ip, [r0], #4
  for (i = n; i != 0U; i--)
 80037a0:	d1f9      	bne.n	8003796 <USB_EPStartXfer+0x1ce>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 80037a2:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 80037a6:	7808      	ldrb	r0, [r1, #0]
 80037a8:	b29d      	uxth	r5, r3
 80037aa:	f202 4304 	addw	r3, r2, #1028	; 0x404
 80037ae:	0100      	lsls	r0, r0, #4
 80037b0:	442b      	add	r3, r5
 80037b2:	52c4      	strh	r4, [r0, r3]
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 80037b4:	7809      	ldrb	r1, [r1, #0]
  return HAL_OK;
 80037b6:	2000      	movs	r0, #0
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 80037b8:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 80037bc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80037c0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80037c4:	041b      	lsls	r3, r3, #16
 80037c6:	0c1b      	lsrs	r3, r3, #16
 80037c8:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 80037cc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80037d0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80037d4:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
}
 80037d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 80037dc:	5ae8      	ldrh	r0, [r5, r3]
 80037de:	f420 40f8 	bic.w	r0, r0, #31744	; 0x7c00
 80037e2:	0400      	lsls	r0, r0, #16
 80037e4:	0c00      	lsrs	r0, r0, #16
 80037e6:	52e8      	strh	r0, [r5, r3]
 80037e8:	5ae8      	ldrh	r0, [r5, r3]
 80037ea:	ea6f 4040 	mvn.w	r0, r0, lsl #17
 80037ee:	ea6f 4050 	mvn.w	r0, r0, lsr #17
 80037f2:	b280      	uxth	r0, r0
 80037f4:	52e8      	strh	r0, [r5, r3]
 80037f6:	f891 c000 	ldrb.w	ip, [r1]
 80037fa:	e744      	b.n	8003686 <USB_EPStartXfer+0xbe>
        return HAL_ERROR;
 80037fc:	2001      	movs	r0, #1
}
 80037fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8003802:	0945      	lsrs	r5, r0, #5
 8003804:	462f      	mov	r7, r5
 8003806:	f010 001f 	ands.w	r0, r0, #31
 800380a:	bf08      	it	eq
 800380c:	f105 37ff 	addeq.w	r7, r5, #4294967295
 8003810:	462e      	mov	r6, r5
 8003812:	4dbb      	ldr	r5, [pc, #748]	; (8003b00 <USB_EPStartXfer+0x538>)
 8003814:	ea45 2587 	orr.w	r5, r5, r7, lsl #10
 8003818:	b2ad      	uxth	r5, r5
 800381a:	52e5      	strh	r5, [r4, r3]
 800381c:	f8b2 4050 	ldrh.w	r4, [r2, #80]	; 0x50
 8003820:	b2a5      	uxth	r5, r4
 8003822:	f202 440c 	addw	r4, r2, #1036	; 0x40c
 8003826:	442c      	add	r4, r5
 8003828:	b900      	cbnz	r0, 800382c <USB_EPStartXfer+0x264>
 800382a:	3e01      	subs	r6, #1
 800382c:	48b4      	ldr	r0, [pc, #720]	; (8003b00 <USB_EPStartXfer+0x538>)
 800382e:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
 8003832:	b280      	uxth	r0, r0
 8003834:	52e0      	strh	r0, [r4, r3]
 8003836:	f891 c000 	ldrb.w	ip, [r1]
 800383a:	e724      	b.n	8003686 <USB_EPStartXfer+0xbe>
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 800383c:	bb13      	cbnz	r3, 8003884 <USB_EPStartXfer+0x2bc>
 800383e:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8003842:	780b      	ldrb	r3, [r1, #0]
 8003844:	b284      	uxth	r4, r0
 8003846:	f202 4004 	addw	r0, r2, #1028	; 0x404
 800384a:	4420      	add	r0, r4
 800384c:	690c      	ldr	r4, [r1, #16]
 800384e:	011b      	lsls	r3, r3, #4
 8003850:	2c00      	cmp	r4, #0
 8003852:	f000 8109 	beq.w	8003a68 <USB_EPStartXfer+0x4a0>
 8003856:	2c3e      	cmp	r4, #62	; 0x3e
 8003858:	f200 818e 	bhi.w	8003b78 <USB_EPStartXfer+0x5b0>
 800385c:	0865      	lsrs	r5, r4, #1
 800385e:	462e      	mov	r6, r5
 8003860:	f014 0401 	ands.w	r4, r4, #1
 8003864:	bf18      	it	ne
 8003866:	1c6e      	addne	r6, r5, #1
 8003868:	02b6      	lsls	r6, r6, #10
 800386a:	b2b6      	uxth	r6, r6
 800386c:	52c6      	strh	r6, [r0, r3]
 800386e:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8003872:	f202 460c 	addw	r6, r2, #1036	; 0x40c
 8003876:	b280      	uxth	r0, r0
 8003878:	4406      	add	r6, r0
 800387a:	b104      	cbz	r4, 800387e <USB_EPStartXfer+0x2b6>
 800387c:	3501      	adds	r5, #1
 800387e:	02ad      	lsls	r5, r5, #10
 8003880:	b2a8      	uxth	r0, r5
 8003882:	52f0      	strh	r0, [r6, r3]
        if (ep->xfer_count != 0U)
 8003884:	69cb      	ldr	r3, [r1, #28]
 8003886:	2b00      	cmp	r3, #0
 8003888:	d0d5      	beq.n	8003836 <USB_EPStartXfer+0x26e>
          wEPVal = PCD_GET_ENDPOINT(USBx, ep->num);
 800388a:	f244 0340 	movw	r3, #16448	; 0x4040
 800388e:	f891 c000 	ldrb.w	ip, [r1]
 8003892:	f832 002c 	ldrh.w	r0, [r2, ip, lsl #2]
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 8003896:	ea03 0400 	and.w	r4, r3, r0
 800389a:	4383      	bics	r3, r0
 800389c:	d002      	beq.n	80038a4 <USB_EPStartXfer+0x2dc>
 800389e:	2c00      	cmp	r4, #0
 80038a0:	f47f aef1 	bne.w	8003686 <USB_EPStartXfer+0xbe>
            PCD_FreeUserBuffer(USBx, ep->num, 0U);
 80038a4:	f832 302c 	ldrh.w	r3, [r2, ip, lsl #2]
 80038a8:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80038ac:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80038b0:	041b      	lsls	r3, r3, #16
 80038b2:	0c1b      	lsrs	r3, r3, #16
 80038b4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80038b8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80038bc:	f822 302c 	strh.w	r3, [r2, ip, lsl #2]
 80038c0:	f891 c000 	ldrb.w	ip, [r1]
 80038c4:	e6df      	b.n	8003686 <USB_EPStartXfer+0xbe>
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 80038c6:	0966      	lsrs	r6, r4, #5
 80038c8:	06e0      	lsls	r0, r4, #27
 80038ca:	488d      	ldr	r0, [pc, #564]	; (8003b00 <USB_EPStartXfer+0x538>)
 80038cc:	bf08      	it	eq
 80038ce:	f106 36ff 	addeq.w	r6, r6, #4294967295
 80038d2:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
 80038d6:	b280      	uxth	r0, r0
 80038d8:	52e8      	strh	r0, [r5, r3]
 80038da:	f891 c000 	ldrb.w	ip, [r1]
 80038de:	e6d2      	b.n	8003686 <USB_EPStartXfer+0xbe>
        if (ep->xfer_len_db > ep->maxpacket)
 80038e0:	6a0c      	ldr	r4, [r1, #32]
 80038e2:	42a5      	cmp	r5, r4
 80038e4:	f080 8094 	bcs.w	8003a10 <USB_EPStartXfer+0x448>
          PCD_SET_EP_DBUF(USBx, ep->num);
 80038e8:	780e      	ldrb	r6, [r1, #0]
          ep->xfer_len_db -= len;
 80038ea:	1a24      	subs	r4, r4, r0
          PCD_SET_EP_DBUF(USBx, ep->num);
 80038ec:	f832 3026 	ldrh.w	r3, [r2, r6, lsl #2]
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80038f0:	ea4f 1906 	mov.w	r9, r6, lsl #4
          PCD_SET_EP_DBUF(USBx, ep->num);
 80038f4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80038f8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80038fc:	041b      	lsls	r3, r3, #16
 80038fe:	0c1b      	lsrs	r3, r3, #16
 8003900:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8003904:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003908:	f822 3026 	strh.w	r3, [r2, r6, lsl #2]
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800390c:	f832 3026 	ldrh.w	r3, [r2, r6, lsl #2]
          ep->xfer_len_db -= len;
 8003910:	620c      	str	r4, [r1, #32]
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 8003912:	f013 0f40 	tst.w	r3, #64	; 0x40
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8003916:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 800391a:	b29e      	uxth	r6, r3
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800391c:	f000 80f2 	beq.w	8003b04 <USB_EPStartXfer+0x53c>
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8003920:	f202 430c 	addw	r3, r2, #1036	; 0x40c
 8003924:	4433      	add	r3, r6
 8003926:	fa1f fa80 	uxth.w	sl, r0
 800392a:	f823 a009 	strh.w	sl, [r3, r9]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800392e:	894e      	ldrh	r6, [r1, #10]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003930:	f10a 0801 	add.w	r8, sl, #1
 8003934:	f502 6380 	add.w	r3, r2, #1024	; 0x400
  for (i = n; i != 0U; i--)
 8003938:	ea5f 0858 	movs.w	r8, r8, lsr #1
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800393c:	694f      	ldr	r7, [r1, #20]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800393e:	eb03 0646 	add.w	r6, r3, r6, lsl #1
  for (i = n; i != 0U; i--)
 8003942:	d008      	beq.n	8003956 <USB_EPStartXfer+0x38e>
  uint8_t *pBuf = pbUsrBuf;
 8003944:	46bc      	mov	ip, r7
 8003946:	eb06 0b88 	add.w	fp, r6, r8, lsl #2
    temp1 = *pBuf;
 800394a:	f83c eb02 	ldrh.w	lr, [ip], #2
    *pdwVal = (uint16_t)temp2;
 800394e:	f826 eb04 	strh.w	lr, [r6], #4
  for (i = n; i != 0U; i--)
 8003952:	45b3      	cmp	fp, r6
 8003954:	d1f9      	bne.n	800394a <USB_EPStartXfer+0x382>
            ep->xfer_buff += len;
 8003956:	4407      	add	r7, r0
            if (ep->xfer_len_db > ep->maxpacket)
 8003958:	42a5      	cmp	r5, r4
            ep->xfer_buff += len;
 800395a:	614f      	str	r7, [r1, #20]
            if (ep->xfer_len_db > ep->maxpacket)
 800395c:	f080 8127 	bcs.w	8003bae <USB_EPStartXfer+0x5e6>
              ep->xfer_len_db -= len;
 8003960:	1a24      	subs	r4, r4, r0
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003962:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8003966:	620c      	str	r4, [r1, #32]
 8003968:	b284      	uxth	r4, r0
 800396a:	f202 4004 	addw	r0, r2, #1028	; 0x404
 800396e:	4420      	add	r0, r4
 8003970:	f820 a009 	strh.w	sl, [r0, r9]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003974:	8908      	ldrh	r0, [r1, #8]
 8003976:	eb03 0340 	add.w	r3, r3, r0, lsl #1
  for (i = n; i != 0U; i--)
 800397a:	f1b8 0f00 	cmp.w	r8, #0
 800397e:	f43f af19 	beq.w	80037b4 <USB_EPStartXfer+0x1ec>
 8003982:	eb03 0488 	add.w	r4, r3, r8, lsl #2
    temp1 = *pBuf;
 8003986:	f837 0b02 	ldrh.w	r0, [r7], #2
    *pdwVal = (uint16_t)temp2;
 800398a:	f823 0b04 	strh.w	r0, [r3], #4
  for (i = n; i != 0U; i--)
 800398e:	429c      	cmp	r4, r3
 8003990:	d1f9      	bne.n	8003986 <USB_EPStartXfer+0x3be>
 8003992:	e70f      	b.n	80037b4 <USB_EPStartXfer+0x1ec>
          PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003994:	f202 4404 	addw	r4, r2, #1028	; 0x404
 8003998:	4434      	add	r4, r6
 800399a:	b286      	uxth	r6, r0
 800399c:	f824 6008 	strh.w	r6, [r4, r8]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80039a0:	f8b1 c008 	ldrh.w	ip, [r1, #8]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 80039a4:	3601      	adds	r6, #1
 80039a6:	f502 6780 	add.w	r7, r2, #1024	; 0x400
  for (i = n; i != 0U; i--)
 80039aa:	0876      	lsrs	r6, r6, #1
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80039ac:	f8d1 9014 	ldr.w	r9, [r1, #20]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80039b0:	eb07 0c4c 	add.w	ip, r7, ip, lsl #1
  for (i = n; i != 0U; i--)
 80039b4:	d008      	beq.n	80039c8 <USB_EPStartXfer+0x400>
  uint8_t *pBuf = pbUsrBuf;
 80039b6:	464c      	mov	r4, r9
 80039b8:	eb09 0646 	add.w	r6, r9, r6, lsl #1
    temp1 = *pBuf;
 80039bc:	f834 eb02 	ldrh.w	lr, [r4], #2
  for (i = n; i != 0U; i--)
 80039c0:	42b4      	cmp	r4, r6
    *pdwVal = (uint16_t)temp2;
 80039c2:	f82c eb04 	strh.w	lr, [ip], #4
  for (i = n; i != 0U; i--)
 80039c6:	d1f9      	bne.n	80039bc <USB_EPStartXfer+0x3f4>
          ep->xfer_buff += len;
 80039c8:	eb09 0400 	add.w	r4, r9, r0
          if (ep->xfer_len_db > ep->maxpacket)
 80039cc:	429d      	cmp	r5, r3
          ep->xfer_buff += len;
 80039ce:	614c      	str	r4, [r1, #20]
          if (ep->xfer_len_db > ep->maxpacket)
 80039d0:	d36f      	bcc.n	8003ab2 <USB_EPStartXfer+0x4ea>
            ep->xfer_len_db = 0U;
 80039d2:	2500      	movs	r5, #0
 80039d4:	620d      	str	r5, [r1, #32]
          if (len > 0U)
 80039d6:	2b00      	cmp	r3, #0
 80039d8:	f43f aeec 	beq.w	80037b4 <USB_EPStartXfer+0x1ec>
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80039dc:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 80039e0:	b285      	uxth	r5, r0
 80039e2:	f202 400c 	addw	r0, r2, #1036	; 0x40c
 80039e6:	4428      	add	r0, r5
 80039e8:	b29d      	uxth	r5, r3
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 80039ea:	462b      	mov	r3, r5
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80039ec:	f820 5008 	strh.w	r5, [r0, r8]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80039f0:	8948      	ldrh	r0, [r1, #10]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 80039f2:	3301      	adds	r3, #1
  for (i = n; i != 0U; i--)
 80039f4:	085b      	lsrs	r3, r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80039f6:	eb07 0740 	add.w	r7, r7, r0, lsl #1
  for (i = n; i != 0U; i--)
 80039fa:	f43f aedb 	beq.w	80037b4 <USB_EPStartXfer+0x1ec>
 80039fe:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    temp1 = *pBuf;
 8003a02:	f834 0b02 	ldrh.w	r0, [r4], #2
    *pdwVal = (uint16_t)temp2;
 8003a06:	f827 0b04 	strh.w	r0, [r7], #4
  for (i = n; i != 0U; i--)
 8003a0a:	429f      	cmp	r7, r3
 8003a0c:	d1f9      	bne.n	8003a02 <USB_EPStartXfer+0x43a>
 8003a0e:	e6d1      	b.n	80037b4 <USB_EPStartXfer+0x1ec>
          PCD_CLEAR_EP_DBUF(USBx, ep->num);
 8003a10:	7808      	ldrb	r0, [r1, #0]
 8003a12:	f832 3020 	ldrh.w	r3, [r2, r0, lsl #2]
 8003a16:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
 8003a1a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003a1e:	041b      	lsls	r3, r3, #16
 8003a20:	0c1b      	lsrs	r3, r3, #16
 8003a22:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003a26:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003a2a:	f822 3020 	strh.w	r3, [r2, r0, lsl #2]
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8003a2e:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8003a32:	0100      	lsls	r0, r0, #4
 8003a34:	b29d      	uxth	r5, r3
 8003a36:	f202 4304 	addw	r3, r2, #1028	; 0x404
 8003a3a:	442b      	add	r3, r5
 8003a3c:	b2a5      	uxth	r5, r4
 8003a3e:	521d      	strh	r5, [r3, r0]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003a40:	b2a0      	uxth	r0, r4
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003a42:	890d      	ldrh	r5, [r1, #8]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003a44:	3001      	adds	r0, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003a46:	f502 6380 	add.w	r3, r2, #1024	; 0x400
  for (i = n; i != 0U; i--)
 8003a4a:	0840      	lsrs	r0, r0, #1
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8003a4c:	694c      	ldr	r4, [r1, #20]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003a4e:	eb03 0345 	add.w	r3, r3, r5, lsl #1
  for (i = n; i != 0U; i--)
 8003a52:	f43f aeaf 	beq.w	80037b4 <USB_EPStartXfer+0x1ec>
 8003a56:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    temp1 = *pBuf;
 8003a5a:	f834 5b02 	ldrh.w	r5, [r4], #2
    *pdwVal = (uint16_t)temp2;
 8003a5e:	f823 5b04 	strh.w	r5, [r3], #4
  for (i = n; i != 0U; i--)
 8003a62:	4298      	cmp	r0, r3
 8003a64:	d1f9      	bne.n	8003a5a <USB_EPStartXfer+0x492>
 8003a66:	e6a5      	b.n	80037b4 <USB_EPStartXfer+0x1ec>
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 8003a68:	5ac4      	ldrh	r4, [r0, r3]
 8003a6a:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
 8003a6e:	0424      	lsls	r4, r4, #16
 8003a70:	0c24      	lsrs	r4, r4, #16
 8003a72:	52c4      	strh	r4, [r0, r3]
 8003a74:	5ac5      	ldrh	r5, [r0, r3]
 8003a76:	f202 440c 	addw	r4, r2, #1036	; 0x40c
 8003a7a:	ea6f 4545 	mvn.w	r5, r5, lsl #17
 8003a7e:	ea6f 4555 	mvn.w	r5, r5, lsr #17
 8003a82:	b2ad      	uxth	r5, r5
 8003a84:	52c5      	strh	r5, [r0, r3]
 8003a86:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8003a8a:	b285      	uxth	r5, r0
 8003a8c:	4620      	mov	r0, r4
 8003a8e:	4428      	add	r0, r5
 8003a90:	5ac4      	ldrh	r4, [r0, r3]
 8003a92:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
 8003a96:	0424      	lsls	r4, r4, #16
 8003a98:	0c24      	lsrs	r4, r4, #16
 8003a9a:	52c4      	strh	r4, [r0, r3]
 8003a9c:	5ac4      	ldrh	r4, [r0, r3]
 8003a9e:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 8003aa2:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8003aa6:	b2a4      	uxth	r4, r4
 8003aa8:	52c4      	strh	r4, [r0, r3]
 8003aaa:	e6eb      	b.n	8003884 <USB_EPStartXfer+0x2bc>
            ep->xfer_len_db -= len;
 8003aac:	1a1d      	subs	r5, r3, r0
 8003aae:	4603      	mov	r3, r0
 8003ab0:	e646      	b.n	8003740 <USB_EPStartXfer+0x178>
            ep->xfer_len_db -= len;
 8003ab2:	1a1d      	subs	r5, r3, r0
 8003ab4:	4603      	mov	r3, r0
 8003ab6:	e78d      	b.n	80039d4 <USB_EPStartXfer+0x40c>
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8003ab8:	5ae0      	ldrh	r0, [r4, r3]
 8003aba:	f420 40f8 	bic.w	r0, r0, #31744	; 0x7c00
 8003abe:	0400      	lsls	r0, r0, #16
 8003ac0:	0c00      	lsrs	r0, r0, #16
 8003ac2:	52e0      	strh	r0, [r4, r3]
 8003ac4:	5ae5      	ldrh	r5, [r4, r3]
 8003ac6:	f202 400c 	addw	r0, r2, #1036	; 0x40c
 8003aca:	ea6f 4545 	mvn.w	r5, r5, lsl #17
 8003ace:	ea6f 4555 	mvn.w	r5, r5, lsr #17
 8003ad2:	b2ad      	uxth	r5, r5
 8003ad4:	52e5      	strh	r5, [r4, r3]
 8003ad6:	f8b2 4050 	ldrh.w	r4, [r2, #80]	; 0x50
 8003ada:	b2a4      	uxth	r4, r4
 8003adc:	4420      	add	r0, r4
 8003ade:	5ac4      	ldrh	r4, [r0, r3]
 8003ae0:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
 8003ae4:	0424      	lsls	r4, r4, #16
 8003ae6:	0c24      	lsrs	r4, r4, #16
 8003ae8:	52c4      	strh	r4, [r0, r3]
 8003aea:	5ac4      	ldrh	r4, [r0, r3]
 8003aec:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 8003af0:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8003af4:	b2a4      	uxth	r4, r4
 8003af6:	52c4      	strh	r4, [r0, r3]
 8003af8:	f891 c000 	ldrb.w	ip, [r1]
 8003afc:	e5c3      	b.n	8003686 <USB_EPStartXfer+0xbe>
 8003afe:	bf00      	nop
 8003b00:	ffff8000 	.word	0xffff8000
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003b04:	f202 4304 	addw	r3, r2, #1028	; 0x404
 8003b08:	4433      	add	r3, r6
 8003b0a:	fa1f fa80 	uxth.w	sl, r0
 8003b0e:	f823 a009 	strh.w	sl, [r3, r9]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003b12:	f8b1 c008 	ldrh.w	ip, [r1, #8]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003b16:	f10a 0801 	add.w	r8, sl, #1
 8003b1a:	f502 6380 	add.w	r3, r2, #1024	; 0x400
  for (i = n; i != 0U; i--)
 8003b1e:	ea5f 0858 	movs.w	r8, r8, lsr #1
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8003b22:	694f      	ldr	r7, [r1, #20]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003b24:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
  for (i = n; i != 0U; i--)
 8003b28:	d008      	beq.n	8003b3c <USB_EPStartXfer+0x574>
  uint8_t *pBuf = pbUsrBuf;
 8003b2a:	463e      	mov	r6, r7
 8003b2c:	eb07 0b48 	add.w	fp, r7, r8, lsl #1
    temp1 = *pBuf;
 8003b30:	f836 eb02 	ldrh.w	lr, [r6], #2
  for (i = n; i != 0U; i--)
 8003b34:	45b3      	cmp	fp, r6
    *pdwVal = (uint16_t)temp2;
 8003b36:	f82c eb04 	strh.w	lr, [ip], #4
  for (i = n; i != 0U; i--)
 8003b3a:	d1f9      	bne.n	8003b30 <USB_EPStartXfer+0x568>
            ep->xfer_buff += len;
 8003b3c:	4407      	add	r7, r0
            if (ep->xfer_len_db > ep->maxpacket)
 8003b3e:	42a5      	cmp	r5, r4
            ep->xfer_buff += len;
 8003b40:	614f      	str	r7, [r1, #20]
            if (ep->xfer_len_db > ep->maxpacket)
 8003b42:	d23e      	bcs.n	8003bc2 <USB_EPStartXfer+0x5fa>
              ep->xfer_len_db -= len;
 8003b44:	1a24      	subs	r4, r4, r0
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8003b46:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8003b4a:	620c      	str	r4, [r1, #32]
 8003b4c:	b284      	uxth	r4, r0
 8003b4e:	f202 400c 	addw	r0, r2, #1036	; 0x40c
 8003b52:	4420      	add	r0, r4
 8003b54:	f820 a009 	strh.w	sl, [r0, r9]
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003b58:	8948      	ldrh	r0, [r1, #10]
 8003b5a:	eb03 0340 	add.w	r3, r3, r0, lsl #1
  for (i = n; i != 0U; i--)
 8003b5e:	f1b8 0f00 	cmp.w	r8, #0
 8003b62:	f43f ae27 	beq.w	80037b4 <USB_EPStartXfer+0x1ec>
 8003b66:	eb03 0488 	add.w	r4, r3, r8, lsl #2
    temp1 = *pBuf;
 8003b6a:	f837 0b02 	ldrh.w	r0, [r7], #2
    *pdwVal = (uint16_t)temp2;
 8003b6e:	f823 0b04 	strh.w	r0, [r3], #4
  for (i = n; i != 0U; i--)
 8003b72:	429c      	cmp	r4, r3
 8003b74:	d1f9      	bne.n	8003b6a <USB_EPStartXfer+0x5a2>
 8003b76:	e61d      	b.n	80037b4 <USB_EPStartXfer+0x1ec>
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 8003b78:	0965      	lsrs	r5, r4, #5
 8003b7a:	462f      	mov	r7, r5
 8003b7c:	f014 041f 	ands.w	r4, r4, #31
 8003b80:	bf08      	it	eq
 8003b82:	f105 37ff 	addeq.w	r7, r5, #4294967295
 8003b86:	462e      	mov	r6, r5
 8003b88:	4d13      	ldr	r5, [pc, #76]	; (8003bd8 <USB_EPStartXfer+0x610>)
 8003b8a:	ea45 2587 	orr.w	r5, r5, r7, lsl #10
 8003b8e:	b2ad      	uxth	r5, r5
 8003b90:	52c5      	strh	r5, [r0, r3]
 8003b92:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8003b96:	f202 450c 	addw	r5, r2, #1036	; 0x40c
 8003b9a:	b280      	uxth	r0, r0
 8003b9c:	4405      	add	r5, r0
 8003b9e:	b904      	cbnz	r4, 8003ba2 <USB_EPStartXfer+0x5da>
 8003ba0:	3e01      	subs	r6, #1
 8003ba2:	480d      	ldr	r0, [pc, #52]	; (8003bd8 <USB_EPStartXfer+0x610>)
 8003ba4:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
 8003ba8:	b280      	uxth	r0, r0
 8003baa:	52e8      	strh	r0, [r5, r3]
 8003bac:	e66a      	b.n	8003884 <USB_EPStartXfer+0x2bc>
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003bae:	fa1f f884 	uxth.w	r8, r4
 8003bb2:	f108 0801 	add.w	r8, r8, #1
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003bb6:	fa1f fa84 	uxth.w	sl, r4
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003bba:	ea4f 0858 	mov.w	r8, r8, lsr #1
              ep->xfer_len_db = 0U;
 8003bbe:	2400      	movs	r4, #0
 8003bc0:	e6cf      	b.n	8003962 <USB_EPStartXfer+0x39a>
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003bc2:	fa1f f884 	uxth.w	r8, r4
 8003bc6:	f108 0801 	add.w	r8, r8, #1
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8003bca:	fa1f fa84 	uxth.w	sl, r4
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003bce:	ea4f 0858 	mov.w	r8, r8, lsr #1
              ep->xfer_len_db = 0U;
 8003bd2:	2400      	movs	r4, #0
 8003bd4:	e7b7      	b.n	8003b46 <USB_EPStartXfer+0x57e>
 8003bd6:	bf00      	nop
 8003bd8:	ffff8000 	.word	0xffff8000

08003bdc <USB_EPSetStall>:
  if (ep->is_in != 0U)
 8003bdc:	784b      	ldrb	r3, [r1, #1]
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 8003bde:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in != 0U)
 8003be0:	b18b      	cbz	r3, 8003c06 <USB_EPSetStall+0x2a>
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 8003be2:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003be6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003bea:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003bee:	041b      	lsls	r3, r3, #16
 8003bf0:	0c1b      	lsrs	r3, r3, #16
 8003bf2:	f083 0310 	eor.w	r3, r3, #16
 8003bf6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003bfa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003bfe:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003c02:	2000      	movs	r0, #0
 8003c04:	4770      	bx	lr
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 8003c06:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003c0a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003c0e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003c12:	041b      	lsls	r3, r3, #16
 8003c14:	0c1b      	lsrs	r3, r3, #16
 8003c16:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8003c1a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003c1e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003c22:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003c26:	2000      	movs	r0, #0
 8003c28:	4770      	bx	lr
 8003c2a:	bf00      	nop

08003c2c <USB_EPClearStall>:
  if (ep->doublebuffer == 0U)
 8003c2c:	7b0b      	ldrb	r3, [r1, #12]
 8003c2e:	bb3b      	cbnz	r3, 8003c80 <USB_EPClearStall+0x54>
    if (ep->is_in != 0U)
 8003c30:	784b      	ldrb	r3, [r1, #1]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003c32:	780a      	ldrb	r2, [r1, #0]
    if (ep->is_in != 0U)
 8003c34:	b333      	cbz	r3, 8003c84 <USB_EPClearStall+0x58>
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003c36:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003c3a:	065b      	lsls	r3, r3, #25
 8003c3c:	d50d      	bpl.n	8003c5a <USB_EPClearStall+0x2e>
 8003c3e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003c42:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003c46:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003c4a:	041b      	lsls	r3, r3, #16
 8003c4c:	0c1b      	lsrs	r3, r3, #16
 8003c4e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003c52:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003c56:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      if (ep->type != EP_TYPE_ISOC)
 8003c5a:	78cb      	ldrb	r3, [r1, #3]
 8003c5c:	2b01      	cmp	r3, #1
 8003c5e:	d00f      	beq.n	8003c80 <USB_EPClearStall+0x54>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 8003c60:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003c64:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003c68:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003c6c:	041b      	lsls	r3, r3, #16
 8003c6e:	0c1b      	lsrs	r3, r3, #16
 8003c70:	f083 0320 	eor.w	r3, r3, #32
 8003c74:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003c78:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003c7c:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003c80:	2000      	movs	r0, #0
 8003c82:	4770      	bx	lr
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003c84:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003c88:	045b      	lsls	r3, r3, #17
 8003c8a:	d50d      	bpl.n	8003ca8 <USB_EPClearStall+0x7c>
 8003c8c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003c90:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003c94:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003c98:	041b      	lsls	r3, r3, #16
 8003c9a:	0c1b      	lsrs	r3, r3, #16
 8003c9c:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003ca0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003ca4:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8003ca8:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003cac:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003cb0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003cb4:	041b      	lsls	r3, r3, #16
 8003cb6:	0c1b      	lsrs	r3, r3, #16
 8003cb8:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8003cbc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003cc0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003cc4:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003cc8:	2000      	movs	r0, #0
 8003cca:	4770      	bx	lr

08003ccc <USB_SetDevAddress>:
  if (address == 0U)
 8003ccc:	b911      	cbnz	r1, 8003cd4 <USB_SetDevAddress+0x8>
    USBx->DADDR = (uint16_t)USB_DADDR_EF;
 8003cce:	2380      	movs	r3, #128	; 0x80
 8003cd0:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
}
 8003cd4:	2000      	movs	r0, #0
 8003cd6:	4770      	bx	lr

08003cd8 <USB_DevConnect>:
 8003cd8:	2000      	movs	r0, #0
 8003cda:	4770      	bx	lr

08003cdc <USB_DevDisconnect>:
 8003cdc:	2000      	movs	r0, #0
 8003cde:	4770      	bx	lr

08003ce0 <USB_ReadInterrupts>:
  tmpreg = USBx->ISTR;
 8003ce0:	f8b0 0044 	ldrh.w	r0, [r0, #68]	; 0x44
}
 8003ce4:	b280      	uxth	r0, r0
 8003ce6:	4770      	bx	lr

08003ce8 <USB_EP0_OutStart>:
}
 8003ce8:	2000      	movs	r0, #0
 8003cea:	4770      	bx	lr

08003cec <USB_WritePMA>:
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 8003cec:	3301      	adds	r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003cee:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  for (i = n; i != 0U; i--)
 8003cf2:	085b      	lsrs	r3, r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003cf4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  for (i = n; i != 0U; i--)
 8003cf8:	d007      	beq.n	8003d0a <USB_WritePMA+0x1e>
 8003cfa:	eb02 0083 	add.w	r0, r2, r3, lsl #2
    temp2 = temp1 | ((uint16_t)((uint16_t) *pBuf << 8));
 8003cfe:	f831 3b02 	ldrh.w	r3, [r1], #2
    *pdwVal = (uint16_t)temp2;
 8003d02:	f822 3b04 	strh.w	r3, [r2], #4
  for (i = n; i != 0U; i--)
 8003d06:	4282      	cmp	r2, r0
 8003d08:	d1f9      	bne.n	8003cfe <USB_WritePMA+0x12>
    pdwVal++;
#endif

    pBuf++;
  }
}
 8003d0a:	4770      	bx	lr

08003d0c <USB_ReadPMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8003d0c:	b570      	push	{r4, r5, r6, lr}
  uint32_t BaseAddr = (uint32_t)USBx;
  uint32_t i, temp;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003d0e:	eb00 0042 	add.w	r0, r0, r2, lsl #1

  for (i = n; i != 0U; i--)
 8003d12:	085e      	lsrs	r6, r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003d14:	f500 6580 	add.w	r5, r0, #1024	; 0x400
  for (i = n; i != 0U; i--)
 8003d18:	d012      	beq.n	8003d40 <USB_ReadPMA+0x34>
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8003d1a:	46ae      	mov	lr, r5
  for (i = n; i != 0U; i--)
 8003d1c:	46b4      	mov	ip, r6
 8003d1e:	1c88      	adds	r0, r1, #2
  {
    temp = *(__IO uint16_t *)pdwVal;
 8003d20:	f83e 2b04 	ldrh.w	r2, [lr], #4
  for (i = n; i != 0U; i--)
 8003d24:	3002      	adds	r0, #2
    temp = *(__IO uint16_t *)pdwVal;
 8003d26:	b292      	uxth	r2, r2
    pdwVal++;
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
    pBuf++;
    *pBuf = (uint8_t)((temp >> 8) & 0xFFU);
 8003d28:	0a14      	lsrs	r4, r2, #8
  for (i = n; i != 0U; i--)
 8003d2a:	f1bc 0c01 	subs.w	ip, ip, #1
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 8003d2e:	f800 2c04 	strb.w	r2, [r0, #-4]
    *pBuf = (uint8_t)((temp >> 8) & 0xFFU);
 8003d32:	f800 4c03 	strb.w	r4, [r0, #-3]
  for (i = n; i != 0U; i--)
 8003d36:	d1f3      	bne.n	8003d20 <USB_ReadPMA+0x14>
    pBuf++;
 8003d38:	eb01 0146 	add.w	r1, r1, r6, lsl #1

#if PMA_ACCESS > 1U
    pdwVal++;
 8003d3c:	eb05 0586 	add.w	r5, r5, r6, lsl #2
#endif
  }

  if ((wNBytes % 2U) != 0U)
 8003d40:	07db      	lsls	r3, r3, #31
  {
    temp = *pdwVal;
 8003d42:	bf44      	itt	mi
 8003d44:	882b      	ldrhmi	r3, [r5, #0]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 8003d46:	700b      	strbmi	r3, [r1, #0]
  }
}
 8003d48:	bd70      	pop	{r4, r5, r6, pc}
 8003d4a:	bf00      	nop

08003d4c <USBD_MSC_GetHSCfgDesc>:
*         return configuration descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t *USBD_MSC_GetHSCfgDesc(uint16_t *length)
{
 8003d4c:	4603      	mov	r3, r0
  *length = sizeof(USBD_MSC_CfgHSDesc);
 8003d4e:	2220      	movs	r2, #32

  return USBD_MSC_CfgHSDesc;
}
 8003d50:	4801      	ldr	r0, [pc, #4]	; (8003d58 <USBD_MSC_GetHSCfgDesc+0xc>)
  *length = sizeof(USBD_MSC_CfgHSDesc);
 8003d52:	801a      	strh	r2, [r3, #0]
}
 8003d54:	4770      	bx	lr
 8003d56:	bf00      	nop
 8003d58:	20000064 	.word	0x20000064

08003d5c <USBD_MSC_GetFSCfgDesc>:
*         return configuration descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t *USBD_MSC_GetFSCfgDesc(uint16_t *length)
{
 8003d5c:	4603      	mov	r3, r0
  *length = sizeof(USBD_MSC_CfgFSDesc);
 8003d5e:	2220      	movs	r2, #32

  return USBD_MSC_CfgFSDesc;
}
 8003d60:	4801      	ldr	r0, [pc, #4]	; (8003d68 <USBD_MSC_GetFSCfgDesc+0xc>)
  *length = sizeof(USBD_MSC_CfgFSDesc);
 8003d62:	801a      	strh	r2, [r3, #0]
}
 8003d64:	4770      	bx	lr
 8003d66:	bf00      	nop
 8003d68:	20000044 	.word	0x20000044

08003d6c <USBD_MSC_GetOtherSpeedCfgDesc>:
*         return other speed configuration descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t *USBD_MSC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 8003d6c:	4603      	mov	r3, r0
  *length = sizeof(USBD_MSC_OtherSpeedCfgDesc);
 8003d6e:	2220      	movs	r2, #32

  return USBD_MSC_OtherSpeedCfgDesc;
}
 8003d70:	4801      	ldr	r0, [pc, #4]	; (8003d78 <USBD_MSC_GetOtherSpeedCfgDesc+0xc>)
  *length = sizeof(USBD_MSC_OtherSpeedCfgDesc);
 8003d72:	801a      	strh	r2, [r3, #0]
}
 8003d74:	4770      	bx	lr
 8003d76:	bf00      	nop
 8003d78:	20000090 	.word	0x20000090

08003d7c <USBD_MSC_GetDeviceQualifierDescriptor>:
*         return Device Qualifier descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t *USBD_MSC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 8003d7c:	4603      	mov	r3, r0
  *length = sizeof(USBD_MSC_DeviceQualifierDesc);
 8003d7e:	220a      	movs	r2, #10

  return USBD_MSC_DeviceQualifierDesc;
}
 8003d80:	4801      	ldr	r0, [pc, #4]	; (8003d88 <USBD_MSC_GetDeviceQualifierDescriptor+0xc>)
  *length = sizeof(USBD_MSC_DeviceQualifierDesc);
 8003d82:	801a      	strh	r2, [r3, #0]
}
 8003d84:	4770      	bx	lr
 8003d86:	bf00      	nop
 8003d88:	20000084 	.word	0x20000084

08003d8c <USBD_MSC_Init>:
{
 8003d8c:	b538      	push	{r3, r4, r5, lr}
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003d8e:	7c03      	ldrb	r3, [r0, #16]
{
 8003d90:	4604      	mov	r4, r0
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003d92:	b9e3      	cbnz	r3, 8003dce <USBD_MSC_Init+0x42>
    USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
 8003d94:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003d98:	2202      	movs	r2, #2
 8003d9a:	2101      	movs	r1, #1
 8003d9c:	f001 fc40 	bl	8005620 <USBD_LL_OpenEP>
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 8003da0:	2501      	movs	r5, #1
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
 8003da2:	f44f 7300 	mov.w	r3, #512	; 0x200
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 8003da6:	2202      	movs	r2, #2
 8003da8:	2181      	movs	r1, #129	; 0x81
 8003daa:	4620      	mov	r0, r4
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 8003dac:	f8c4 516c 	str.w	r5, [r4, #364]	; 0x16c
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 8003db0:	f001 fc36 	bl	8005620 <USBD_LL_OpenEP>
  pdev->pClassData = USBD_malloc(sizeof(USBD_MSC_BOT_HandleTypeDef));
 8003db4:	f44f 70b6 	mov.w	r0, #364	; 0x16c
    pdev->ep_in[MSC_EPIN_ADDR & 0xFU].is_used = 1U;
 8003db8:	62e5      	str	r5, [r4, #44]	; 0x2c
  pdev->pClassData = USBD_malloc(sizeof(USBD_MSC_BOT_HandleTypeDef));
 8003dba:	f001 fcbb 	bl	8005734 <USBD_static_malloc>
 8003dbe:	f8c4 02b8 	str.w	r0, [r4, #696]	; 0x2b8
  if (pdev->pClassData == NULL)
 8003dc2:	b160      	cbz	r0, 8003dde <USBD_MSC_Init+0x52>
  MSC_BOT_Init(pdev);
 8003dc4:	4620      	mov	r0, r4
 8003dc6:	f000 f8f3 	bl	8003fb0 <MSC_BOT_Init>
  return USBD_OK;
 8003dca:	2000      	movs	r0, #0
}
 8003dcc:	bd38      	pop	{r3, r4, r5, pc}
    USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 8003dce:	2340      	movs	r3, #64	; 0x40
 8003dd0:	2202      	movs	r2, #2
 8003dd2:	2101      	movs	r1, #1
 8003dd4:	f001 fc24 	bl	8005620 <USBD_LL_OpenEP>
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 8003dd8:	2501      	movs	r5, #1
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 8003dda:	2340      	movs	r3, #64	; 0x40
 8003ddc:	e7e3      	b.n	8003da6 <USBD_MSC_Init+0x1a>
    return USBD_FAIL;
 8003dde:	2002      	movs	r0, #2
}
 8003de0:	bd38      	pop	{r3, r4, r5, pc}
 8003de2:	bf00      	nop

08003de4 <USBD_MSC_DeInit>:
{
 8003de4:	b538      	push	{r3, r4, r5, lr}
 8003de6:	4604      	mov	r4, r0
  pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 0U;
 8003de8:	2500      	movs	r5, #0
  USBD_LL_CloseEP(pdev, MSC_EPOUT_ADDR);
 8003dea:	2101      	movs	r1, #1
 8003dec:	f001 fc28 	bl	8005640 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev, MSC_EPIN_ADDR);
 8003df0:	2181      	movs	r1, #129	; 0x81
 8003df2:	4620      	mov	r0, r4
  pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 0U;
 8003df4:	f8c4 516c 	str.w	r5, [r4, #364]	; 0x16c
  USBD_LL_CloseEP(pdev, MSC_EPIN_ADDR);
 8003df8:	f001 fc22 	bl	8005640 <USBD_LL_CloseEP>
  MSC_BOT_DeInit(pdev);
 8003dfc:	4620      	mov	r0, r4
  pdev->ep_in[MSC_EPIN_ADDR & 0xFU].is_used = 0U;
 8003dfe:	62e5      	str	r5, [r4, #44]	; 0x2c
  MSC_BOT_DeInit(pdev);
 8003e00:	f000 f900 	bl	8004004 <MSC_BOT_DeInit>
  if (pdev->pClassData != NULL)
 8003e04:	f8d4 02b8 	ldr.w	r0, [r4, #696]	; 0x2b8
 8003e08:	b118      	cbz	r0, 8003e12 <USBD_MSC_DeInit+0x2e>
    USBD_free(pdev->pClassData);
 8003e0a:	f001 fc97 	bl	800573c <USBD_static_free>
    pdev->pClassData  = NULL;
 8003e0e:	f8c4 52b8 	str.w	r5, [r4, #696]	; 0x2b8
}
 8003e12:	2000      	movs	r0, #0
 8003e14:	bd38      	pop	{r3, r4, r5, pc}
 8003e16:	bf00      	nop

08003e18 <USBD_MSC_Setup>:
  uint16_t status_info = 0U;
 8003e18:	2300      	movs	r3, #0
{
 8003e1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003e1e:	b082      	sub	sp, #8
  uint16_t status_info = 0U;
 8003e20:	f8ad 3006 	strh.w	r3, [sp, #6]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8003e24:	780b      	ldrb	r3, [r1, #0]
{
 8003e26:	460c      	mov	r4, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8003e28:	f013 0660 	ands.w	r6, r3, #96	; 0x60
{
 8003e2c:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
 8003e2e:	f8d0 72b8 	ldr.w	r7, [r0, #696]	; 0x2b8
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8003e32:	d01f      	beq.n	8003e74 <USBD_MSC_Setup+0x5c>
 8003e34:	2e20      	cmp	r6, #32
 8003e36:	d114      	bne.n	8003e62 <USBD_MSC_Setup+0x4a>
      switch (req->bRequest)
 8003e38:	784a      	ldrb	r2, [r1, #1]
 8003e3a:	2afe      	cmp	r2, #254	; 0xfe
 8003e3c:	d00a      	beq.n	8003e54 <USBD_MSC_Setup+0x3c>
 8003e3e:	2aff      	cmp	r2, #255	; 0xff
 8003e40:	d10f      	bne.n	8003e62 <USBD_MSC_Setup+0x4a>
          if ((req->wValue  == 0U) && (req->wLength == 0U) &&
 8003e42:	884a      	ldrh	r2, [r1, #2]
 8003e44:	b96a      	cbnz	r2, 8003e62 <USBD_MSC_Setup+0x4a>
 8003e46:	88ce      	ldrh	r6, [r1, #6]
 8003e48:	b95e      	cbnz	r6, 8003e62 <USBD_MSC_Setup+0x4a>
 8003e4a:	061b      	lsls	r3, r3, #24
 8003e4c:	d409      	bmi.n	8003e62 <USBD_MSC_Setup+0x4a>
            MSC_BOT_Reset(pdev);
 8003e4e:	f000 f8cd 	bl	8003fec <MSC_BOT_Reset>
 8003e52:	e00b      	b.n	8003e6c <USBD_MSC_Setup+0x54>
          if ((req->wValue  == 0U) && (req->wLength == 1U) &&
 8003e54:	884e      	ldrh	r6, [r1, #2]
 8003e56:	b926      	cbnz	r6, 8003e62 <USBD_MSC_Setup+0x4a>
 8003e58:	f8b1 8006 	ldrh.w	r8, [r1, #6]
 8003e5c:	f1b8 0f01 	cmp.w	r8, #1
 8003e60:	d06a      	beq.n	8003f38 <USBD_MSC_Setup+0x120>
          USBD_CtlError(pdev, req);
 8003e62:	4621      	mov	r1, r4
 8003e64:	4628      	mov	r0, r5
 8003e66:	f001 f93b 	bl	80050e0 <USBD_CtlError>
          ret = USBD_FAIL;
 8003e6a:	2602      	movs	r6, #2
}
 8003e6c:	4630      	mov	r0, r6
 8003e6e:	b002      	add	sp, #8
 8003e70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      switch (req->bRequest)
 8003e74:	f891 8001 	ldrb.w	r8, [r1, #1]
 8003e78:	f1b8 0f0b 	cmp.w	r8, #11
 8003e7c:	d8f1      	bhi.n	8003e62 <USBD_MSC_Setup+0x4a>
 8003e7e:	a301      	add	r3, pc, #4	; (adr r3, 8003e84 <USBD_MSC_Setup+0x6c>)
 8003e80:	f853 f028 	ldr.w	pc, [r3, r8, lsl #2]
 8003e84:	08003ec3 	.word	0x08003ec3
 8003e88:	08003eeb 	.word	0x08003eeb
 8003e8c:	08003e63 	.word	0x08003e63
 8003e90:	08003e63 	.word	0x08003e63
 8003e94:	08003e63 	.word	0x08003e63
 8003e98:	08003e63 	.word	0x08003e63
 8003e9c:	08003e63 	.word	0x08003e63
 8003ea0:	08003e63 	.word	0x08003e63
 8003ea4:	08003e63 	.word	0x08003e63
 8003ea8:	08003e63 	.word	0x08003e63
 8003eac:	08003ed9 	.word	0x08003ed9
 8003eb0:	08003eb5 	.word	0x08003eb5
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8003eb4:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8003eb8:	2b03      	cmp	r3, #3
 8003eba:	d1d2      	bne.n	8003e62 <USBD_MSC_Setup+0x4a>
            hmsc->interface = (uint8_t)(req->wValue);
 8003ebc:	788b      	ldrb	r3, [r1, #2]
 8003ebe:	607b      	str	r3, [r7, #4]
 8003ec0:	e7d4      	b.n	8003e6c <USBD_MSC_Setup+0x54>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8003ec2:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8003ec6:	2b03      	cmp	r3, #3
 8003ec8:	d1cb      	bne.n	8003e62 <USBD_MSC_Setup+0x4a>
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&status_info, 2U);
 8003eca:	2202      	movs	r2, #2
 8003ecc:	f10d 0106 	add.w	r1, sp, #6
 8003ed0:	f001 f93c 	bl	800514c <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 8003ed4:	4646      	mov	r6, r8
 8003ed6:	e7c9      	b.n	8003e6c <USBD_MSC_Setup+0x54>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8003ed8:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8003edc:	2b03      	cmp	r3, #3
 8003ede:	d1c0      	bne.n	8003e62 <USBD_MSC_Setup+0x4a>
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&hmsc->interface, 1U);
 8003ee0:	2201      	movs	r2, #1
 8003ee2:	1d39      	adds	r1, r7, #4
 8003ee4:	f001 f932 	bl	800514c <USBD_CtlSendData>
 8003ee8:	e7c0      	b.n	8003e6c <USBD_MSC_Setup+0x54>
          USBD_LL_FlushEP(pdev, (uint8_t)req->wIndex);
 8003eea:	7909      	ldrb	r1, [r1, #4]
 8003eec:	f001 fbb6 	bl	800565c <USBD_LL_FlushEP>
          USBD_LL_CloseEP(pdev, (uint8_t)req->wIndex);
 8003ef0:	4628      	mov	r0, r5
 8003ef2:	7921      	ldrb	r1, [r4, #4]
 8003ef4:	f001 fba4 	bl	8005640 <USBD_LL_CloseEP>
          if ((((uint8_t)req->wIndex) & 0x80U) == 0x80U)
 8003ef8:	88a3      	ldrh	r3, [r4, #4]
 8003efa:	f994 2004 	ldrsb.w	r2, [r4, #4]
            pdev->ep_in[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 8003efe:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)req->wIndex) & 0x80U) == 0x80U)
 8003f02:	2a00      	cmp	r2, #0
            pdev->ep_in[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 8003f04:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003f08:	f04f 0200 	mov.w	r2, #0
 8003f0c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
          if ((((uint8_t)req->wIndex) & 0x80U) == 0x80U)
 8003f10:	db20      	blt.n	8003f54 <USBD_MSC_Setup+0x13c>
            pdev->ep_out[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 8003f12:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
            if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003f16:	7c2b      	ldrb	r3, [r5, #16]
 8003f18:	bb4b      	cbnz	r3, 8003f6e <USBD_MSC_Setup+0x156>
              USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK,
 8003f1a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003f1e:	2202      	movs	r2, #2
 8003f20:	2101      	movs	r1, #1
 8003f22:	4628      	mov	r0, r5
 8003f24:	f001 fb7c 	bl	8005620 <USBD_LL_OpenEP>
            pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 8003f28:	2301      	movs	r3, #1
 8003f2a:	f8c5 316c 	str.w	r3, [r5, #364]	; 0x16c
          MSC_BOT_CplClrFeature(pdev, (uint8_t)req->wIndex);
 8003f2e:	4628      	mov	r0, r5
 8003f30:	7921      	ldrb	r1, [r4, #4]
 8003f32:	f000 f971 	bl	8004218 <MSC_BOT_CplClrFeature>
          break;
 8003f36:	e799      	b.n	8003e6c <USBD_MSC_Setup+0x54>
          if ((req->wValue  == 0U) && (req->wLength == 1U) &&
 8003f38:	061a      	lsls	r2, r3, #24
 8003f3a:	d592      	bpl.n	8003e62 <USBD_MSC_Setup+0x4a>
            hmsc->max_lun = (uint32_t)((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 8003f3c:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 8003f40:	699b      	ldr	r3, [r3, #24]
 8003f42:	4798      	blx	r3
 8003f44:	4603      	mov	r3, r0
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&hmsc->max_lun, 1U);
 8003f46:	4642      	mov	r2, r8
 8003f48:	4628      	mov	r0, r5
 8003f4a:	4639      	mov	r1, r7
            hmsc->max_lun = (uint32_t)((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 8003f4c:	603b      	str	r3, [r7, #0]
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&hmsc->max_lun, 1U);
 8003f4e:	f001 f8fd 	bl	800514c <USBD_CtlSendData>
 8003f52:	e78b      	b.n	8003e6c <USBD_MSC_Setup+0x54>
            pdev->ep_in[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 8003f54:	619a      	str	r2, [r3, #24]
            if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003f56:	7c2b      	ldrb	r3, [r5, #16]
 8003f58:	b983      	cbnz	r3, 8003f7c <USBD_MSC_Setup+0x164>
              USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK,
 8003f5a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003f5e:	2202      	movs	r2, #2
 8003f60:	2181      	movs	r1, #129	; 0x81
 8003f62:	4628      	mov	r0, r5
 8003f64:	f001 fb5c 	bl	8005620 <USBD_LL_OpenEP>
            pdev->ep_in[MSC_EPIN_ADDR & 0xFU].is_used = 1U;
 8003f68:	2301      	movs	r3, #1
 8003f6a:	62eb      	str	r3, [r5, #44]	; 0x2c
 8003f6c:	e7df      	b.n	8003f2e <USBD_MSC_Setup+0x116>
              USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK,
 8003f6e:	2340      	movs	r3, #64	; 0x40
 8003f70:	2202      	movs	r2, #2
 8003f72:	2101      	movs	r1, #1
 8003f74:	4628      	mov	r0, r5
 8003f76:	f001 fb53 	bl	8005620 <USBD_LL_OpenEP>
 8003f7a:	e7d5      	b.n	8003f28 <USBD_MSC_Setup+0x110>
              USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK,
 8003f7c:	2340      	movs	r3, #64	; 0x40
 8003f7e:	2202      	movs	r2, #2
 8003f80:	2181      	movs	r1, #129	; 0x81
 8003f82:	4628      	mov	r0, r5
 8003f84:	f001 fb4c 	bl	8005620 <USBD_LL_OpenEP>
 8003f88:	e7ee      	b.n	8003f68 <USBD_MSC_Setup+0x150>
 8003f8a:	bf00      	nop

08003f8c <USBD_MSC_DataIn>:
{
 8003f8c:	b508      	push	{r3, lr}
  MSC_BOT_DataIn(pdev, epnum);
 8003f8e:	f000 f83f 	bl	8004010 <MSC_BOT_DataIn>
}
 8003f92:	2000      	movs	r0, #0
 8003f94:	bd08      	pop	{r3, pc}
 8003f96:	bf00      	nop

08003f98 <USBD_MSC_DataOut>:
{
 8003f98:	b508      	push	{r3, lr}
  MSC_BOT_DataOut(pdev, epnum);
 8003f9a:	f000 f895 	bl	80040c8 <MSC_BOT_DataOut>
}
 8003f9e:	2000      	movs	r0, #0
 8003fa0:	bd08      	pop	{r3, pc}
 8003fa2:	bf00      	nop

08003fa4 <USBD_MSC_RegisterStorage>:
* @retval status
*/
uint8_t USBD_MSC_RegisterStorage(USBD_HandleTypeDef *pdev,
                                 USBD_StorageTypeDef *fops)
{
  if (fops != NULL)
 8003fa4:	b109      	cbz	r1, 8003faa <USBD_MSC_RegisterStorage+0x6>
  {
    pdev->pUserData = fops;
 8003fa6:	f8c0 12bc 	str.w	r1, [r0, #700]	; 0x2bc
  }

  return USBD_OK;
}
 8003faa:	2000      	movs	r0, #0
 8003fac:	4770      	bx	lr
 8003fae:	bf00      	nop

08003fb0 <MSC_BOT_Init>:
*         Initialize the BOT Process
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_Init(USBD_HandleTypeDef  *pdev)
{
 8003fb0:	b570      	push	{r4, r5, r6, lr}
 8003fb2:	4604      	mov	r4, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;

  hmsc->bot_state = USBD_BOT_IDLE;
 8003fb4:	2300      	movs	r3, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8003fb6:	f8d4 52b8 	ldr.w	r5, [r4, #696]	; 0x2b8
  hmsc->bot_status = USBD_BOT_STATUS_NORMAL;

  hmsc->scsi_sense_tail = 0U;
  hmsc->scsi_sense_head = 0U;

  ((USBD_StorageTypeDef *)pdev->pUserData)->Init(0U);
 8003fba:	4618      	mov	r0, r3
  hmsc->bot_state = USBD_BOT_IDLE;
 8003fbc:	812b      	strh	r3, [r5, #8]
  hmsc->scsi_sense_head = 0U;
 8003fbe:	f8a5 315c 	strh.w	r3, [r5, #348]	; 0x15c
  ((USBD_StorageTypeDef *)pdev->pUserData)->Init(0U);
 8003fc2:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8003fc6:	681b      	ldr	r3, [r3, #0]
 8003fc8:	4798      	blx	r3

  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
 8003fca:	2101      	movs	r1, #1
 8003fcc:	4620      	mov	r0, r4
 8003fce:	f001 fb45 	bl	800565c <USBD_LL_FlushEP>
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
 8003fd2:	2181      	movs	r1, #129	; 0x81
 8003fd4:	4620      	mov	r0, r4
 8003fd6:	f001 fb41 	bl	800565c <USBD_LL_FlushEP>

  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 8003fda:	4620      	mov	r0, r4
 8003fdc:	f505 7286 	add.w	r2, r5, #268	; 0x10c
 8003fe0:	231f      	movs	r3, #31
                         USBD_BOT_CBW_LENGTH);
}
 8003fe2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 8003fe6:	2101      	movs	r1, #1
 8003fe8:	f001 bb92 	b.w	8005710 <USBD_LL_PrepareReceive>

08003fec <MSC_BOT_Reset>:
*/
void MSC_BOT_Reset(USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;

  hmsc->bot_state  = USBD_BOT_IDLE;
 8003fec:	f44f 7c80 	mov.w	ip, #256	; 0x100
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8003ff0:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;

  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 8003ff4:	231f      	movs	r3, #31
  hmsc->bot_state  = USBD_BOT_IDLE;
 8003ff6:	f8a2 c008 	strh.w	ip, [r2, #8]
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 8003ffa:	2101      	movs	r1, #1
 8003ffc:	f502 7286 	add.w	r2, r2, #268	; 0x10c
 8004000:	f001 bb86 	b.w	8005710 <USBD_LL_PrepareReceive>

08004004 <MSC_BOT_DeInit>:
* @retval None
*/
void MSC_BOT_DeInit(USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
  hmsc->bot_state = USBD_BOT_IDLE;
 8004004:	2200      	movs	r2, #0
 8004006:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800400a:	721a      	strb	r2, [r3, #8]
}
 800400c:	4770      	bx	lr
 800400e:	bf00      	nop

08004010 <MSC_BOT_DataIn>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataIn(USBD_HandleTypeDef  *pdev,
                    uint8_t epnum)
{
 8004010:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004012:	f8d0 42b8 	ldr.w	r4, [r0, #696]	; 0x2b8
{
 8004016:	4605      	mov	r5, r0

  switch (hmsc->bot_state)
 8004018:	7a23      	ldrb	r3, [r4, #8]
 800401a:	2b02      	cmp	r3, #2
 800401c:	d01a      	beq.n	8004054 <MSC_BOT_DataIn+0x44>
 800401e:	3b03      	subs	r3, #3
 8004020:	2b01      	cmp	r3, #1
 8004022:	d81f      	bhi.n	8004064 <MSC_BOT_DataIn+0x54>
void  MSC_BOT_SendCSW(USBD_HandleTypeDef  *pdev,
                      uint8_t CSW_Status)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;

  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8004024:	4b18      	ldr	r3, [pc, #96]	; (8004088 <MSC_BOT_DataIn+0x78>)
  hmsc->csw.bStatus = CSW_Status;
 8004026:	f04f 0c00 	mov.w	ip, #0
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 800402a:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  hmsc->bot_state = USBD_BOT_IDLE;

  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 800402e:	2181      	movs	r1, #129	; 0x81
 8004030:	230d      	movs	r3, #13
 8004032:	f504 7296 	add.w	r2, r4, #300	; 0x12c
  hmsc->csw.bStatus = CSW_Status;
 8004036:	f884 c138 	strb.w	ip, [r4, #312]	; 0x138
  hmsc->bot_state = USBD_BOT_IDLE;
 800403a:	f884 c008 	strb.w	ip, [r4, #8]
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 800403e:	f001 fb59 	bl	80056f4 <USBD_LL_Transmit>
                   USBD_BOT_CSW_LENGTH);

  /* Prepare EP to Receive next Cmd */
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 8004042:	4628      	mov	r0, r5
 8004044:	f504 7286 	add.w	r2, r4, #268	; 0x10c
 8004048:	231f      	movs	r3, #31
}
 800404a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 800404e:	2101      	movs	r1, #1
 8004050:	f001 bb5e 	b.w	8005710 <USBD_LL_PrepareReceive>
      if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
 8004054:	f894 1119 	ldrb.w	r1, [r4, #281]	; 0x119
 8004058:	f204 121b 	addw	r2, r4, #283	; 0x11b
 800405c:	f000 f908 	bl	8004270 <SCSI_ProcessCmd>
 8004060:	2800      	cmp	r0, #0
 8004062:	db00      	blt.n	8004066 <MSC_BOT_DataIn+0x56>
}
 8004064:	bd70      	pop	{r4, r5, r6, pc}
  hmsc->csw.bStatus = CSW_Status;
 8004066:	2601      	movs	r6, #1
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004068:	f8d5 42b8 	ldr.w	r4, [r5, #696]	; 0x2b8
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 800406c:	4b06      	ldr	r3, [pc, #24]	; (8004088 <MSC_BOT_DataIn+0x78>)
  hmsc->bot_state = USBD_BOT_IDLE;
 800406e:	f04f 0c00 	mov.w	ip, #0
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8004072:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 8004076:	2181      	movs	r1, #129	; 0x81
 8004078:	230d      	movs	r3, #13
 800407a:	4628      	mov	r0, r5
 800407c:	f504 7296 	add.w	r2, r4, #300	; 0x12c
  hmsc->csw.bStatus = CSW_Status;
 8004080:	f884 6138 	strb.w	r6, [r4, #312]	; 0x138
  hmsc->bot_state = USBD_BOT_IDLE;
 8004084:	e7d9      	b.n	800403a <MSC_BOT_DataIn+0x2a>
 8004086:	bf00      	nop
 8004088:	53425355 	.word	0x53425355

0800408c <MSC_BOT_SendCSW>:
{
 800408c:	468c      	mov	ip, r1
  hmsc->bot_state = USBD_BOT_IDLE;
 800408e:	2200      	movs	r2, #0
{
 8004090:	b570      	push	{r4, r5, r6, lr}
 8004092:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004094:	f8d0 42b8 	ldr.w	r4, [r0, #696]	; 0x2b8
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8004098:	4e0a      	ldr	r6, [pc, #40]	; (80040c4 <MSC_BOT_SendCSW+0x38>)
  hmsc->bot_state = USBD_BOT_IDLE;
 800409a:	7222      	strb	r2, [r4, #8]
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 800409c:	230d      	movs	r3, #13
 800409e:	f504 7296 	add.w	r2, r4, #300	; 0x12c
 80040a2:	2181      	movs	r1, #129	; 0x81
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 80040a4:	f8c4 612c 	str.w	r6, [r4, #300]	; 0x12c
  hmsc->csw.bStatus = CSW_Status;
 80040a8:	f884 c138 	strb.w	ip, [r4, #312]	; 0x138
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 80040ac:	f001 fb22 	bl	80056f4 <USBD_LL_Transmit>
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 80040b0:	4628      	mov	r0, r5
 80040b2:	f504 7286 	add.w	r2, r4, #268	; 0x10c
 80040b6:	231f      	movs	r3, #31
                         USBD_BOT_CBW_LENGTH);
}
 80040b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 80040bc:	2101      	movs	r1, #1
 80040be:	f001 bb27 	b.w	8005710 <USBD_LL_PrepareReceive>
 80040c2:	bf00      	nop
 80040c4:	53425355 	.word	0x53425355

080040c8 <MSC_BOT_DataOut>:
{
 80040c8:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80040ca:	f8d0 52b8 	ldr.w	r5, [r0, #696]	; 0x2b8
{
 80040ce:	4604      	mov	r4, r0
  switch (hmsc->bot_state)
 80040d0:	7a2e      	ldrb	r6, [r5, #8]
 80040d2:	b156      	cbz	r6, 80040ea <MSC_BOT_DataOut+0x22>
 80040d4:	2e01      	cmp	r6, #1
 80040d6:	d107      	bne.n	80040e8 <MSC_BOT_DataOut+0x20>
      if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
 80040d8:	f895 1119 	ldrb.w	r1, [r5, #281]	; 0x119
 80040dc:	f205 121b 	addw	r2, r5, #283	; 0x11b
 80040e0:	f000 f8c6 	bl	8004270 <SCSI_ProcessCmd>
 80040e4:	2800      	cmp	r0, #0
 80040e6:	db37      	blt.n	8004158 <MSC_BOT_DataOut+0x90>
}
 80040e8:	bd70      	pop	{r4, r5, r6, pc}
  hmsc->csw.dTag = hmsc->cbw.dTag;
 80040ea:	e9d5 3244 	ldrd	r3, r2, [r5, #272]	; 0x110
  if ((USBD_LL_GetRxDataSize(pdev, MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 80040ee:	2101      	movs	r1, #1
  hmsc->csw.dTag = hmsc->cbw.dTag;
 80040f0:	f8c5 2134 	str.w	r2, [r5, #308]	; 0x134
 80040f4:	f8c5 3130 	str.w	r3, [r5, #304]	; 0x130
  if ((USBD_LL_GetRxDataSize(pdev, MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 80040f8:	f001 fb18 	bl	800572c <USBD_LL_GetRxDataSize>
 80040fc:	281f      	cmp	r0, #31
 80040fe:	d128      	bne.n	8004152 <MSC_BOT_DataOut+0x8a>
 8004100:	4b43      	ldr	r3, [pc, #268]	; (8004210 <MSC_BOT_DataOut+0x148>)
 8004102:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
      (hmsc->cbw.bLUN > 1U) ||
 8004106:	f895 1119 	ldrb.w	r1, [r5, #281]	; 0x119
  if ((USBD_LL_GetRxDataSize(pdev, MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 800410a:	429a      	cmp	r2, r3
 800410c:	d037      	beq.n	800417e <MSC_BOT_DataOut+0xb6>
    SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
 800410e:	2320      	movs	r3, #32
 8004110:	2205      	movs	r2, #5
 8004112:	4620      	mov	r0, r4
 8004114:	f000 fc1e 	bl	8004954 <SCSI_SenseCode>
    hmsc->bot_status = USBD_BOT_STATUS_ERROR;
 8004118:	2302      	movs	r3, #2
 800411a:	726b      	strb	r3, [r5, #9]
* @retval status
*/

static void  MSC_BOT_Abort(USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 800411c:	f8d4 52b8 	ldr.w	r5, [r4, #696]	; 0x2b8

  if ((hmsc->cbw.bmFlags == 0U) &&
 8004120:	f895 3118 	ldrb.w	r3, [r5, #280]	; 0x118
 8004124:	b92b      	cbnz	r3, 8004132 <MSC_BOT_DataOut+0x6a>
 8004126:	f8d5 3114 	ldr.w	r3, [r5, #276]	; 0x114
 800412a:	b113      	cbz	r3, 8004132 <MSC_BOT_DataOut+0x6a>
      (hmsc->cbw.dDataLength != 0U) &&
 800412c:	7a6b      	ldrb	r3, [r5, #9]
 800412e:	2b00      	cmp	r3, #0
 8004130:	d053      	beq.n	80041da <MSC_BOT_DataOut+0x112>
      (hmsc->bot_status == USBD_BOT_STATUS_NORMAL))
  {
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR);
  }

  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 8004132:	2181      	movs	r1, #129	; 0x81
 8004134:	4620      	mov	r0, r4
 8004136:	f001 fa9f 	bl	8005678 <USBD_LL_StallEP>

  if (hmsc->bot_status == USBD_BOT_STATUS_ERROR)
 800413a:	7a6b      	ldrb	r3, [r5, #9]
 800413c:	2b02      	cmp	r3, #2
 800413e:	d1d3      	bne.n	80040e8 <MSC_BOT_DataOut+0x20>
  {
    USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 8004140:	4620      	mov	r0, r4
 8004142:	f505 7286 	add.w	r2, r5, #268	; 0x10c
 8004146:	231f      	movs	r3, #31
}
 8004148:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 800414c:	2101      	movs	r1, #1
 800414e:	f001 badf 	b.w	8005710 <USBD_LL_PrepareReceive>
      (hmsc->cbw.bLUN > 1U) ||
 8004152:	f895 1119 	ldrb.w	r1, [r5, #281]	; 0x119
 8004156:	e7da      	b.n	800410e <MSC_BOT_DataOut+0x46>
  hmsc->bot_state = USBD_BOT_IDLE;
 8004158:	f04f 0c00 	mov.w	ip, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 800415c:	f8d4 52b8 	ldr.w	r5, [r4, #696]	; 0x2b8
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8004160:	4b2c      	ldr	r3, [pc, #176]	; (8004214 <MSC_BOT_DataOut+0x14c>)
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 8004162:	2181      	movs	r1, #129	; 0x81
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8004164:	f8c5 312c 	str.w	r3, [r5, #300]	; 0x12c
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 8004168:	4620      	mov	r0, r4
 800416a:	230d      	movs	r3, #13
  hmsc->csw.bStatus = CSW_Status;
 800416c:	f885 6138 	strb.w	r6, [r5, #312]	; 0x138
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 8004170:	f505 7296 	add.w	r2, r5, #300	; 0x12c
  hmsc->bot_state = USBD_BOT_IDLE;
 8004174:	f885 c008 	strb.w	ip, [r5, #8]
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 8004178:	f001 fabc 	bl	80056f4 <USBD_LL_Transmit>
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 800417c:	e7e0      	b.n	8004140 <MSC_BOT_DataOut+0x78>
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE) ||
 800417e:	2901      	cmp	r1, #1
 8004180:	d8c5      	bhi.n	800410e <MSC_BOT_DataOut+0x46>
      (hmsc->cbw.bLUN > 1U) ||
 8004182:	f895 311a 	ldrb.w	r3, [r5, #282]	; 0x11a
 8004186:	3b01      	subs	r3, #1
 8004188:	2b0f      	cmp	r3, #15
 800418a:	d8c0      	bhi.n	800410e <MSC_BOT_DataOut+0x46>
    if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
 800418c:	4620      	mov	r0, r4
 800418e:	f205 121b 	addw	r2, r5, #283	; 0x11b
 8004192:	f000 f86d 	bl	8004270 <SCSI_ProcessCmd>
 8004196:	2800      	cmp	r0, #0
      if (hmsc->bot_state == USBD_BOT_NO_DATA)
 8004198:	7a2b      	ldrb	r3, [r5, #8]
    if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
 800419a:	db23      	blt.n	80041e4 <MSC_BOT_DataOut+0x11c>
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) &&
 800419c:	3b01      	subs	r3, #1
 800419e:	2b02      	cmp	r3, #2
 80041a0:	d9a2      	bls.n	80040e8 <MSC_BOT_DataOut+0x20>
      if (hmsc->bot_data_length > 0U)
 80041a2:	896b      	ldrh	r3, [r5, #10]
 80041a4:	b33b      	cbz	r3, 80041f6 <MSC_BOT_DataOut+0x12e>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80041a6:	f8d4 12b8 	ldr.w	r1, [r4, #696]	; 0x2b8
  uint16_t length = (uint16_t)MIN(hmsc->cbw.dDataLength, len);
 80041aa:	461e      	mov	r6, r3
 80041ac:	f8d1 0114 	ldr.w	r0, [r1, #276]	; 0x114
        MSC_BOT_SendData(pdev, hmsc->bot_data, hmsc->bot_data_length);
 80041b0:	f105 020c 	add.w	r2, r5, #12
  uint16_t length = (uint16_t)MIN(hmsc->cbw.dDataLength, len);
 80041b4:	4298      	cmp	r0, r3
 80041b6:	bf38      	it	cc
 80041b8:	b283      	uxthcc	r3, r0
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, pbuf, length);
 80041ba:	4620      	mov	r0, r4
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
 80041bc:	2400      	movs	r4, #0
 80041be:	f881 4138 	strb.w	r4, [r1, #312]	; 0x138
  hmsc->bot_state = USBD_BOT_SEND_DATA;
 80041c2:	2404      	movs	r4, #4
 80041c4:	720c      	strb	r4, [r1, #8]
  hmsc->csw.dDataResidue -= len;
 80041c6:	f8d1 4134 	ldr.w	r4, [r1, #308]	; 0x134
 80041ca:	1ba4      	subs	r4, r4, r6
 80041cc:	f8c1 4134 	str.w	r4, [r1, #308]	; 0x134
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, pbuf, length);
 80041d0:	2181      	movs	r1, #129	; 0x81
}
 80041d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, pbuf, length);
 80041d6:	f001 ba8d 	b.w	80056f4 <USBD_LL_Transmit>
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR);
 80041da:	2101      	movs	r1, #1
 80041dc:	4620      	mov	r0, r4
 80041de:	f001 fa4b 	bl	8005678 <USBD_LL_StallEP>
 80041e2:	e7a6      	b.n	8004132 <MSC_BOT_DataOut+0x6a>
      if (hmsc->bot_state == USBD_BOT_NO_DATA)
 80041e4:	2b05      	cmp	r3, #5
 80041e6:	d00c      	beq.n	8004202 <MSC_BOT_DataOut+0x13a>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80041e8:	f8d4 52b8 	ldr.w	r5, [r4, #696]	; 0x2b8
  if ((hmsc->cbw.bmFlags == 0U) &&
 80041ec:	f895 3118 	ldrb.w	r3, [r5, #280]	; 0x118
 80041f0:	2b00      	cmp	r3, #0
 80041f2:	d19e      	bne.n	8004132 <MSC_BOT_DataOut+0x6a>
 80041f4:	e797      	b.n	8004126 <MSC_BOT_DataOut+0x5e>
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_PASSED);
 80041f6:	4620      	mov	r0, r4
}
 80041f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_PASSED);
 80041fc:	4619      	mov	r1, r3
 80041fe:	f7ff bf45 	b.w	800408c <MSC_BOT_SendCSW>
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
 8004202:	4620      	mov	r0, r4
}
 8004204:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
 8004208:	2101      	movs	r1, #1
 800420a:	f7ff bf3f 	b.w	800408c <MSC_BOT_SendCSW>
 800420e:	bf00      	nop
 8004210:	43425355 	.word	0x43425355
 8004214:	53425355 	.word	0x53425355

08004218 <MSC_BOT_CplClrFeature>:
* @param  epnum: endpoint index
* @retval None
*/

void  MSC_BOT_CplClrFeature(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 8004218:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 800421a:	f8d0 52b8 	ldr.w	r5, [r0, #696]	; 0x2b8

  if (hmsc->bot_status == USBD_BOT_STATUS_ERROR) /* Bad CBW Signature */
 800421e:	7a6b      	ldrb	r3, [r5, #9]
 8004220:	2b02      	cmp	r3, #2
 8004222:	d01d      	beq.n	8004260 <MSC_BOT_CplClrFeature+0x48>
  {
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
  }
  else if (((epnum & 0x80U) == 0x80U) && (hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
 8004224:	060a      	lsls	r2, r1, #24
 8004226:	d520      	bpl.n	800426a <MSC_BOT_CplClrFeature+0x52>
 8004228:	2b01      	cmp	r3, #1
 800422a:	d01e      	beq.n	800426a <MSC_BOT_CplClrFeature+0x52>
  hmsc->csw.bStatus = CSW_Status;
 800422c:	2601      	movs	r6, #1
  hmsc->bot_state = USBD_BOT_IDLE;
 800422e:	f04f 0c00 	mov.w	ip, #0
 8004232:	4604      	mov	r4, r0
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8004234:	4b0d      	ldr	r3, [pc, #52]	; (800426c <MSC_BOT_CplClrFeature+0x54>)
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 8004236:	f505 7296 	add.w	r2, r5, #300	; 0x12c
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 800423a:	f8c5 312c 	str.w	r3, [r5, #300]	; 0x12c
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 800423e:	2181      	movs	r1, #129	; 0x81
 8004240:	230d      	movs	r3, #13
  hmsc->csw.bStatus = CSW_Status;
 8004242:	f885 6138 	strb.w	r6, [r5, #312]	; 0x138
  hmsc->bot_state = USBD_BOT_IDLE;
 8004246:	f885 c008 	strb.w	ip, [r5, #8]
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 800424a:	f001 fa53 	bl	80056f4 <USBD_LL_Transmit>
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 800424e:	4631      	mov	r1, r6
 8004250:	4620      	mov	r0, r4
 8004252:	f505 7286 	add.w	r2, r5, #268	; 0x10c
 8004256:	231f      	movs	r3, #31
  }
  else
  {
    return;
  }
}
 8004258:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 800425c:	f001 ba58 	b.w	8005710 <USBD_LL_PrepareReceive>
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 8004260:	2181      	movs	r1, #129	; 0x81
 8004262:	f001 fa09 	bl	8005678 <USBD_LL_StallEP>
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
 8004266:	2300      	movs	r3, #0
 8004268:	726b      	strb	r3, [r5, #9]
}
 800426a:	bd70      	pop	{r4, r5, r6, pc}
 800426c:	53425355 	.word	0x53425355

08004270 <SCSI_ProcessCmd>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *cmd)
{
 8004270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  switch (cmd[0])
 8004274:	7813      	ldrb	r3, [r2, #0]
{
 8004276:	4615      	mov	r5, r2
 8004278:	4604      	mov	r4, r0
 800427a:	468a      	mov	sl, r1
 800427c:	b082      	sub	sp, #8
  switch (cmd[0])
 800427e:	2b5a      	cmp	r3, #90	; 0x5a
 8004280:	d85c      	bhi.n	800433c <SCSI_ProcessCmd+0xcc>
 8004282:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004286:	00db      	.short	0x00db
 8004288:	005b005b 	.word	0x005b005b
 800428c:	005b007e 	.word	0x005b007e
 8004290:	005b005b 	.word	0x005b005b
 8004294:	005b005b 	.word	0x005b005b
 8004298:	005b005b 	.word	0x005b005b
 800429c:	005b005b 	.word	0x005b005b
 80042a0:	005b005b 	.word	0x005b005b
 80042a4:	005b005b 	.word	0x005b005b
 80042a8:	00ba005b 	.word	0x00ba005b
 80042ac:	005b005b 	.word	0x005b005b
 80042b0:	005b005b 	.word	0x005b005b
 80042b4:	005b005b 	.word	0x005b005b
 80042b8:	00ac005b 	.word	0x00ac005b
 80042bc:	005b0075 	.word	0x005b0075
 80042c0:	0075005b 	.word	0x0075005b
 80042c4:	005b005b 	.word	0x005b005b
 80042c8:	005b005b 	.word	0x005b005b
 80042cc:	005b01b8 	.word	0x005b01b8
 80042d0:	005b01dd 	.word	0x005b01dd
 80042d4:	0149005b 	.word	0x0149005b
 80042d8:	00ed005b 	.word	0x00ed005b
 80042dc:	005b005b 	.word	0x005b005b
 80042e0:	005b005b 	.word	0x005b005b
 80042e4:	005b0137 	.word	0x005b0137
 80042e8:	005b005b 	.word	0x005b005b
 80042ec:	005b005b 	.word	0x005b005b
 80042f0:	005b005b 	.word	0x005b005b
 80042f4:	005b005b 	.word	0x005b005b
 80042f8:	005b005b 	.word	0x005b005b
 80042fc:	005b005b 	.word	0x005b005b
 8004300:	005b005b 	.word	0x005b005b
 8004304:	005b005b 	.word	0x005b005b
 8004308:	005b005b 	.word	0x005b005b
 800430c:	005b005b 	.word	0x005b005b
 8004310:	005b005b 	.word	0x005b005b
 8004314:	005b005b 	.word	0x005b005b
 8004318:	005b005b 	.word	0x005b005b
 800431c:	005b005b 	.word	0x005b005b
 8004320:	005b005b 	.word	0x005b005b
 8004324:	005b005b 	.word	0x005b005b
 8004328:	005b005b 	.word	0x005b005b
 800432c:	005b005b 	.word	0x005b005b
 8004330:	005b005b 	.word	0x005b005b
 8004334:	005b005b 	.word	0x005b005b
 8004338:	01fd005b 	.word	0x01fd005b
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;

  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800433c:	2000      	movs	r0, #0
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800433e:	2505      	movs	r5, #5
      return -1;
 8004340:	f04f 36ff 	mov.w	r6, #4294967295
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004344:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004348:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 800434c:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 8004350:	3301      	adds	r3, #1
 8004352:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004354:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004356:	f881 513c 	strb.w	r5, [r1, #316]	; 0x13c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800435a:	f881 0140 	strb.w	r0, [r1, #320]	; 0x140
  hmsc->scsi_sense_tail++;
 800435e:	bf14      	ite	ne
 8004360:	f882 315d 	strbne.w	r3, [r2, #349]	; 0x15d
  {
    hmsc->scsi_sense_tail = 0U;
 8004364:	f882 015d 	strbeq.w	r0, [r2, #349]	; 0x15d
}
 8004368:	4630      	mov	r0, r6
 800436a:	b002      	add	sp, #8
 800436c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
* @retval status
*/
static int8_t SCSI_StartStopUnit(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
  hmsc->bot_data_length = 0U;
 8004370:	2300      	movs	r3, #0
  return 0;
 8004372:	461e      	mov	r6, r3
  hmsc->bot_data_length = 0U;
 8004374:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
}
 8004378:	4630      	mov	r0, r6
  hmsc->bot_data_length = 0U;
 800437a:	8153      	strh	r3, [r2, #10]
}
 800437c:	b002      	add	sp, #8
 800437e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  hmsc->bot_data[7] = REQUEST_SENSE_DATA_LEN - 6U;
 8004382:	200c      	movs	r0, #12
    hmsc->bot_data[i] = 0U;
 8004384:	2100      	movs	r1, #0
  hmsc->bot_data[0] = 0x70U;
 8004386:	2270      	movs	r2, #112	; 0x70
 8004388:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
    hmsc->bot_data[i] = 0U;
 800438c:	181c      	adds	r4, r3, r0
 800438e:	60d9      	str	r1, [r3, #12]
 8004390:	6119      	str	r1, [r3, #16]
 8004392:	6159      	str	r1, [r3, #20]
 8004394:	6199      	str	r1, [r3, #24]
 8004396:	8221      	strh	r1, [r4, #16]
  hmsc->bot_data[0] = 0x70U;
 8004398:	731a      	strb	r2, [r3, #12]
  hmsc->bot_data[7] = REQUEST_SENSE_DATA_LEN - 6U;
 800439a:	74d8      	strb	r0, [r3, #19]
  if ((hmsc->scsi_sense_head != hmsc->scsi_sense_tail))
 800439c:	f893 215c 	ldrb.w	r2, [r3, #348]	; 0x15c
 80043a0:	f893 015d 	ldrb.w	r0, [r3, #349]	; 0x15d
 80043a4:	4290      	cmp	r0, r2
 80043a6:	d012      	beq.n	80043ce <SCSI_ProcessCmd+0x15e>
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;
 80043a8:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 80043ac:	f890 413c 	ldrb.w	r4, [r0, #316]	; 0x13c
    hmsc->scsi_sense_head++;
 80043b0:	3201      	adds	r2, #1
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;
 80043b2:	739c      	strb	r4, [r3, #14]
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;
 80043b4:	f890 4141 	ldrb.w	r4, [r0, #321]	; 0x141
    hmsc->scsi_sense_head++;
 80043b8:	b2d2      	uxtb	r2, r2
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;
 80043ba:	761c      	strb	r4, [r3, #24]
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;
 80043bc:	f890 0140 	ldrb.w	r0, [r0, #320]	; 0x140
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
 80043c0:	2a04      	cmp	r2, #4
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;
 80043c2:	7658      	strb	r0, [r3, #25]
    hmsc->scsi_sense_head++;
 80043c4:	bf14      	ite	ne
 80043c6:	f883 215c 	strbne.w	r2, [r3, #348]	; 0x15c
      hmsc->scsi_sense_head = 0U;
 80043ca:	f883 115c 	strbeq.w	r1, [r3, #348]	; 0x15c
  hmsc->bot_data_length = REQUEST_SENSE_DATA_LEN;
 80043ce:	2212      	movs	r2, #18
 80043d0:	815a      	strh	r2, [r3, #10]
  if (params[4] <= REQUEST_SENSE_DATA_LEN)
 80043d2:	792a      	ldrb	r2, [r5, #4]
 80043d4:	2a12      	cmp	r2, #18
 80043d6:	d80b      	bhi.n	80043f0 <SCSI_ProcessCmd+0x180>
  return 0;
 80043d8:	2600      	movs	r6, #0
    hmsc->bot_data_length = params[4];
 80043da:	815a      	strh	r2, [r3, #10]
 80043dc:	e7c4      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->bot_data_length = len;
 80043de:	2108      	movs	r1, #8
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 80043e0:	4ad0      	ldr	r2, [pc, #832]	; (8004724 <SCSI_ProcessCmd+0x4b4>)
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80043e2:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 80043e6:	6810      	ldr	r0, [r2, #0]
 80043e8:	6852      	ldr	r2, [r2, #4]
 80043ea:	60d8      	str	r0, [r3, #12]
 80043ec:	611a      	str	r2, [r3, #16]
  hmsc->bot_data_length = len;
 80043ee:	8159      	strh	r1, [r3, #10]
  return 0;
 80043f0:	2600      	movs	r6, #0
}
 80043f2:	4630      	mov	r0, r6
 80043f4:	b002      	add	sp, #8
 80043f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (params[1] & 0x01U)/*Evpd is set*/
 80043fa:	786b      	ldrb	r3, [r5, #1]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80043fc:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
  if (params[1] & 0x01U)/*Evpd is set*/
 8004400:	07db      	lsls	r3, r3, #31
 8004402:	f100 8140 	bmi.w	8004686 <SCSI_ProcessCmd+0x416>
    pPage = (uint8_t *)(void *) & ((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 8004406:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800440a:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 800440e:	69d8      	ldr	r0, [r3, #28]
 8004410:	792b      	ldrb	r3, [r5, #4]
 8004412:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    len = (uint16_t)pPage[4] + 5U;
 8004416:	7901      	ldrb	r1, [r0, #4]
 8004418:	3105      	adds	r1, #5
    if (params[4] <= len)
 800441a:	428b      	cmp	r3, r1
 800441c:	bf28      	it	cs
 800441e:	460b      	movcs	r3, r1
    hmsc->bot_data_length = len;
 8004420:	8153      	strh	r3, [r2, #10]
    while (len)
 8004422:	2b00      	cmp	r3, #0
 8004424:	d0e4      	beq.n	80043f0 <SCSI_ProcessCmd+0x180>
 8004426:	f103 010b 	add.w	r1, r3, #11
 800442a:	440a      	add	r2, r1
 800442c:	4403      	add	r3, r0
      hmsc->bot_data[len] = pPage[len];
 800442e:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    while (len)
 8004432:	4283      	cmp	r3, r0
      hmsc->bot_data[len] = pPage[len];
 8004434:	f802 1901 	strb.w	r1, [r2], #-1
    while (len)
 8004438:	d1f9      	bne.n	800442e <SCSI_ProcessCmd+0x1be>
 800443a:	e7d9      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 800443c:	f8d0 52b8 	ldr.w	r5, [r0, #696]	; 0x2b8
  if (hmsc->cbw.dDataLength != 0U)
 8004440:	f8d5 7114 	ldr.w	r7, [r5, #276]	; 0x114
 8004444:	2f00      	cmp	r7, #0
 8004446:	f040 81ce 	bne.w	80047e6 <SCSI_ProcessCmd+0x576>
  if (((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) != 0)
 800444a:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800444e:	4608      	mov	r0, r1
 8004450:	689b      	ldr	r3, [r3, #8]
 8004452:	4798      	blx	r3
 8004454:	4606      	mov	r6, r0
 8004456:	2800      	cmp	r0, #0
 8004458:	f040 81d8 	bne.w	800480c <SCSI_ProcessCmd+0x59c>
  hmsc->bot_data_length = 0U;
 800445c:	8168      	strh	r0, [r5, #10]
  return 0;
 800445e:	e783      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
* @retval status
*/

static int8_t SCSI_Write10(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
 8004460:	f8d0 72b8 	ldr.w	r7, [r0, #696]	; 0x2b8
  uint32_t len;

  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 8004464:	f897 9008 	ldrb.w	r9, [r7, #8]
 8004468:	f1b9 0f00 	cmp.w	r9, #0
 800446c:	f040 8128 	bne.w	80046c0 <SCSI_ProcessCmd+0x450>
  {
    /* case 8 : Hi <> Do */
    if ((hmsc->cbw.bmFlags & 0x80U) == 0x80U)
 8004470:	f997 3118 	ldrsb.w	r3, [r7, #280]	; 0x118
 8004474:	2b00      	cmp	r3, #0
 8004476:	f2c0 8250 	blt.w	800491a <SCSI_ProcessCmd+0x6aa>
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
      return -1;
    }

    /* Check whether Media is ready */
    if (((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) != 0)
 800447a:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800447e:	4608      	mov	r0, r1
 8004480:	689b      	ldr	r3, [r3, #8]
 8004482:	4798      	blx	r3
 8004484:	4680      	mov	r8, r0
 8004486:	2800      	cmp	r0, #0
 8004488:	f040 8233 	bne.w	80048f2 <SCSI_ProcessCmd+0x682>
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
      return -1;
    }

    /* Check If media is write-protected */
    if (((USBD_StorageTypeDef *)pdev->pUserData)->IsWriteProtected(lun) != 0)
 800448c:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8004490:	4650      	mov	r0, sl
 8004492:	68db      	ldr	r3, [r3, #12]
 8004494:	4798      	blx	r3
 8004496:	4606      	mov	r6, r0
 8004498:	2800      	cmp	r0, #0
 800449a:	f040 8202 	bne.w	80048a2 <SCSI_ProcessCmd+0x632>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, WRITE_PROTECTED);
      return -1;
    }

    hmsc->scsi_blk_addr = ((uint32_t)params[2] << 24) |
 800449e:	f8d5 2002 	ldr.w	r2, [r5, #2]
* @retval status
*/
static int8_t SCSI_CheckAddressRange(USBD_HandleTypeDef *pdev, uint8_t lun,
                                     uint32_t blk_offset, uint32_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
 80044a2:	f8d4 12b8 	ldr.w	r1, [r4, #696]	; 0x2b8
 80044a6:	ba12      	rev	r2, r2
    hmsc->scsi_blk_addr = ((uint32_t)params[2] << 24) |
 80044a8:	f8c7 2164 	str.w	r2, [r7, #356]	; 0x164
    hmsc->scsi_blk_len = ((uint32_t)params[7] << 8) |
 80044ac:	f8b5 3007 	ldrh.w	r3, [r5, #7]

  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 80044b0:	f8d1 0160 	ldr.w	r0, [r1, #352]	; 0x160
 80044b4:	ba5b      	rev16	r3, r3
 80044b6:	b29b      	uxth	r3, r3
 80044b8:	441a      	add	r2, r3
 80044ba:	4282      	cmp	r2, r0
    hmsc->scsi_blk_len = ((uint32_t)params[7] << 8) |
 80044bc:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 80044c0:	f200 8145 	bhi.w	800474e <SCSI_ProcessCmd+0x4de>
    len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 80044c4:	f8b7 215e 	ldrh.w	r2, [r7, #350]	; 0x15e
 80044c8:	fb02 f303 	mul.w	r3, r2, r3
    if (hmsc->cbw.dDataLength != len)
 80044cc:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 80044d0:	4293      	cmp	r3, r2
 80044d2:	f040 813c 	bne.w	800474e <SCSI_ProcessCmd+0x4de>
    len = MIN(len, MSC_MEDIA_PACKET);
 80044d6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    hmsc->bot_state = USBD_BOT_DATA_OUT;
 80044da:	f04f 0101 	mov.w	r1, #1
    len = MIN(len, MSC_MEDIA_PACKET);
 80044de:	bf28      	it	cs
 80044e0:	f44f 7380 	movcs.w	r3, #256	; 0x100
    USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, hmsc->bot_data, len);
 80044e4:	4620      	mov	r0, r4
 80044e6:	f107 020c 	add.w	r2, r7, #12
    hmsc->bot_state = USBD_BOT_DATA_OUT;
 80044ea:	7239      	strb	r1, [r7, #8]
    USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, hmsc->bot_data, len);
 80044ec:	b29b      	uxth	r3, r3
 80044ee:	f001 f90f 	bl	8005710 <USBD_LL_PrepareReceive>
  return 0;
 80044f2:	e739      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  if ((params[1] & 0x02U) == 0x02U)
 80044f4:	786b      	ldrb	r3, [r5, #1]
 80044f6:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
 80044fa:	f013 0302 	ands.w	r3, r3, #2
 80044fe:	f040 81ae 	bne.w	800485e <SCSI_ProcessCmd+0x5ee>
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 8004502:	e9d2 1459 	ldrd	r1, r4, [r2, #356]	; 0x164
 8004506:	f8d2 0160 	ldr.w	r0, [r2, #352]	; 0x160
 800450a:	4421      	add	r1, r4
 800450c:	4281      	cmp	r1, r0
 800450e:	f200 8196 	bhi.w	800483e <SCSI_ProcessCmd+0x5ce>
  return 0;
 8004512:	461e      	mov	r6, r3
  hmsc->bot_data_length = 0U;
 8004514:	8153      	strh	r3, [r2, #10]
  return 0;
 8004516:	e727      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
 8004518:	f8d0 82b8 	ldr.w	r8, [r0, #696]	; 0x2b8
  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 800451c:	f898 7008 	ldrb.w	r7, [r8, #8]
 8004520:	2f00      	cmp	r7, #0
 8004522:	f040 80cb 	bne.w	80046bc <SCSI_ProcessCmd+0x44c>
    if ((hmsc->cbw.bmFlags & 0x80U) != 0x80U)
 8004526:	f998 3118 	ldrsb.w	r3, [r8, #280]	; 0x118
 800452a:	2b00      	cmp	r3, #0
 800452c:	f280 81a6 	bge.w	800487c <SCSI_ProcessCmd+0x60c>
    if (((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) != 0)
 8004530:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 8004534:	4608      	mov	r0, r1
 8004536:	689b      	ldr	r3, [r3, #8]
 8004538:	4798      	blx	r3
 800453a:	4606      	mov	r6, r0
 800453c:	2800      	cmp	r0, #0
 800453e:	f040 81c4 	bne.w	80048ca <SCSI_ProcessCmd+0x65a>
    hmsc->scsi_blk_addr = ((uint32_t)params[2] << 24) |
 8004542:	f8d5 2002 	ldr.w	r2, [r5, #2]
 8004546:	ba12      	rev	r2, r2
 8004548:	f8c8 2164 	str.w	r2, [r8, #356]	; 0x164
    hmsc->scsi_blk_len = ((uint32_t)params[7] <<  8) | (uint32_t)params[8];
 800454c:	f8b5 3007 	ldrh.w	r3, [r5, #7]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
 8004550:	f8d4 52b8 	ldr.w	r5, [r4, #696]	; 0x2b8
 8004554:	ba5b      	rev16	r3, r3
 8004556:	b29b      	uxth	r3, r3
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 8004558:	f8d5 0160 	ldr.w	r0, [r5, #352]	; 0x160
 800455c:	441a      	add	r2, r3
 800455e:	4282      	cmp	r2, r0
    hmsc->scsi_blk_len = ((uint32_t)params[7] <<  8) | (uint32_t)params[8];
 8004560:	f8c8 3168 	str.w	r3, [r8, #360]	; 0x168
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 8004564:	f200 8099 	bhi.w	800469a <SCSI_ProcessCmd+0x42a>
    hmsc->bot_state = USBD_BOT_DATA_IN;
 8004568:	2202      	movs	r2, #2
 800456a:	f888 2008 	strb.w	r2, [r8, #8]
    if (hmsc->cbw.dDataLength != (hmsc->scsi_blk_len * hmsc->scsi_blk_size))
 800456e:	f8b8 215e 	ldrh.w	r2, [r8, #350]	; 0x15e
 8004572:	fb02 f303 	mul.w	r3, r2, r3
 8004576:	f8d8 2114 	ldr.w	r2, [r8, #276]	; 0x114
 800457a:	429a      	cmp	r2, r3
 800457c:	f040 808d 	bne.w	800469a <SCSI_ProcessCmd+0x42a>
  hmsc->bot_data_length = MSC_MEDIA_PACKET;
 8004580:	f44f 7280 	mov.w	r2, #256	; 0x100
* @retval status
*/
static int8_t SCSI_ProcessRead(USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 8004584:	f8b5 315e 	ldrh.w	r3, [r5, #350]	; 0x15e
 8004588:	f8d5 7168 	ldr.w	r7, [r5, #360]	; 0x168

  len = MIN(len, MSC_MEDIA_PACKET);

  if (((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 800458c:	f8d4 12bc 	ldr.w	r1, [r4, #700]	; 0x2bc
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 8004590:	fb03 f707 	mul.w	r7, r3, r7
  len = MIN(len, MSC_MEDIA_PACKET);
 8004594:	4297      	cmp	r7, r2
 8004596:	bf28      	it	cs
 8004598:	4617      	movcs	r7, r2
                                                     hmsc->bot_data,
                                                     hmsc->scsi_blk_addr,
                                                     (len / hmsc->scsi_blk_size)) < 0)
 800459a:	fbb7 f3f3 	udiv	r3, r7, r3
                                                     hmsc->bot_data,
 800459e:	f105 060c 	add.w	r6, r5, #12
  if (((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 80045a2:	f8d1 9010 	ldr.w	r9, [r1, #16]
 80045a6:	4650      	mov	r0, sl
  hmsc->bot_data_length = MSC_MEDIA_PACKET;
 80045a8:	f8a8 200a 	strh.w	r2, [r8, #10]
  if (((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 80045ac:	4631      	mov	r1, r6
 80045ae:	f8d5 2164 	ldr.w	r2, [r5, #356]	; 0x164
 80045b2:	b29b      	uxth	r3, r3
 80045b4:	47c8      	blx	r9
 80045b6:	2800      	cmp	r0, #0
 80045b8:	f2c0 80fe 	blt.w	80047b8 <SCSI_ProcessCmd+0x548>
  {
    SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, UNRECOVERED_READ_ERROR);
    return -1;
  }

  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, hmsc->bot_data, len);
 80045bc:	4632      	mov	r2, r6
 80045be:	b2bb      	uxth	r3, r7
 80045c0:	4620      	mov	r0, r4
 80045c2:	2181      	movs	r1, #129	; 0x81
 80045c4:	f001 f896 	bl	80056f4 <USBD_LL_Transmit>

  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 80045c8:	f8b5 015e 	ldrh.w	r0, [r5, #350]	; 0x15e
 80045cc:	f8d5 3164 	ldr.w	r3, [r5, #356]	; 0x164
 80045d0:	fbb7 f0f0 	udiv	r0, r7, r0
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 80045d4:	f8d5 6168 	ldr.w	r6, [r5, #360]	; 0x168

  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 80045d8:	f8d5 2134 	ldr.w	r2, [r5, #308]	; 0x134
  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 80045dc:	4403      	add	r3, r0
  hmsc->csw.dDataResidue -= len;
 80045de:	1bd2      	subs	r2, r2, r7
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 80045e0:	1a36      	subs	r6, r6, r0
 80045e2:	e9c5 3659 	strd	r3, r6, [r5, #356]	; 0x164
  hmsc->csw.dDataResidue -= len;
 80045e6:	f8c5 2134 	str.w	r2, [r5, #308]	; 0x134

  if (hmsc->scsi_blk_len == 0U)
 80045ea:	2e00      	cmp	r6, #0
 80045ec:	f47f af00 	bne.w	80043f0 <SCSI_ProcessCmd+0x180>
  {
    hmsc->bot_state = USBD_BOT_LAST_DATA_IN;
 80045f0:	2303      	movs	r3, #3
 80045f2:	722b      	strb	r3, [r5, #8]
 80045f4:	e6b8      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
    hmsc->bot_data[i] = 0U;
 80045f6:	2600      	movs	r6, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80045f8:	f8d0 52b8 	ldr.w	r5, [r0, #696]	; 0x2b8
  if (((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &blk_nbr, &blk_size) != 0U)
 80045fc:	f10d 0202 	add.w	r2, sp, #2
    hmsc->bot_data[i] = 0U;
 8004600:	60ee      	str	r6, [r5, #12]
 8004602:	612e      	str	r6, [r5, #16]
 8004604:	616e      	str	r6, [r5, #20]
  if (((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &blk_nbr, &blk_size) != 0U)
 8004606:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 800460a:	4608      	mov	r0, r1
 800460c:	685b      	ldr	r3, [r3, #4]
 800460e:	a901      	add	r1, sp, #4
 8004610:	4798      	blx	r3
 8004612:	2800      	cmp	r0, #0
 8004614:	f040 80be 	bne.w	8004794 <SCSI_ProcessCmd+0x524>
    hmsc->bot_data[3] = 0x08U;
 8004618:	2208      	movs	r2, #8
    hmsc->bot_data[8] = 0x02U;
 800461a:	2002      	movs	r0, #2
    hmsc->bot_data_length = 12U;
 800461c:	210c      	movs	r1, #12
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 800461e:	9b01      	ldr	r3, [sp, #4]
    hmsc->bot_data[3] = 0x08U;
 8004620:	73ea      	strb	r2, [r5, #15]
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 8004622:	3b01      	subs	r3, #1
 8004624:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    hmsc->bot_data[8] = 0x02U;
 8004628:	82a8      	strh	r0, [r5, #20]
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 800462a:	0e18      	lsrs	r0, r3, #24
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1U);
 800462c:	74eb      	strb	r3, [r5, #19]
 800462e:	ba52      	rev16	r2, r2
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 8004630:	7428      	strb	r0, [r5, #16]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1U) >> 16);
 8004632:	0c18      	lsrs	r0, r3, #16
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1U) >>  8);
 8004634:	0a1b      	lsrs	r3, r3, #8
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1U) >> 16);
 8004636:	7468      	strb	r0, [r5, #17]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1U) >>  8);
 8004638:	74ab      	strb	r3, [r5, #18]
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 800463a:	82ea      	strh	r2, [r5, #22]
    hmsc->bot_data_length = 12U;
 800463c:	8169      	strh	r1, [r5, #10]
    return 0;
 800463e:	e6d7      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  if (((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &hmsc->scsi_blk_nbr, &hmsc->scsi_blk_size) != 0)
 8004640:	e9d0 53ae 	ldrd	r5, r3, [r0, #696]	; 0x2b8
 8004644:	4608      	mov	r0, r1
 8004646:	685b      	ldr	r3, [r3, #4]
 8004648:	f505 72af 	add.w	r2, r5, #350	; 0x15e
 800464c:	f505 71b0 	add.w	r1, r5, #352	; 0x160
 8004650:	4798      	blx	r3
 8004652:	4606      	mov	r6, r0
 8004654:	2800      	cmp	r0, #0
 8004656:	f040 808a 	bne.w	800476e <SCSI_ProcessCmd+0x4fe>
    hmsc->bot_data_length = 8U;
 800465a:	2108      	movs	r1, #8
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >> 24);
 800465c:	f8d5 3160 	ldr.w	r3, [r5, #352]	; 0x160
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 8004660:	8228      	strh	r0, [r5, #16]
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >> 24);
 8004662:	3b01      	subs	r3, #1
 8004664:	0e1a      	lsrs	r2, r3, #24
 8004666:	732a      	strb	r2, [r5, #12]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >> 16);
 8004668:	0c1a      	lsrs	r2, r3, #16
 800466a:	736a      	strb	r2, [r5, #13]
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >>  8);
 800466c:	fa23 f201 	lsr.w	r2, r3, r1
 8004670:	73aa      	strb	r2, [r5, #14]
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1U);
 8004672:	f8b5 215e 	ldrh.w	r2, [r5, #350]	; 0x15e
 8004676:	73eb      	strb	r3, [r5, #15]
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 8004678:	ba53      	rev16	r3, r2
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 800467a:	826b      	strh	r3, [r5, #18]
    hmsc->bot_data_length = 8U;
 800467c:	8169      	strh	r1, [r5, #10]
    return 0;
 800467e:	e673      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->bot_data_length = len;
 8004680:	2108      	movs	r1, #8
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 8004682:	4a29      	ldr	r2, [pc, #164]	; (8004728 <SCSI_ProcessCmd+0x4b8>)
 8004684:	e6ad      	b.n	80043e2 <SCSI_ProcessCmd+0x172>
    hmsc->bot_data_length = len;
 8004686:	2107      	movs	r1, #7
      hmsc->bot_data[len] = MSC_Page00_Inquiry_Data[len];
 8004688:	4b28      	ldr	r3, [pc, #160]	; (800472c <SCSI_ProcessCmd+0x4bc>)
    hmsc->bot_data_length = len;
 800468a:	8151      	strh	r1, [r2, #10]
      hmsc->bot_data[len] = MSC_Page00_Inquiry_Data[len];
 800468c:	6818      	ldr	r0, [r3, #0]
 800468e:	889c      	ldrh	r4, [r3, #4]
 8004690:	799b      	ldrb	r3, [r3, #6]
 8004692:	8214      	strh	r4, [r2, #16]
 8004694:	60d0      	str	r0, [r2, #12]
 8004696:	7493      	strb	r3, [r2, #18]
 8004698:	e6aa      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800469a:	2105      	movs	r1, #5
 800469c:	f895 315d 	ldrb.w	r3, [r5, #349]	; 0x15d
 80046a0:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
  hmsc->scsi_sense_tail++;
 80046a4:	3301      	adds	r3, #1
 80046a6:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80046a8:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80046aa:	f882 6140 	strb.w	r6, [r2, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80046ae:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80046b2:	f000 80f3 	beq.w	800489c <SCSI_ProcessCmd+0x62c>
  hmsc->scsi_sense_tail++;
 80046b6:	f885 315d 	strb.w	r3, [r5, #349]	; 0x15d
 80046ba:	e699      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
 80046bc:	4645      	mov	r5, r8
 80046be:	e75f      	b.n	8004580 <SCSI_ProcessCmd+0x310>
*/

static int8_t SCSI_ProcessWrite(USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *) pdev->pClassData;
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 80046c0:	f8b7 315e 	ldrh.w	r3, [r7, #350]	; 0x15e
 80046c4:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168

  len = MIN(len, MSC_MEDIA_PACKET);

  if (((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun, hmsc->bot_data,
 80046c8:	f107 080c 	add.w	r8, r7, #12
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 80046cc:	fb02 f503 	mul.w	r5, r2, r3
  len = MIN(len, MSC_MEDIA_PACKET);
 80046d0:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 80046d4:	bf28      	it	cs
 80046d6:	f44f 7580 	movcs.w	r5, #256	; 0x100
                                                      hmsc->scsi_blk_addr,
                                                      (len / hmsc->scsi_blk_size)) < 0)
 80046da:	fbb5 f3f3 	udiv	r3, r5, r3
  if (((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun, hmsc->bot_data,
 80046de:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
 80046e2:	4608      	mov	r0, r1
 80046e4:	6956      	ldr	r6, [r2, #20]
 80046e6:	4641      	mov	r1, r8
 80046e8:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80046ec:	b29b      	uxth	r3, r3
 80046ee:	47b0      	blx	r6
 80046f0:	2800      	cmp	r0, #0
 80046f2:	db61      	blt.n	80047b8 <SCSI_ProcessCmd+0x548>
    SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, WRITE_FAULT);

    return -1;
  }

  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 80046f4:	f8b7 315e 	ldrh.w	r3, [r7, #350]	; 0x15e
 80046f8:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80046fc:	fbb5 f0f3 	udiv	r0, r5, r3
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 8004700:	f8d7 6168 	ldr.w	r6, [r7, #360]	; 0x168

  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 8004704:	f8d7 1134 	ldr.w	r1, [r7, #308]	; 0x134
  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 8004708:	4402      	add	r2, r0
  hmsc->csw.dDataResidue -= len;
 800470a:	1b49      	subs	r1, r1, r5
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 800470c:	1a36      	subs	r6, r6, r0
 800470e:	e9c7 2659 	strd	r2, r6, [r7, #356]	; 0x164
  hmsc->csw.dDataResidue -= len;
 8004712:	f8c7 1134 	str.w	r1, [r7, #308]	; 0x134

  if (hmsc->scsi_blk_len == 0U)
 8004716:	b95e      	cbnz	r6, 8004730 <SCSI_ProcessCmd+0x4c0>
  {
    MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_PASSED);
 8004718:	4631      	mov	r1, r6
 800471a:	4620      	mov	r0, r4
 800471c:	f7ff fcb6 	bl	800408c <MSC_BOT_SendCSW>
 8004720:	e622      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
 8004722:	bf00      	nop
 8004724:	080068d4 	.word	0x080068d4
 8004728:	080068cc 	.word	0x080068cc
 800472c:	080068dc 	.word	0x080068dc
  }
  else
  {
    len = MIN((hmsc->scsi_blk_len * hmsc->scsi_blk_size), MSC_MEDIA_PACKET);
 8004730:	fb06 f303 	mul.w	r3, r6, r3
 8004734:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004738:	bf28      	it	cs
 800473a:	f44f 7380 	movcs.w	r3, #256	; 0x100
    /* Prepare EP to Receive next packet */
    USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, hmsc->bot_data, len);
 800473e:	4642      	mov	r2, r8
 8004740:	2101      	movs	r1, #1
 8004742:	4620      	mov	r0, r4
 8004744:	b29b      	uxth	r3, r3
  return 0;
 8004746:	2600      	movs	r6, #0
    USBD_LL_PrepareReceive(pdev, MSC_EPOUT_ADDR, hmsc->bot_data, len);
 8004748:	f000 ffe2 	bl	8005710 <USBD_LL_PrepareReceive>
 800474c:	e60c      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800474e:	2005      	movs	r0, #5
 8004750:	f891 315d 	ldrb.w	r3, [r1, #349]	; 0x15d
 8004754:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
  hmsc->scsi_sense_tail++;
 8004758:	3301      	adds	r3, #1
 800475a:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 800475c:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800475e:	f882 6140 	strb.w	r6, [r2, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004762:	f882 013c 	strb.w	r0, [r2, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004766:	d03b      	beq.n	80047e0 <SCSI_ProcessCmd+0x570>
  hmsc->scsi_sense_tail++;
 8004768:	f881 315d 	strb.w	r3, [r1, #349]	; 0x15d
 800476c:	e640      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800476e:	2502      	movs	r5, #2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004770:	2100      	movs	r1, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004772:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004776:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 800477a:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 800477e:	3301      	adds	r3, #1
 8004780:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004782:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004784:	f880 513c 	strb.w	r5, [r0, #316]	; 0x13c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004788:	f880 1140 	strb.w	r1, [r0, #320]	; 0x140
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 800478c:	d024      	beq.n	80047d8 <SCSI_ProcessCmd+0x568>
  hmsc->scsi_sense_tail++;
 800478e:	f882 315d 	strb.w	r3, [r2, #349]	; 0x15d
 8004792:	e62d      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004794:	2002      	movs	r0, #2
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004796:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800479a:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 800479e:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 80047a2:	3301      	adds	r3, #1
 80047a4:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80047a6:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80047a8:	f881 6140 	strb.w	r6, [r1, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047ac:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80047b0:	d1ed      	bne.n	800478e <SCSI_ProcessCmd+0x51e>
    hmsc->scsi_sense_tail = 0U;
 80047b2:	f882 615d 	strb.w	r6, [r2, #349]	; 0x15d
 80047b6:	e61b      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047b8:	2504      	movs	r5, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80047ba:	2100      	movs	r1, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80047bc:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047c0:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 80047c4:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 80047c8:	3301      	adds	r3, #1
 80047ca:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80047cc:	42ab      	cmp	r3, r5
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047ce:	f880 513c 	strb.w	r5, [r0, #316]	; 0x13c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80047d2:	f880 1140 	strb.w	r1, [r0, #320]	; 0x140
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80047d6:	d1da      	bne.n	800478e <SCSI_ProcessCmd+0x51e>
  return 0;
 80047d8:	460e      	mov	r6, r1
    hmsc->scsi_sense_tail = 0U;
 80047da:	f882 115d 	strb.w	r1, [r2, #349]	; 0x15d
 80047de:	e5c3      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
 80047e0:	f881 615d 	strb.w	r6, [r1, #349]	; 0x15d
 80047e4:	e5c0      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047e6:	2005      	movs	r0, #5
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80047e8:	2200      	movs	r2, #0
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047ea:	f895 315d 	ldrb.w	r3, [r5, #349]	; 0x15d
 80047ee:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
  hmsc->scsi_sense_tail++;
 80047f2:	3301      	adds	r3, #1
 80047f4:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80047f6:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80047f8:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80047fc:	f881 2140 	strb.w	r2, [r1, #320]	; 0x140
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004800:	f47f af59 	bne.w	80046b6 <SCSI_ProcessCmd+0x446>
  return 0;
 8004804:	4616      	mov	r6, r2
    hmsc->scsi_sense_tail = 0U;
 8004806:	f885 215d 	strb.w	r2, [r5, #349]	; 0x15d
 800480a:	e5ad      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800480c:	2002      	movs	r0, #2
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 800480e:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  return 0;
 8004812:	2600      	movs	r6, #0
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004814:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 8004818:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 800481c:	3301      	adds	r3, #1
 800481e:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004820:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004822:	f881 7140 	strb.w	r7, [r1, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004826:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
  hmsc->scsi_sense_tail++;
 800482a:	bf18      	it	ne
 800482c:	f882 315d 	strbne.w	r3, [r2, #349]	; 0x15d
    hmsc->bot_state = USBD_BOT_NO_DATA;
 8004830:	f04f 0305 	mov.w	r3, #5
    hmsc->scsi_sense_tail = 0U;
 8004834:	bf08      	it	eq
 8004836:	f882 715d 	strbeq.w	r7, [r2, #349]	; 0x15d
    hmsc->bot_state = USBD_BOT_NO_DATA;
 800483a:	722b      	strb	r3, [r5, #8]
    return -1;
 800483c:	e594      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800483e:	2405      	movs	r4, #5
 8004840:	f892 115d 	ldrb.w	r1, [r2, #349]	; 0x15d
 8004844:	eb02 00c1 	add.w	r0, r2, r1, lsl #3
  hmsc->scsi_sense_tail++;
 8004848:	3101      	adds	r1, #1
 800484a:	b2c9      	uxtb	r1, r1
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 800484c:	2904      	cmp	r1, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800484e:	f880 3140 	strb.w	r3, [r0, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004852:	f880 413c 	strb.w	r4, [r0, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004856:	d070      	beq.n	800493a <SCSI_ProcessCmd+0x6ca>
  hmsc->scsi_sense_tail++;
 8004858:	f882 115d 	strb.w	r1, [r2, #349]	; 0x15d
 800485c:	e5c8      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800485e:	2405      	movs	r4, #5
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004860:	2100      	movs	r1, #0
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004862:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 8004866:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 800486a:	3301      	adds	r3, #1
 800486c:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 800486e:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004870:	f880 413c 	strb.w	r4, [r0, #316]	; 0x13c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004874:	f880 1140 	strb.w	r1, [r0, #320]	; 0x140
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004878:	d189      	bne.n	800478e <SCSI_ProcessCmd+0x51e>
 800487a:	e7ad      	b.n	80047d8 <SCSI_ProcessCmd+0x568>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800487c:	2105      	movs	r1, #5
 800487e:	f898 315d 	ldrb.w	r3, [r8, #349]	; 0x15d
 8004882:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
  hmsc->scsi_sense_tail++;
 8004886:	3301      	adds	r3, #1
 8004888:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 800488a:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800488c:	f882 7140 	strb.w	r7, [r2, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8004890:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004894:	d055      	beq.n	8004942 <SCSI_ProcessCmd+0x6d2>
  hmsc->scsi_sense_tail++;
 8004896:	f888 315d 	strb.w	r3, [r8, #349]	; 0x15d
 800489a:	e5a9      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
    hmsc->scsi_sense_tail = 0U;
 800489c:	f885 615d 	strb.w	r6, [r5, #349]	; 0x15d
 80048a0:	e562      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048a2:	2002      	movs	r0, #2
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80048a4:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048a8:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 80048ac:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 80048b0:	3301      	adds	r3, #1
 80048b2:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80048b4:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80048b6:	f881 8140 	strb.w	r8, [r1, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048ba:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80048be:	f47f af66 	bne.w	800478e <SCSI_ProcessCmd+0x51e>
  return 0;
 80048c2:	4646      	mov	r6, r8
    hmsc->scsi_sense_tail = 0U;
 80048c4:	f882 815d 	strb.w	r8, [r2, #349]	; 0x15d
 80048c8:	e54e      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048ca:	2002      	movs	r0, #2
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80048cc:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048d0:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 80048d4:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 80048d8:	3301      	adds	r3, #1
 80048da:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80048dc:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 80048de:	f881 7140 	strb.w	r7, [r1, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048e2:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 80048e6:	f47f af52 	bne.w	800478e <SCSI_ProcessCmd+0x51e>
  return 0;
 80048ea:	463e      	mov	r6, r7
    hmsc->scsi_sense_tail = 0U;
 80048ec:	f882 715d 	strb.w	r7, [r2, #349]	; 0x15d
 80048f0:	e53a      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048f2:	2002      	movs	r0, #2
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 80048f4:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 80048f8:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 80048fc:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 8004900:	3301      	adds	r3, #1
 8004902:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004904:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004906:	f881 9140 	strb.w	r9, [r1, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800490a:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 800490e:	f47f af3e 	bne.w	800478e <SCSI_ProcessCmd+0x51e>
  return 0;
 8004912:	464e      	mov	r6, r9
    hmsc->scsi_sense_tail = 0U;
 8004914:	f882 915d 	strb.w	r9, [r2, #349]	; 0x15d
 8004918:	e526      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800491a:	2105      	movs	r1, #5
 800491c:	f897 315d 	ldrb.w	r3, [r7, #349]	; 0x15d
 8004920:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
  hmsc->scsi_sense_tail++;
 8004924:	3301      	adds	r3, #1
 8004926:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004928:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800492a:	f882 9140 	strb.w	r9, [r2, #320]	; 0x140
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800492e:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004932:	d00a      	beq.n	800494a <SCSI_ProcessCmd+0x6da>
  hmsc->scsi_sense_tail++;
 8004934:	f887 315d 	strb.w	r3, [r7, #349]	; 0x15d
 8004938:	e55a      	b.n	80043f0 <SCSI_ProcessCmd+0x180>
  return 0;
 800493a:	461e      	mov	r6, r3
    hmsc->scsi_sense_tail = 0U;
 800493c:	f882 315d 	strb.w	r3, [r2, #349]	; 0x15d
 8004940:	e512      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  return 0;
 8004942:	463e      	mov	r6, r7
    hmsc->scsi_sense_tail = 0U;
 8004944:	f888 715d 	strb.w	r7, [r8, #349]	; 0x15d
 8004948:	e50e      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
  return 0;
 800494a:	464e      	mov	r6, r9
    hmsc->scsi_sense_tail = 0U;
 800494c:	f887 915d 	strb.w	r9, [r7, #349]	; 0x15d
 8004950:	e50a      	b.n	8004368 <SCSI_ProcessCmd+0xf8>
 8004952:	bf00      	nop

08004954 <SCSI_SenseCode>:
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8004954:	f04f 0c00 	mov.w	ip, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassData;
 8004958:	f8d0 12b8 	ldr.w	r1, [r0, #696]	; 0x2b8
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800495c:	f891 315d 	ldrb.w	r3, [r1, #349]	; 0x15d
 8004960:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
  hmsc->scsi_sense_tail++;
 8004964:	3301      	adds	r3, #1
 8004966:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8004968:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 800496a:	f880 213c 	strb.w	r2, [r0, #316]	; 0x13c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 800496e:	f880 c140 	strb.w	ip, [r0, #320]	; 0x140
  hmsc->scsi_sense_tail++;
 8004972:	bf14      	ite	ne
 8004974:	f881 315d 	strbne.w	r3, [r1, #349]	; 0x15d
    hmsc->scsi_sense_tail = 0U;
 8004978:	f881 c15d 	strbeq.w	ip, [r1, #349]	; 0x15d
}
 800497c:	4770      	bx	lr
 800497e:	bf00      	nop

08004980 <USBD_Init>:
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 8004980:	b188      	cbz	r0, 80049a6 <USBD_Init+0x26>
{
 8004982:	b508      	push	{r3, lr}
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class*/
  if (pdev->pClass != NULL)
 8004984:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004988:	b113      	cbz	r3, 8004990 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 800498a:	2300      	movs	r3, #0
 800498c:	f8c0 32b4 	str.w	r3, [r0, #692]	; 0x2b4
  }

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 8004990:	b109      	cbz	r1, 8004996 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8004992:	f8c0 12b0 	str.w	r1, [r0, #688]	; 0x2b0
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8004996:	2301      	movs	r3, #1
  pdev->id = id;
 8004998:	7002      	strb	r2, [r0, #0]
  pdev->dev_state = USBD_STATE_DEFAULT;
 800499a:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 800499e:	f000 fdf5 	bl	800558c <USBD_LL_Init>

  return USBD_OK;
 80049a2:	2000      	movs	r0, #0
}
 80049a4:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 80049a6:	2002      	movs	r0, #2
}
 80049a8:	4770      	bx	lr
 80049aa:	bf00      	nop

080049ac <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 80049ac:	4603      	mov	r3, r0
  USBD_StatusTypeDef status = USBD_OK;
  if (pclass != NULL)
 80049ae:	b119      	cbz	r1, 80049b8 <USBD_RegisterClass+0xc>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
    status = USBD_OK;
 80049b0:	2000      	movs	r0, #0
    pdev->pClass = pclass;
 80049b2:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
    status = USBD_OK;
 80049b6:	4770      	bx	lr
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 80049b8:	2002      	movs	r0, #2
  }

  return status;
}
 80049ba:	4770      	bx	lr

080049bc <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start(USBD_HandleTypeDef *pdev)
{
 80049bc:	b508      	push	{r3, lr}
  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 80049be:	f000 fe21 	bl	8005604 <USBD_LL_Start>

  return USBD_OK;
}
 80049c2:	2000      	movs	r0, #0
 80049c4:	bd08      	pop	{r3, pc}
 80049c6:	bf00      	nop

080049c8 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80049c8:	b508      	push	{r3, lr}
  USBD_StatusTypeDef ret = USBD_FAIL;

  if (pdev->pClass != NULL)
 80049ca:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 80049ce:	b11b      	cbz	r3, 80049d8 <USBD_SetClassConfig+0x10>
  {
    /* Set configuration  and Start the Class*/
    if (pdev->pClass->Init(pdev, cfgidx) == 0U)
 80049d0:	681b      	ldr	r3, [r3, #0]
 80049d2:	4798      	blx	r3
 80049d4:	b900      	cbnz	r0, 80049d8 <USBD_SetClassConfig+0x10>
      ret = USBD_OK;
    }
  }

  return ret;
}
 80049d6:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef ret = USBD_FAIL;
 80049d8:	2002      	movs	r0, #2
}
 80049da:	bd08      	pop	{r3, pc}

080049dc <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80049dc:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 80049de:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 80049e2:	685b      	ldr	r3, [r3, #4]
 80049e4:	4798      	blx	r3

  return USBD_OK;
}
 80049e6:	2000      	movs	r0, #0
 80049e8:	bd08      	pop	{r3, pc}
 80049ea:	bf00      	nop

080049ec <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80049ec:	b538      	push	{r3, r4, r5, lr}
 80049ee:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 80049f0:	f500 752a 	add.w	r5, r0, #680	; 0x2a8
 80049f4:	4628      	mov	r0, r5
 80049f6:	f000 fb5f 	bl	80050b8 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 80049fa:	2201      	movs	r2, #1

  pdev->ep0_data_len = pdev->request.wLength;
 80049fc:	f8b4 32ae 	ldrh.w	r3, [r4, #686]	; 0x2ae

  switch (pdev->request.bmRequest & 0x1FU)
 8004a00:	f894 12a8 	ldrb.w	r1, [r4, #680]	; 0x2a8
  pdev->ep0_data_len = pdev->request.wLength;
 8004a04:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
 8004a08:	f001 031f 	and.w	r3, r1, #31
  switch (pdev->request.bmRequest & 0x1FU)
 8004a0c:	4293      	cmp	r3, r2
  pdev->ep0_state = USBD_EP0_SETUP;
 8004a0e:	f8c4 2294 	str.w	r2, [r4, #660]	; 0x294
  switch (pdev->request.bmRequest & 0x1FU)
 8004a12:	d009      	beq.n	8004a28 <USBD_LL_SetupStage+0x3c>
 8004a14:	2b02      	cmp	r3, #2
 8004a16:	d013      	beq.n	8004a40 <USBD_LL_SetupStage+0x54>
 8004a18:	b163      	cbz	r3, 8004a34 <USBD_LL_SetupStage+0x48>
    case USB_REQ_RECIPIENT_ENDPOINT:
      USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8004a1a:	4620      	mov	r0, r4
 8004a1c:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8004a20:	f000 fe2a 	bl	8005678 <USBD_LL_StallEP>
      break;
  }

  return USBD_OK;
}
 8004a24:	2000      	movs	r0, #0
 8004a26:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdItfReq(pdev, &pdev->request);
 8004a28:	4629      	mov	r1, r5
 8004a2a:	4620      	mov	r0, r4
 8004a2c:	f000 fa74 	bl	8004f18 <USBD_StdItfReq>
}
 8004a30:	2000      	movs	r0, #0
 8004a32:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdDevReq(pdev, &pdev->request);
 8004a34:	4629      	mov	r1, r5
 8004a36:	4620      	mov	r0, r4
 8004a38:	f000 f8fa 	bl	8004c30 <USBD_StdDevReq>
}
 8004a3c:	2000      	movs	r0, #0
 8004a3e:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdEPReq(pdev, &pdev->request);
 8004a40:	4629      	mov	r1, r5
 8004a42:	4620      	mov	r0, r4
 8004a44:	f000 fa9c 	bl	8004f80 <USBD_StdEPReq>
}
 8004a48:	2000      	movs	r0, #0
 8004a4a:	bd38      	pop	{r3, r4, r5, pc}

08004a4c <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8004a4c:	b538      	push	{r3, r4, r5, lr}
 8004a4e:	4605      	mov	r5, r0
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 8004a50:	b969      	cbnz	r1, 8004a6e <USBD_LL_DataOutStage+0x22>
 8004a52:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 8004a54:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 8004a58:	2a03      	cmp	r2, #3
 8004a5a:	d015      	beq.n	8004a88 <USBD_LL_DataOutStage+0x3c>
        USBD_CtlSendStatus(pdev);
      }
    }
    else
    {
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 8004a5c:	2a05      	cmp	r2, #5
 8004a5e:	460c      	mov	r4, r1
 8004a60:	d10e      	bne.n	8004a80 <USBD_LL_DataOutStage+0x34>
      {
        /*
         * STATUS PHASE completed, update ep0_state to idle
         */
        pdev->ep0_state = USBD_EP0_IDLE;
 8004a62:	f8c5 1294 	str.w	r1, [r5, #660]	; 0x294
        USBD_LL_StallEP(pdev, 0U);
 8004a66:	f000 fe07 	bl	8005678 <USBD_LL_StallEP>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 8004a6a:	4620      	mov	r0, r4
}
 8004a6c:	bd38      	pop	{r3, r4, r5, pc}
  else if ((pdev->pClass->DataOut != NULL) &&
 8004a6e:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004a72:	699b      	ldr	r3, [r3, #24]
 8004a74:	b133      	cbz	r3, 8004a84 <USBD_LL_DataOutStage+0x38>
 8004a76:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 8004a7a:	2a03      	cmp	r2, #3
 8004a7c:	d102      	bne.n	8004a84 <USBD_LL_DataOutStage+0x38>
    pdev->pClass->DataOut(pdev, epnum);
 8004a7e:	4798      	blx	r3
  return USBD_OK;
 8004a80:	2000      	movs	r0, #0
}
 8004a82:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 8004a84:	2002      	movs	r0, #2
}
 8004a86:	bd38      	pop	{r3, r4, r5, pc}
      if (pep->rem_length > pep->maxpacket)
 8004a88:	e9d0 1258 	ldrd	r1, r2, [r0, #352]	; 0x160
 8004a8c:	4291      	cmp	r1, r2
 8004a8e:	d90c      	bls.n	8004aaa <USBD_LL_DataOutStage+0x5e>
        pep->rem_length -= pep->maxpacket;
 8004a90:	1a89      	subs	r1, r1, r2
        USBD_CtlContinueRx(pdev, pdata,
 8004a92:	428a      	cmp	r2, r1
 8004a94:	bf88      	it	hi
 8004a96:	b28a      	uxthhi	r2, r1
        pep->rem_length -= pep->maxpacket;
 8004a98:	f8c0 1160 	str.w	r1, [r0, #352]	; 0x160
        USBD_CtlContinueRx(pdev, pdata,
 8004a9c:	bf98      	it	ls
 8004a9e:	b292      	uxthls	r2, r2
 8004aa0:	4619      	mov	r1, r3
 8004aa2:	f000 fb6b 	bl	800517c <USBD_CtlContinueRx>
  return USBD_OK;
 8004aa6:	2000      	movs	r0, #0
}
 8004aa8:	bd38      	pop	{r3, r4, r5, pc}
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8004aaa:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004aae:	691b      	ldr	r3, [r3, #16]
 8004ab0:	b11b      	cbz	r3, 8004aba <USBD_LL_DataOutStage+0x6e>
 8004ab2:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 8004ab6:	2a03      	cmp	r2, #3
 8004ab8:	d004      	beq.n	8004ac4 <USBD_LL_DataOutStage+0x78>
        USBD_CtlSendStatus(pdev);
 8004aba:	4628      	mov	r0, r5
 8004abc:	f000 fb68 	bl	8005190 <USBD_CtlSendStatus>
  return USBD_OK;
 8004ac0:	2000      	movs	r0, #0
}
 8004ac2:	bd38      	pop	{r3, r4, r5, pc}
          pdev->pClass->EP0_RxReady(pdev);
 8004ac4:	4798      	blx	r3
 8004ac6:	e7f8      	b.n	8004aba <USBD_LL_DataOutStage+0x6e>

08004ac8 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8004ac8:	b570      	push	{r4, r5, r6, lr}
 8004aca:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 8004acc:	b961      	cbnz	r1, 8004ae8 <USBD_LL_DataInStage+0x20>
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 8004ace:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 8004ad2:	2b02      	cmp	r3, #2
 8004ad4:	d015      	beq.n	8004b02 <USBD_LL_DataInStage+0x3a>
        }
      }
    }
    else
    {
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 8004ad6:	f033 0304 	bics.w	r3, r3, #4
 8004ada:	d02e      	beq.n	8004b3a <USBD_LL_DataInStage+0x72>
      {
        USBD_LL_StallEP(pdev, 0x80U);
      }
    }

    if (pdev->dev_test_mode == 1U)
 8004adc:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 8004ae0:	2b01      	cmp	r3, #1
 8004ae2:	d031      	beq.n	8004b48 <USBD_LL_DataInStage+0x80>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 8004ae4:	2000      	movs	r0, #0
}
 8004ae6:	bd70      	pop	{r4, r5, r6, pc}
  else if ((pdev->pClass->DataIn != NULL) &&
 8004ae8:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004aec:	695b      	ldr	r3, [r3, #20]
 8004aee:	b133      	cbz	r3, 8004afe <USBD_LL_DataInStage+0x36>
 8004af0:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 8004af4:	2a03      	cmp	r2, #3
 8004af6:	d102      	bne.n	8004afe <USBD_LL_DataInStage+0x36>
    pdev->pClass->DataIn(pdev, epnum);
 8004af8:	4798      	blx	r3
  return USBD_OK;
 8004afa:	2000      	movs	r0, #0
}
 8004afc:	bd70      	pop	{r4, r5, r6, pc}
    return USBD_FAIL;
 8004afe:	2002      	movs	r0, #2
}
 8004b00:	bd70      	pop	{r4, r5, r6, pc}
      if (pep->rem_length > pep->maxpacket)
 8004b02:	e9d0 6308 	ldrd	r6, r3, [r0, #32]
 8004b06:	429e      	cmp	r6, r3
 8004b08:	d833      	bhi.n	8004b72 <USBD_LL_DataInStage+0xaa>
        if ((pep->total_length % pep->maxpacket == 0U) &&
 8004b0a:	69c2      	ldr	r2, [r0, #28]
 8004b0c:	fbb2 f5f3 	udiv	r5, r2, r3
 8004b10:	fb03 2515 	mls	r5, r3, r5, r2
 8004b14:	b9ed      	cbnz	r5, 8004b52 <USBD_LL_DataInStage+0x8a>
 8004b16:	4293      	cmp	r3, r2
 8004b18:	d81b      	bhi.n	8004b52 <USBD_LL_DataInStage+0x8a>
            (pep->total_length >= pep->maxpacket) &&
 8004b1a:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
 8004b1e:	429a      	cmp	r2, r3
 8004b20:	d217      	bcs.n	8004b52 <USBD_LL_DataInStage+0x8a>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 8004b22:	462a      	mov	r2, r5
 8004b24:	f000 fb20 	bl	8005168 <USBD_CtlContinueSendData>
          USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8004b28:	462b      	mov	r3, r5
 8004b2a:	462a      	mov	r2, r5
 8004b2c:	4629      	mov	r1, r5
 8004b2e:	4620      	mov	r0, r4
          pdev->ep0_data_len = 0U;
 8004b30:	f8c4 5298 	str.w	r5, [r4, #664]	; 0x298
          USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8004b34:	f000 fdec 	bl	8005710 <USBD_LL_PrepareReceive>
 8004b38:	e7d0      	b.n	8004adc <USBD_LL_DataInStage+0x14>
        USBD_LL_StallEP(pdev, 0x80U);
 8004b3a:	2180      	movs	r1, #128	; 0x80
 8004b3c:	f000 fd9c 	bl	8005678 <USBD_LL_StallEP>
    if (pdev->dev_test_mode == 1U)
 8004b40:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 8004b44:	2b01      	cmp	r3, #1
 8004b46:	d1cd      	bne.n	8004ae4 <USBD_LL_DataInStage+0x1c>
      pdev->dev_test_mode = 0U;
 8004b48:	2300      	movs	r3, #0
 8004b4a:	f884 32a0 	strb.w	r3, [r4, #672]	; 0x2a0
  return USBD_OK;
 8004b4e:	4618      	mov	r0, r3
}
 8004b50:	bd70      	pop	{r4, r5, r6, pc}
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 8004b52:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004b56:	68db      	ldr	r3, [r3, #12]
 8004b58:	b11b      	cbz	r3, 8004b62 <USBD_LL_DataInStage+0x9a>
 8004b5a:	f894 229c 	ldrb.w	r2, [r4, #668]	; 0x29c
 8004b5e:	2a03      	cmp	r2, #3
 8004b60:	d015      	beq.n	8004b8e <USBD_LL_DataInStage+0xc6>
          USBD_LL_StallEP(pdev, 0x80U);
 8004b62:	2180      	movs	r1, #128	; 0x80
 8004b64:	4620      	mov	r0, r4
 8004b66:	f000 fd87 	bl	8005678 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 8004b6a:	4620      	mov	r0, r4
 8004b6c:	f000 fb1c 	bl	80051a8 <USBD_CtlReceiveStatus>
 8004b70:	e7b4      	b.n	8004adc <USBD_LL_DataInStage+0x14>
        pep->rem_length -= pep->maxpacket;
 8004b72:	460d      	mov	r5, r1
 8004b74:	1af3      	subs	r3, r6, r3
        USBD_CtlContinueSendData(pdev, pdata, (uint16_t)pep->rem_length);
 8004b76:	4611      	mov	r1, r2
        pep->rem_length -= pep->maxpacket;
 8004b78:	6203      	str	r3, [r0, #32]
        USBD_CtlContinueSendData(pdev, pdata, (uint16_t)pep->rem_length);
 8004b7a:	b29a      	uxth	r2, r3
 8004b7c:	f000 faf4 	bl	8005168 <USBD_CtlContinueSendData>
        USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8004b80:	462b      	mov	r3, r5
 8004b82:	462a      	mov	r2, r5
 8004b84:	4629      	mov	r1, r5
 8004b86:	4620      	mov	r0, r4
 8004b88:	f000 fdc2 	bl	8005710 <USBD_LL_PrepareReceive>
 8004b8c:	e7a6      	b.n	8004adc <USBD_LL_DataInStage+0x14>
            pdev->pClass->EP0_TxSent(pdev);
 8004b8e:	4620      	mov	r0, r4
 8004b90:	4798      	blx	r3
 8004b92:	e7e6      	b.n	8004b62 <USBD_LL_DataInStage+0x9a>

08004b94 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8004b94:	b570      	push	{r4, r5, r6, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004b96:	2200      	movs	r2, #0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8004b98:	2640      	movs	r6, #64	; 0x40
{
 8004b9a:	4604      	mov	r4, r0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8004b9c:	2501      	movs	r5, #1
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004b9e:	4611      	mov	r1, r2
 8004ba0:	4633      	mov	r3, r6
 8004ba2:	f000 fd3d 	bl	8005620 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004ba6:	4633      	mov	r3, r6
 8004ba8:	2180      	movs	r1, #128	; 0x80
 8004baa:	2200      	movs	r2, #0
 8004bac:	4620      	mov	r0, r4
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8004bae:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8004bb2:	f8c4 6164 	str.w	r6, [r4, #356]	; 0x164
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004bb6:	f000 fd33 	bl	8005620 <USBD_LL_OpenEP>

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
 8004bba:	2100      	movs	r1, #0
  pdev->dev_config = 0U;
  pdev->dev_remote_wakeup = 0U;

  if (pdev->pClassData)
 8004bbc:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8004bc0:	61a5      	str	r5, [r4, #24]
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8004bc2:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 8004bc4:	f884 529c 	strb.w	r5, [r4, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 8004bc8:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
  pdev->dev_config = 0U;
 8004bcc:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 8004bce:	f8c4 12a4 	str.w	r1, [r4, #676]	; 0x2a4
  if (pdev->pClassData)
 8004bd2:	b123      	cbz	r3, 8004bde <USBD_LL_Reset+0x4a>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8004bd4:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004bd8:	4620      	mov	r0, r4
 8004bda:	685b      	ldr	r3, [r3, #4]
 8004bdc:	4798      	blx	r3
  }

  return USBD_OK;
}
 8004bde:	2000      	movs	r0, #0
 8004be0:	bd70      	pop	{r4, r5, r6, pc}
 8004be2:	bf00      	nop

08004be4 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 8004be4:	4603      	mov	r3, r0
  pdev->dev_speed = speed;

  return USBD_OK;
}
 8004be6:	2000      	movs	r0, #0
  pdev->dev_speed = speed;
 8004be8:	7419      	strb	r1, [r3, #16]
}
 8004bea:	4770      	bx	lr

08004bec <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 8004bec:	4603      	mov	r3, r0
  pdev->dev_old_state =  pdev->dev_state;
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8004bee:	2104      	movs	r1, #4
  pdev->dev_old_state =  pdev->dev_state;
 8004bf0:	f893 229c 	ldrb.w	r2, [r3, #668]	; 0x29c

  return USBD_OK;
}
 8004bf4:	2000      	movs	r0, #0
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8004bf6:	f883 129c 	strb.w	r1, [r3, #668]	; 0x29c
  pdev->dev_old_state =  pdev->dev_state;
 8004bfa:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d
}
 8004bfe:	4770      	bx	lr

08004c00 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8004c00:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004c04:	2b04      	cmp	r3, #4
  {
    pdev->dev_state = pdev->dev_old_state;
 8004c06:	bf04      	itt	eq
 8004c08:	f890 329d 	ldrbeq.w	r3, [r0, #669]	; 0x29d
 8004c0c:	f880 329c 	strbeq.w	r3, [r0, #668]	; 0x29c
  }

  return USBD_OK;
}
 8004c10:	2000      	movs	r0, #0
 8004c12:	4770      	bx	lr

08004c14 <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004c14:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 8004c18:	2a03      	cmp	r2, #3
 8004c1a:	d001      	beq.n	8004c20 <USBD_LL_SOF+0xc>
      pdev->pClass->SOF(pdev);
    }
  }

  return USBD_OK;
}
 8004c1c:	2000      	movs	r0, #0
 8004c1e:	4770      	bx	lr
{
 8004c20:	b508      	push	{r3, lr}
    if (pdev->pClass->SOF != NULL)
 8004c22:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004c26:	69db      	ldr	r3, [r3, #28]
 8004c28:	b103      	cbz	r3, 8004c2c <USBD_LL_SOF+0x18>
      pdev->pClass->SOF(pdev);
 8004c2a:	4798      	blx	r3
}
 8004c2c:	2000      	movs	r0, #0
 8004c2e:	bd08      	pop	{r3, pc}

08004c30 <USBD_StdDevReq>:
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq(USBD_HandleTypeDef *pdev,
                                   USBD_SetupReqTypedef *req)
{
 8004c30:	b530      	push	{r4, r5, lr}
 8004c32:	780b      	ldrb	r3, [r1, #0]
 8004c34:	460d      	mov	r5, r1
 8004c36:	f003 0360 	and.w	r3, r3, #96	; 0x60
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004c3a:	2b20      	cmp	r3, #32
{
 8004c3c:	4604      	mov	r4, r0
 8004c3e:	b083      	sub	sp, #12
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004c40:	d00d      	beq.n	8004c5e <USBD_StdDevReq+0x2e>
 8004c42:	2b40      	cmp	r3, #64	; 0x40
 8004c44:	d00b      	beq.n	8004c5e <USBD_StdDevReq+0x2e>
 8004c46:	b19b      	cbz	r3, 8004c70 <USBD_StdDevReq+0x40>
*/

void USBD_CtlError(USBD_HandleTypeDef *pdev,
                   USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev, 0x80U);
 8004c48:	2180      	movs	r1, #128	; 0x80
 8004c4a:	4620      	mov	r0, r4
 8004c4c:	f000 fd14 	bl	8005678 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8004c50:	2100      	movs	r1, #0
 8004c52:	4620      	mov	r0, r4
 8004c54:	f000 fd10 	bl	8005678 <USBD_LL_StallEP>
}
 8004c58:	2000      	movs	r0, #0
 8004c5a:	b003      	add	sp, #12
 8004c5c:	bd30      	pop	{r4, r5, pc}
      pdev->pClass->Setup(pdev, req);
 8004c5e:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004c62:	4629      	mov	r1, r5
 8004c64:	4620      	mov	r0, r4
 8004c66:	689b      	ldr	r3, [r3, #8]
 8004c68:	4798      	blx	r3
}
 8004c6a:	2000      	movs	r0, #0
 8004c6c:	b003      	add	sp, #12
 8004c6e:	bd30      	pop	{r4, r5, pc}
      switch (req->bRequest)
 8004c70:	784b      	ldrb	r3, [r1, #1]
 8004c72:	2b09      	cmp	r3, #9
 8004c74:	d8e8      	bhi.n	8004c48 <USBD_StdDevReq+0x18>
 8004c76:	a201      	add	r2, pc, #4	; (adr r2, 8004c7c <USBD_StdDevReq+0x4c>)
 8004c78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004c7c:	08004cd7 	.word	0x08004cd7
 8004c80:	08004d03 	.word	0x08004d03
 8004c84:	08004c49 	.word	0x08004c49
 8004c88:	08004d21 	.word	0x08004d21
 8004c8c:	08004c49 	.word	0x08004c49
 8004c90:	08004d29 	.word	0x08004d29
 8004c94:	08004d61 	.word	0x08004d61
 8004c98:	08004c49 	.word	0x08004c49
 8004c9c:	08004d95 	.word	0x08004d95
 8004ca0:	08004ca5 	.word	0x08004ca5
  cfgidx = (uint8_t)(req->wValue);
 8004ca4:	7889      	ldrb	r1, [r1, #2]
 8004ca6:	4d9b      	ldr	r5, [pc, #620]	; (8004f14 <USBD_StdDevReq+0x2e4>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8004ca8:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 8004caa:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8004cac:	d8cc      	bhi.n	8004c48 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 8004cae:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004cb2:	2b02      	cmp	r3, #2
 8004cb4:	f000 810c 	beq.w	8004ed0 <USBD_StdDevReq+0x2a0>
 8004cb8:	2b03      	cmp	r3, #3
 8004cba:	f000 80fa 	beq.w	8004eb2 <USBD_StdDevReq+0x282>
  USBD_LL_StallEP(pdev, 0x80U);
 8004cbe:	2180      	movs	r1, #128	; 0x80
 8004cc0:	f000 fcda 	bl	8005678 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8004cc4:	2100      	movs	r1, #0
 8004cc6:	4620      	mov	r0, r4
 8004cc8:	f000 fcd6 	bl	8005678 <USBD_LL_StallEP>
        USBD_ClrClassConfig(pdev, cfgidx);
 8004ccc:	4620      	mov	r0, r4
 8004cce:	7829      	ldrb	r1, [r5, #0]
 8004cd0:	f7ff fe84 	bl	80049dc <USBD_ClrClassConfig>
        break;
 8004cd4:	e7c0      	b.n	8004c58 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 8004cd6:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004cda:	3b01      	subs	r3, #1
 8004cdc:	2b02      	cmp	r3, #2
 8004cde:	d8b3      	bhi.n	8004c48 <USBD_StdDevReq+0x18>
      if (req->wLength != 0x2U)
 8004ce0:	88cb      	ldrh	r3, [r1, #6]
 8004ce2:	2b02      	cmp	r3, #2
 8004ce4:	d1b0      	bne.n	8004c48 <USBD_StdDevReq+0x18>
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 8004ce6:	2201      	movs	r2, #1
      if (pdev->dev_remote_wakeup)
 8004ce8:	f8d0 32a4 	ldr.w	r3, [r0, #676]	; 0x2a4
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 8004cec:	60c2      	str	r2, [r0, #12]
      if (pdev->dev_remote_wakeup)
 8004cee:	b10b      	cbz	r3, 8004cf4 <USBD_StdDevReq+0xc4>
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 8004cf0:	2303      	movs	r3, #3
 8004cf2:	60c3      	str	r3, [r0, #12]
      USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 8004cf4:	2202      	movs	r2, #2
 8004cf6:	4620      	mov	r0, r4
 8004cf8:	f104 010c 	add.w	r1, r4, #12
 8004cfc:	f000 fa26 	bl	800514c <USBD_CtlSendData>
      break;
 8004d00:	e7aa      	b.n	8004c58 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 8004d02:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004d06:	3b01      	subs	r3, #1
 8004d08:	2b02      	cmp	r3, #2
 8004d0a:	d89d      	bhi.n	8004c48 <USBD_StdDevReq+0x18>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8004d0c:	884b      	ldrh	r3, [r1, #2]
 8004d0e:	2b01      	cmp	r3, #1
 8004d10:	d1a2      	bne.n	8004c58 <USBD_StdDevReq+0x28>
        pdev->dev_remote_wakeup = 0U;
 8004d12:	2300      	movs	r3, #0
        USBD_CtlSendStatus(pdev);
 8004d14:	4620      	mov	r0, r4
        pdev->dev_remote_wakeup = 0U;
 8004d16:	f8c4 32a4 	str.w	r3, [r4, #676]	; 0x2a4
        USBD_CtlSendStatus(pdev);
 8004d1a:	f000 fa39 	bl	8005190 <USBD_CtlSendStatus>
 8004d1e:	e79b      	b.n	8004c58 <USBD_StdDevReq+0x28>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8004d20:	884b      	ldrh	r3, [r1, #2]
 8004d22:	2b01      	cmp	r3, #1
 8004d24:	d198      	bne.n	8004c58 <USBD_StdDevReq+0x28>
 8004d26:	e7f5      	b.n	8004d14 <USBD_StdDevReq+0xe4>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8004d28:	888b      	ldrh	r3, [r1, #4]
 8004d2a:	2b00      	cmp	r3, #0
 8004d2c:	d18c      	bne.n	8004c48 <USBD_StdDevReq+0x18>
 8004d2e:	88cb      	ldrh	r3, [r1, #6]
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	d189      	bne.n	8004c48 <USBD_StdDevReq+0x18>
 8004d34:	884d      	ldrh	r5, [r1, #2]
 8004d36:	2d7f      	cmp	r5, #127	; 0x7f
 8004d38:	d886      	bhi.n	8004c48 <USBD_StdDevReq+0x18>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004d3a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004d3e:	2b03      	cmp	r3, #3
 8004d40:	d082      	beq.n	8004c48 <USBD_StdDevReq+0x18>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8004d42:	b2e9      	uxtb	r1, r5
      pdev->dev_address = dev_addr;
 8004d44:	f880 129e 	strb.w	r1, [r0, #670]	; 0x29e
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 8004d48:	f000 fcc6 	bl	80056d8 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 8004d4c:	4620      	mov	r0, r4
 8004d4e:	f000 fa1f 	bl	8005190 <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8004d52:	2d00      	cmp	r5, #0
 8004d54:	f000 80d9 	beq.w	8004f0a <USBD_StdDevReq+0x2da>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8004d58:	2302      	movs	r3, #2
 8004d5a:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 8004d5e:	e77b      	b.n	8004c58 <USBD_StdDevReq+0x28>
  uint16_t len = 0U;
 8004d60:	2100      	movs	r1, #0
  switch (req->wValue >> 8)
 8004d62:	886a      	ldrh	r2, [r5, #2]
  uint16_t len = 0U;
 8004d64:	f8ad 1006 	strh.w	r1, [sp, #6]
  switch (req->wValue >> 8)
 8004d68:	0a13      	lsrs	r3, r2, #8
 8004d6a:	3b01      	subs	r3, #1
 8004d6c:	2b06      	cmp	r3, #6
 8004d6e:	f63f af6b 	bhi.w	8004c48 <USBD_StdDevReq+0x18>
 8004d72:	a101      	add	r1, pc, #4	; (adr r1, 8004d78 <USBD_StdDevReq+0x148>)
 8004d74:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8004d78:	08004e27 	.word	0x08004e27
 8004d7c:	08004e0f 	.word	0x08004e0f
 8004d80:	08004dfd 	.word	0x08004dfd
 8004d84:	08004c49 	.word	0x08004c49
 8004d88:	08004c49 	.word	0x08004c49
 8004d8c:	08004de7 	.word	0x08004de7
 8004d90:	08004db9 	.word	0x08004db9
  if (req->wLength != 1U)
 8004d94:	88ca      	ldrh	r2, [r1, #6]
 8004d96:	2a01      	cmp	r2, #1
 8004d98:	f47f af56 	bne.w	8004c48 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 8004d9c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004da0:	2b02      	cmp	r3, #2
 8004da2:	d871      	bhi.n	8004e88 <USBD_StdDevReq+0x258>
 8004da4:	2b00      	cmp	r3, #0
 8004da6:	f43f af4f 	beq.w	8004c48 <USBD_StdDevReq+0x18>
        pdev->dev_default_config = 0U;
 8004daa:	4601      	mov	r1, r0
 8004dac:	2300      	movs	r3, #0
 8004dae:	f841 3f08 	str.w	r3, [r1, #8]!
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 8004db2:	f000 f9cb 	bl	800514c <USBD_CtlSendData>
        break;
 8004db6:	e74f      	b.n	8004c58 <USBD_StdDevReq+0x28>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004db8:	7c03      	ldrb	r3, [r0, #16]
 8004dba:	2b00      	cmp	r3, #0
 8004dbc:	f47f af44 	bne.w	8004c48 <USBD_StdDevReq+0x18>
        pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8004dc0:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004dc4:	f10d 0006 	add.w	r0, sp, #6
 8004dc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004dca:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8004dcc:	2307      	movs	r3, #7
 8004dce:	7043      	strb	r3, [r0, #1]
    if ((len != 0U) && (req->wLength != 0U))
 8004dd0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8004dd4:	2a00      	cmp	r2, #0
 8004dd6:	d067      	beq.n	8004ea8 <USBD_StdDevReq+0x278>
 8004dd8:	88eb      	ldrh	r3, [r5, #6]
 8004dda:	2b00      	cmp	r3, #0
 8004ddc:	d15b      	bne.n	8004e96 <USBD_StdDevReq+0x266>
          USBD_CtlSendStatus(pdev);
 8004dde:	4620      	mov	r0, r4
 8004de0:	f000 f9d6 	bl	8005190 <USBD_CtlSendStatus>
 8004de4:	e738      	b.n	8004c58 <USBD_StdDevReq+0x28>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004de6:	7c03      	ldrb	r3, [r0, #16]
 8004de8:	2b00      	cmp	r3, #0
 8004dea:	f47f af2d 	bne.w	8004c48 <USBD_StdDevReq+0x18>
        pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8004dee:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004df2:	f10d 0006 	add.w	r0, sp, #6
 8004df6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004df8:	4798      	blx	r3
  if (err != 0U)
 8004dfa:	e7e9      	b.n	8004dd0 <USBD_StdDevReq+0x1a0>
      switch ((uint8_t)(req->wValue))
 8004dfc:	b2d2      	uxtb	r2, r2
 8004dfe:	2a05      	cmp	r2, #5
 8004e00:	f63f af22 	bhi.w	8004c48 <USBD_StdDevReq+0x18>
 8004e04:	e8df f002 	tbb	[pc, r2]
 8004e08:	282e343a 	.word	0x282e343a
 8004e0c:	1722      	.short	0x1722
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004e0e:	7c03      	ldrb	r3, [r0, #16]
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d16a      	bne.n	8004eea <USBD_StdDevReq+0x2ba>
        pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 8004e14:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004e18:	f10d 0006 	add.w	r0, sp, #6
 8004e1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004e1e:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004e20:	2302      	movs	r3, #2
 8004e22:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 8004e24:	e7d4      	b.n	8004dd0 <USBD_StdDevReq+0x1a0>
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8004e26:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e2a:	f10d 0106 	add.w	r1, sp, #6
 8004e2e:	681b      	ldr	r3, [r3, #0]
 8004e30:	7c00      	ldrb	r0, [r0, #16]
 8004e32:	4798      	blx	r3
  if (err != 0U)
 8004e34:	e7cc      	b.n	8004dd0 <USBD_StdDevReq+0x1a0>
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8004e36:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e3a:	699b      	ldr	r3, [r3, #24]
 8004e3c:	2b00      	cmp	r3, #0
 8004e3e:	f43f af03 	beq.w	8004c48 <USBD_StdDevReq+0x18>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8004e42:	7c20      	ldrb	r0, [r4, #16]
 8004e44:	f10d 0106 	add.w	r1, sp, #6
 8004e48:	4798      	blx	r3
  if (err != 0U)
 8004e4a:	e7c1      	b.n	8004dd0 <USBD_StdDevReq+0x1a0>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8004e4c:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e50:	695b      	ldr	r3, [r3, #20]
 8004e52:	2b00      	cmp	r3, #0
 8004e54:	d1f5      	bne.n	8004e42 <USBD_StdDevReq+0x212>
 8004e56:	e6f7      	b.n	8004c48 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8004e58:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e5c:	691b      	ldr	r3, [r3, #16]
 8004e5e:	2b00      	cmp	r3, #0
 8004e60:	d1ef      	bne.n	8004e42 <USBD_StdDevReq+0x212>
 8004e62:	e6f1      	b.n	8004c48 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8004e64:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e68:	68db      	ldr	r3, [r3, #12]
 8004e6a:	2b00      	cmp	r3, #0
 8004e6c:	d1e9      	bne.n	8004e42 <USBD_StdDevReq+0x212>
 8004e6e:	e6eb      	b.n	8004c48 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8004e70:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e74:	689b      	ldr	r3, [r3, #8]
 8004e76:	2b00      	cmp	r3, #0
 8004e78:	d1e3      	bne.n	8004e42 <USBD_StdDevReq+0x212>
 8004e7a:	e6e5      	b.n	8004c48 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8004e7c:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004e80:	685b      	ldr	r3, [r3, #4]
 8004e82:	2b00      	cmp	r3, #0
 8004e84:	d1dd      	bne.n	8004e42 <USBD_StdDevReq+0x212>
 8004e86:	e6df      	b.n	8004c48 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 8004e88:	2b03      	cmp	r3, #3
 8004e8a:	f47f aedd 	bne.w	8004c48 <USBD_StdDevReq+0x18>
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 8004e8e:	1d01      	adds	r1, r0, #4
 8004e90:	f000 f95c 	bl	800514c <USBD_CtlSendData>
        break;
 8004e94:	e6e0      	b.n	8004c58 <USBD_StdDevReq+0x28>
      len = MIN(len, req->wLength);
 8004e96:	429a      	cmp	r2, r3
 8004e98:	bf28      	it	cs
 8004e9a:	461a      	movcs	r2, r3
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8004e9c:	4601      	mov	r1, r0
 8004e9e:	4620      	mov	r0, r4
      len = MIN(len, req->wLength);
 8004ea0:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8004ea4:	f000 f952 	bl	800514c <USBD_CtlSendData>
    if (req->wLength == 0U)
 8004ea8:	88eb      	ldrh	r3, [r5, #6]
 8004eaa:	2b00      	cmp	r3, #0
 8004eac:	f47f aed4 	bne.w	8004c58 <USBD_StdDevReq+0x28>
 8004eb0:	e795      	b.n	8004dde <USBD_StdDevReq+0x1ae>
        if (cfgidx == 0U)
 8004eb2:	b319      	cbz	r1, 8004efc <USBD_StdDevReq+0x2cc>
        else if (cfgidx != pdev->dev_config)
 8004eb4:	6841      	ldr	r1, [r0, #4]
 8004eb6:	2901      	cmp	r1, #1
 8004eb8:	d091      	beq.n	8004dde <USBD_StdDevReq+0x1ae>
          USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8004eba:	b2c9      	uxtb	r1, r1
 8004ebc:	f7ff fd8e 	bl	80049dc <USBD_ClrClassConfig>
          pdev->dev_config = cfgidx;
 8004ec0:	7829      	ldrb	r1, [r5, #0]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004ec2:	4620      	mov	r0, r4
          pdev->dev_config = cfgidx;
 8004ec4:	6061      	str	r1, [r4, #4]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004ec6:	f7ff fd7f 	bl	80049c8 <USBD_SetClassConfig>
 8004eca:	2802      	cmp	r0, #2
 8004ecc:	d187      	bne.n	8004dde <USBD_StdDevReq+0x1ae>
 8004ece:	e6bb      	b.n	8004c48 <USBD_StdDevReq+0x18>
        if (cfgidx)
 8004ed0:	2900      	cmp	r1, #0
 8004ed2:	d084      	beq.n	8004dde <USBD_StdDevReq+0x1ae>
          pdev->dev_config = cfgidx;
 8004ed4:	2101      	movs	r1, #1
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8004ed6:	2303      	movs	r3, #3
          pdev->dev_config = cfgidx;
 8004ed8:	6041      	str	r1, [r0, #4]
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8004eda:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004ede:	f7ff fd73 	bl	80049c8 <USBD_SetClassConfig>
 8004ee2:	2802      	cmp	r0, #2
 8004ee4:	f47f af7b 	bne.w	8004dde <USBD_StdDevReq+0x1ae>
 8004ee8:	e6ae      	b.n	8004c48 <USBD_StdDevReq+0x18>
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 8004eea:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004eee:	f10d 0006 	add.w	r0, sp, #6
 8004ef2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004ef4:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004ef6:	2302      	movs	r3, #2
 8004ef8:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 8004efa:	e769      	b.n	8004dd0 <USBD_StdDevReq+0x1a0>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8004efc:	2302      	movs	r3, #2
          pdev->dev_config = cfgidx;
 8004efe:	6041      	str	r1, [r0, #4]
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8004f00:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
          USBD_ClrClassConfig(pdev, cfgidx);
 8004f04:	f7ff fd6a 	bl	80049dc <USBD_ClrClassConfig>
 8004f08:	e769      	b.n	8004dde <USBD_StdDevReq+0x1ae>
        pdev->dev_state = USBD_STATE_DEFAULT;
 8004f0a:	2301      	movs	r3, #1
 8004f0c:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 8004f10:	e6a2      	b.n	8004c58 <USBD_StdDevReq+0x28>
 8004f12:	bf00      	nop
 8004f14:	200002d8 	.word	0x200002d8

08004f18 <USBD_StdItfReq>:
{
 8004f18:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004f1a:	780b      	ldrb	r3, [r1, #0]
{
 8004f1c:	460d      	mov	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004f1e:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8004f22:	2a40      	cmp	r2, #64	; 0x40
{
 8004f24:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004f26:	d00a      	beq.n	8004f3e <USBD_StdItfReq+0x26>
 8004f28:	065b      	lsls	r3, r3, #25
 8004f2a:	d508      	bpl.n	8004f3e <USBD_StdItfReq+0x26>
  USBD_LL_StallEP(pdev, 0x80U);
 8004f2c:	2180      	movs	r1, #128	; 0x80
 8004f2e:	f000 fba3 	bl	8005678 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8004f32:	2100      	movs	r1, #0
 8004f34:	4620      	mov	r0, r4
 8004f36:	f000 fb9f 	bl	8005678 <USBD_LL_StallEP>
}
 8004f3a:	2000      	movs	r0, #0
 8004f3c:	bd38      	pop	{r3, r4, r5, pc}
      switch (pdev->dev_state)
 8004f3e:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8004f42:	3b01      	subs	r3, #1
 8004f44:	2b02      	cmp	r3, #2
 8004f46:	d811      	bhi.n	8004f6c <USBD_StdItfReq+0x54>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8004f48:	792b      	ldrb	r3, [r5, #4]
 8004f4a:	2b01      	cmp	r3, #1
 8004f4c:	d80e      	bhi.n	8004f6c <USBD_StdItfReq+0x54>
            ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8004f4e:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004f52:	4629      	mov	r1, r5
 8004f54:	689b      	ldr	r3, [r3, #8]
 8004f56:	4620      	mov	r0, r4
 8004f58:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8004f5a:	88eb      	ldrh	r3, [r5, #6]
 8004f5c:	2b00      	cmp	r3, #0
 8004f5e:	d1ec      	bne.n	8004f3a <USBD_StdItfReq+0x22>
 8004f60:	2800      	cmp	r0, #0
 8004f62:	d1ea      	bne.n	8004f3a <USBD_StdItfReq+0x22>
              USBD_CtlSendStatus(pdev);
 8004f64:	4620      	mov	r0, r4
 8004f66:	f000 f913 	bl	8005190 <USBD_CtlSendStatus>
 8004f6a:	e7e6      	b.n	8004f3a <USBD_StdItfReq+0x22>
  USBD_LL_StallEP(pdev, 0x80U);
 8004f6c:	2180      	movs	r1, #128	; 0x80
 8004f6e:	4620      	mov	r0, r4
 8004f70:	f000 fb82 	bl	8005678 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8004f74:	2100      	movs	r1, #0
 8004f76:	4620      	mov	r0, r4
 8004f78:	f000 fb7e 	bl	8005678 <USBD_LL_StallEP>
}
 8004f7c:	2000      	movs	r0, #0
 8004f7e:	bd38      	pop	{r3, r4, r5, pc}

08004f80 <USBD_StdEPReq>:
{
 8004f80:	b538      	push	{r3, r4, r5, lr}
 8004f82:	780b      	ldrb	r3, [r1, #0]
 8004f84:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004f86:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004f8a:	2b20      	cmp	r3, #32
 8004f8c:	d00c      	beq.n	8004fa8 <USBD_StdEPReq+0x28>
 8004f8e:	2b40      	cmp	r3, #64	; 0x40
 8004f90:	d00a      	beq.n	8004fa8 <USBD_StdEPReq+0x28>
 8004f92:	b183      	cbz	r3, 8004fb6 <USBD_StdEPReq+0x36>
  USBD_LL_StallEP(pdev, 0x80U);
 8004f94:	2180      	movs	r1, #128	; 0x80
 8004f96:	4620      	mov	r0, r4
 8004f98:	f000 fb6e 	bl	8005678 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8004f9c:	2100      	movs	r1, #0
 8004f9e:	4620      	mov	r0, r4
 8004fa0:	f000 fb6a 	bl	8005678 <USBD_LL_StallEP>
}
 8004fa4:	2000      	movs	r0, #0
 8004fa6:	bd38      	pop	{r3, r4, r5, pc}
      pdev->pClass->Setup(pdev, req);
 8004fa8:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004fac:	4620      	mov	r0, r4
 8004fae:	689b      	ldr	r3, [r3, #8]
 8004fb0:	4798      	blx	r3
}
 8004fb2:	2000      	movs	r0, #0
 8004fb4:	bd38      	pop	{r3, r4, r5, pc}
      switch (req->bRequest)
 8004fb6:	784b      	ldrb	r3, [r1, #1]
  ep_addr  = LOBYTE(req->wIndex);
 8004fb8:	888a      	ldrh	r2, [r1, #4]
 8004fba:	2b01      	cmp	r3, #1
 8004fbc:	fa5f fc82 	uxtb.w	ip, r2
      switch (req->bRequest)
 8004fc0:	d03e      	beq.n	8005040 <USBD_StdEPReq+0xc0>
 8004fc2:	2b03      	cmp	r3, #3
 8004fc4:	d02a      	beq.n	800501c <USBD_StdEPReq+0x9c>
 8004fc6:	2b00      	cmp	r3, #0
 8004fc8:	d1e4      	bne.n	8004f94 <USBD_StdEPReq+0x14>
          switch (pdev->dev_state)
 8004fca:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004fce:	2b02      	cmp	r3, #2
 8004fd0:	d051      	beq.n	8005076 <USBD_StdEPReq+0xf6>
 8004fd2:	2b03      	cmp	r3, #3
 8004fd4:	d1de      	bne.n	8004f94 <USBD_StdEPReq+0x14>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8004fd6:	f00c 030f 	and.w	r3, ip, #15
 8004fda:	eb03 0383 	add.w	r3, r3, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 8004fde:	0612      	lsls	r2, r2, #24
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8004fe0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 8004fe4:	d456      	bmi.n	8005094 <USBD_StdEPReq+0x114>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8004fe6:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 8004fea:	2b00      	cmp	r3, #0
 8004fec:	d0d2      	beq.n	8004f94 <USBD_StdEPReq+0x14>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8004fee:	f00c 037f 	and.w	r3, ip, #127	; 0x7f
 8004ff2:	eb03 0583 	add.w	r5, r3, r3, lsl #2
 8004ff6:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8004ffa:	f505 75aa 	add.w	r5, r5, #340	; 0x154
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8004ffe:	b133      	cbz	r3, 800500e <USBD_StdEPReq+0x8e>
              else if (USBD_LL_IsStallEP(pdev, ep_addr))
 8005000:	4661      	mov	r1, ip
 8005002:	4620      	mov	r0, r4
 8005004:	f000 fb54 	bl	80056b0 <USBD_LL_IsStallEP>
 8005008:	2800      	cmp	r0, #0
 800500a:	d04f      	beq.n	80050ac <USBD_StdEPReq+0x12c>
                pep->status = 0x0001U;
 800500c:	2301      	movs	r3, #1
 800500e:	602b      	str	r3, [r5, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 8005010:	2202      	movs	r2, #2
 8005012:	4629      	mov	r1, r5
 8005014:	4620      	mov	r0, r4
 8005016:	f000 f899 	bl	800514c <USBD_CtlSendData>
              break;
 800501a:	e7c3      	b.n	8004fa4 <USBD_StdEPReq+0x24>
          switch (pdev->dev_state)
 800501c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8005020:	2b02      	cmp	r3, #2
 8005022:	d01d      	beq.n	8005060 <USBD_StdEPReq+0xe0>
 8005024:	2b03      	cmp	r3, #3
 8005026:	d1b5      	bne.n	8004f94 <USBD_StdEPReq+0x14>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8005028:	884b      	ldrh	r3, [r1, #2]
 800502a:	b92b      	cbnz	r3, 8005038 <USBD_StdEPReq+0xb8>
                if ((ep_addr != 0x00U) &&
 800502c:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 8005030:	d002      	beq.n	8005038 <USBD_StdEPReq+0xb8>
                    (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8005032:	88cb      	ldrh	r3, [r1, #6]
 8005034:	2b00      	cmp	r3, #0
 8005036:	d03b      	beq.n	80050b0 <USBD_StdEPReq+0x130>
              USBD_CtlSendStatus(pdev);
 8005038:	4620      	mov	r0, r4
 800503a:	f000 f8a9 	bl	8005190 <USBD_CtlSendStatus>
              break;
 800503e:	e7b1      	b.n	8004fa4 <USBD_StdEPReq+0x24>
          switch (pdev->dev_state)
 8005040:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8005044:	2b02      	cmp	r3, #2
 8005046:	d00b      	beq.n	8005060 <USBD_StdEPReq+0xe0>
 8005048:	2b03      	cmp	r3, #3
 800504a:	d1a3      	bne.n	8004f94 <USBD_StdEPReq+0x14>
              if (req->wValue == USB_FEATURE_EP_HALT)
 800504c:	884b      	ldrh	r3, [r1, #2]
 800504e:	2b00      	cmp	r3, #0
 8005050:	d1a8      	bne.n	8004fa4 <USBD_StdEPReq+0x24>
                if ((ep_addr & 0x7FU) != 0x00U)
 8005052:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 8005056:	d0ef      	beq.n	8005038 <USBD_StdEPReq+0xb8>
                  USBD_LL_ClearStallEP(pdev, ep_addr);
 8005058:	4661      	mov	r1, ip
 800505a:	f000 fb1b 	bl	8005694 <USBD_LL_ClearStallEP>
 800505e:	e7eb      	b.n	8005038 <USBD_StdEPReq+0xb8>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8005060:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 8005064:	d096      	beq.n	8004f94 <USBD_StdEPReq+0x14>
                USBD_LL_StallEP(pdev, ep_addr);
 8005066:	4661      	mov	r1, ip
 8005068:	f000 fb06 	bl	8005678 <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 800506c:	2180      	movs	r1, #128	; 0x80
 800506e:	4620      	mov	r0, r4
 8005070:	f000 fb02 	bl	8005678 <USBD_LL_StallEP>
 8005074:	e796      	b.n	8004fa4 <USBD_StdEPReq+0x24>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8005076:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 800507a:	d18b      	bne.n	8004f94 <USBD_StdEPReq+0x14>
              pep->status = 0x0000U;
 800507c:	2300      	movs	r3, #0
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800507e:	0611      	lsls	r1, r2, #24
 8005080:	bf4c      	ite	mi
 8005082:	f100 0114 	addmi.w	r1, r0, #20
 8005086:	f500 71aa 	addpl.w	r1, r0, #340	; 0x154
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800508a:	2202      	movs	r2, #2
              pep->status = 0x0000U;
 800508c:	600b      	str	r3, [r1, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800508e:	f000 f85d 	bl	800514c <USBD_CtlSendData>
              break;
 8005092:	e787      	b.n	8004fa4 <USBD_StdEPReq+0x24>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8005094:	699b      	ldr	r3, [r3, #24]
 8005096:	2b00      	cmp	r3, #0
 8005098:	f43f af7c 	beq.w	8004f94 <USBD_StdEPReq+0x14>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800509c:	f00c 037f 	and.w	r3, ip, #127	; 0x7f
 80050a0:	1c5d      	adds	r5, r3, #1
 80050a2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 80050a6:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 80050aa:	e7a8      	b.n	8004ffe <USBD_StdEPReq+0x7e>
                pep->status = 0x0000U;
 80050ac:	6028      	str	r0, [r5, #0]
 80050ae:	e7af      	b.n	8005010 <USBD_StdEPReq+0x90>
                  USBD_LL_StallEP(pdev, ep_addr);
 80050b0:	4661      	mov	r1, ip
 80050b2:	f000 fae1 	bl	8005678 <USBD_LL_StallEP>
 80050b6:	e7bf      	b.n	8005038 <USBD_StdEPReq+0xb8>

080050b8 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pdata);
 80050b8:	780b      	ldrb	r3, [r1, #0]
 80050ba:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pdata + 1U);
 80050bc:	784b      	ldrb	r3, [r1, #1]
 80050be:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pdata + 2U);
 80050c0:	78ca      	ldrb	r2, [r1, #3]
 80050c2:	788b      	ldrb	r3, [r1, #2]
 80050c4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80050c8:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pdata + 4U);
 80050ca:	794a      	ldrb	r2, [r1, #5]
 80050cc:	790b      	ldrb	r3, [r1, #4]
 80050ce:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80050d2:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pdata + 6U);
 80050d4:	79ca      	ldrb	r2, [r1, #7]
 80050d6:	798b      	ldrb	r3, [r1, #6]
 80050d8:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80050dc:	80c3      	strh	r3, [r0, #6]
}
 80050de:	4770      	bx	lr

080050e0 <USBD_CtlError>:
{
 80050e0:	b510      	push	{r4, lr}
 80050e2:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev, 0x80U);
 80050e4:	2180      	movs	r1, #128	; 0x80
 80050e6:	f000 fac7 	bl	8005678 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 80050ea:	4620      	mov	r0, r4
}
 80050ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev, 0U);
 80050f0:	2100      	movs	r1, #0
 80050f2:	f000 bac1 	b.w	8005678 <USBD_LL_StallEP>
 80050f6:	bf00      	nop

080050f8 <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0U;

  if (desc != NULL)
 80050f8:	b318      	cbz	r0, 8005142 <USBD_GetString+0x4a>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;

  while (*buf != '\0')
 80050fa:	7803      	ldrb	r3, [r0, #0]
{
 80050fc:	b430      	push	{r4, r5}
  while (*buf != '\0')
 80050fe:	b30b      	cbz	r3, 8005144 <USBD_GetString+0x4c>
 8005100:	4604      	mov	r4, r0
 8005102:	f1c0 0c01 	rsb	ip, r0, #1
  {
    len++;
 8005106:	eb04 030c 	add.w	r3, r4, ip
  while (*buf != '\0')
 800510a:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 800510e:	b2db      	uxtb	r3, r3
 8005110:	2d00      	cmp	r5, #0
 8005112:	d1f8      	bne.n	8005106 <USBD_GetString+0xe>
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 8005114:	3301      	adds	r3, #1
 8005116:	005b      	lsls	r3, r3, #1
 8005118:	b2dc      	uxtb	r4, r3
 800511a:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 800511c:	2303      	movs	r3, #3
    unicode[idx++] = *(uint8_t *)(void *)len;
 800511e:	700c      	strb	r4, [r1, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8005120:	704b      	strb	r3, [r1, #1]
    while (*desc != '\0')
 8005122:	7804      	ldrb	r4, [r0, #0]
 8005124:	b15c      	cbz	r4, 800513e <USBD_GetString+0x46>
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8005126:	2302      	movs	r3, #2
      unicode[idx++] =  0U;
 8005128:	2500      	movs	r5, #0
      unicode[idx++] = *desc++;
 800512a:	1c5a      	adds	r2, r3, #1
 800512c:	b2d2      	uxtb	r2, r2
 800512e:	54cc      	strb	r4, [r1, r3]
      unicode[idx++] =  0U;
 8005130:	548d      	strb	r5, [r1, r2]
    while (*desc != '\0')
 8005132:	f810 4f01 	ldrb.w	r4, [r0, #1]!
      unicode[idx++] =  0U;
 8005136:	3302      	adds	r3, #2
 8005138:	b2db      	uxtb	r3, r3
    while (*desc != '\0')
 800513a:	2c00      	cmp	r4, #0
 800513c:	d1f5      	bne.n	800512a <USBD_GetString+0x32>
}
 800513e:	bc30      	pop	{r4, r5}
 8005140:	4770      	bx	lr
 8005142:	4770      	bx	lr
  while (*buf != '\0')
 8005144:	2402      	movs	r4, #2
 8005146:	4623      	mov	r3, r4
 8005148:	e7e7      	b.n	800511a <USBD_GetString+0x22>
 800514a:	bf00      	nop

0800514c <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint16_t len)
{
 800514c:	b510      	push	{r4, lr}
 800514e:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8005150:	2402      	movs	r4, #2
{
 8005152:	460a      	mov	r2, r1
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 8005154:	e9c0 3307 	strd	r3, r3, [r0, #28]

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8005158:	2100      	movs	r1, #0
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800515a:	f8c0 4294 	str.w	r4, [r0, #660]	; 0x294
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800515e:	f000 fac9 	bl	80056f4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8005162:	2000      	movs	r0, #0
 8005164:	bd10      	pop	{r4, pc}
 8005166:	bf00      	nop

08005168 <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint16_t len)
{
 8005168:	468c      	mov	ip, r1
 800516a:	b508      	push	{r3, lr}
  /* Start the next transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800516c:	2100      	movs	r1, #0
{
 800516e:	4613      	mov	r3, r2
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8005170:	4662      	mov	r2, ip
 8005172:	f000 fabf 	bl	80056f4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8005176:	2000      	movs	r0, #0
 8005178:	bd08      	pop	{r3, pc}
 800517a:	bf00      	nop

0800517c <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint16_t len)
{
 800517c:	468c      	mov	ip, r1
 800517e:	b508      	push	{r3, lr}
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8005180:	2100      	movs	r1, #0
{
 8005182:	4613      	mov	r3, r2
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8005184:	4662      	mov	r2, ip
 8005186:	f000 fac3 	bl	8005710 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800518a:	2000      	movs	r0, #0
 800518c:	bd08      	pop	{r3, pc}
 800518e:	bf00      	nop

08005190 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8005190:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005192:	2104      	movs	r1, #4

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8005194:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005196:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 800519a:	461a      	mov	r2, r3
 800519c:	4619      	mov	r1, r3
 800519e:	f000 faa9 	bl	80056f4 <USBD_LL_Transmit>

  return USBD_OK;
}
 80051a2:	2000      	movs	r0, #0
 80051a4:	bd08      	pop	{r3, pc}
 80051a6:	bf00      	nop

080051a8 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80051a8:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80051aa:	2105      	movs	r1, #5

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80051ac:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80051ae:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80051b2:	461a      	mov	r2, r3
 80051b4:	4619      	mov	r1, r3
 80051b6:	f000 faab 	bl	8005710 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 80051ba:	2000      	movs	r0, #0
 80051bc:	bd08      	pop	{r3, pc}
 80051be:	bf00      	nop

080051c0 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 80051c0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 80051c2:	2200      	movs	r2, #0
 80051c4:	4917      	ldr	r1, [pc, #92]	; (8005224 <MX_USB_DEVICE_Init+0x64>)
 80051c6:	4818      	ldr	r0, [pc, #96]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 80051c8:	f7ff fbda 	bl	8004980 <USBD_Init>
 80051cc:	b970      	cbnz	r0, 80051ec <MX_USB_DEVICE_Init+0x2c>
  {
    Error_Handler();
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_MSC) != USBD_OK)
 80051ce:	4917      	ldr	r1, [pc, #92]	; (800522c <MX_USB_DEVICE_Init+0x6c>)
 80051d0:	4815      	ldr	r0, [pc, #84]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 80051d2:	f7ff fbeb 	bl	80049ac <USBD_RegisterClass>
 80051d6:	b988      	cbnz	r0, 80051fc <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
  }
  if (USBD_MSC_RegisterStorage(&hUsbDeviceFS, &USBD_Storage_Interface_fops_FS) != USBD_OK)
 80051d8:	4915      	ldr	r1, [pc, #84]	; (8005230 <MX_USB_DEVICE_Init+0x70>)
 80051da:	4813      	ldr	r0, [pc, #76]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 80051dc:	f7fe fee2 	bl	8003fa4 <USBD_MSC_RegisterStorage>
 80051e0:	b9a0      	cbnz	r0, 800520c <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 80051e2:	4811      	ldr	r0, [pc, #68]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 80051e4:	f7ff fbea 	bl	80049bc <USBD_Start>
 80051e8:	b9b8      	cbnz	r0, 800521a <MX_USB_DEVICE_Init+0x5a>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 80051ea:	bd08      	pop	{r3, pc}
    Error_Handler();
 80051ec:	f7fb fa88 	bl	8000700 <Error_Handler>
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_MSC) != USBD_OK)
 80051f0:	490e      	ldr	r1, [pc, #56]	; (800522c <MX_USB_DEVICE_Init+0x6c>)
 80051f2:	480d      	ldr	r0, [pc, #52]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 80051f4:	f7ff fbda 	bl	80049ac <USBD_RegisterClass>
 80051f8:	2800      	cmp	r0, #0
 80051fa:	d0ed      	beq.n	80051d8 <MX_USB_DEVICE_Init+0x18>
    Error_Handler();
 80051fc:	f7fb fa80 	bl	8000700 <Error_Handler>
  if (USBD_MSC_RegisterStorage(&hUsbDeviceFS, &USBD_Storage_Interface_fops_FS) != USBD_OK)
 8005200:	490b      	ldr	r1, [pc, #44]	; (8005230 <MX_USB_DEVICE_Init+0x70>)
 8005202:	4809      	ldr	r0, [pc, #36]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 8005204:	f7fe fece 	bl	8003fa4 <USBD_MSC_RegisterStorage>
 8005208:	2800      	cmp	r0, #0
 800520a:	d0ea      	beq.n	80051e2 <MX_USB_DEVICE_Init+0x22>
    Error_Handler();
 800520c:	f7fb fa78 	bl	8000700 <Error_Handler>
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8005210:	4805      	ldr	r0, [pc, #20]	; (8005228 <MX_USB_DEVICE_Init+0x68>)
 8005212:	f7ff fbd3 	bl	80049bc <USBD_Start>
 8005216:	2800      	cmp	r0, #0
 8005218:	d0e7      	beq.n	80051ea <MX_USB_DEVICE_Init+0x2a>
}
 800521a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 800521e:	f7fb ba6f 	b.w	8000700 <Error_Handler>
 8005222:	bf00      	nop
 8005224:	200000b0 	.word	0x200000b0
 8005228:	200002dc 	.word	0x200002dc
 800522c:	2000000c 	.word	0x2000000c
 8005230:	20000100 	.word	0x20000100

08005234 <USBD_FS_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 8005234:	2312      	movs	r3, #18
  return USBD_FS_DeviceDesc;
}
 8005236:	4801      	ldr	r0, [pc, #4]	; (800523c <USBD_FS_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_FS_DeviceDesc);
 8005238:	800b      	strh	r3, [r1, #0]
}
 800523a:	4770      	bx	lr
 800523c:	200000cc 	.word	0x200000cc

08005240 <USBD_FS_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 8005240:	2304      	movs	r3, #4
  return USBD_LangIDDesc;
}
 8005242:	4801      	ldr	r0, [pc, #4]	; (8005248 <USBD_FS_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 8005244:	800b      	strh	r3, [r1, #0]
}
 8005246:	4770      	bx	lr
 8005248:	200000e0 	.word	0x200000e0

0800524c <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 800524c:	b510      	push	{r4, lr}
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800524e:	4c04      	ldr	r4, [pc, #16]	; (8005260 <USBD_FS_ManufacturerStrDescriptor+0x14>)
{
 8005250:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8005252:	4804      	ldr	r0, [pc, #16]	; (8005264 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8005254:	4621      	mov	r1, r4
 8005256:	f7ff ff4f 	bl	80050f8 <USBD_GetString>
  return USBD_StrDesc;
}
 800525a:	4620      	mov	r0, r4
 800525c:	bd10      	pop	{r4, pc}
 800525e:	bf00      	nop
 8005260:	200005a0 	.word	0x200005a0
 8005264:	080068e4 	.word	0x080068e4

08005268 <USBD_FS_ProductStrDescriptor>:
{
 8005268:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800526a:	4c04      	ldr	r4, [pc, #16]	; (800527c <USBD_FS_ProductStrDescriptor+0x14>)
{
 800526c:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800526e:	4804      	ldr	r0, [pc, #16]	; (8005280 <USBD_FS_ProductStrDescriptor+0x18>)
 8005270:	4621      	mov	r1, r4
 8005272:	f7ff ff41 	bl	80050f8 <USBD_GetString>
}
 8005276:	4620      	mov	r0, r4
 8005278:	bd10      	pop	{r4, pc}
 800527a:	bf00      	nop
 800527c:	200005a0 	.word	0x200005a0
 8005280:	080068f0 	.word	0x080068f0

08005284 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8005284:	b510      	push	{r4, lr}
  if(speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8005286:	4c04      	ldr	r4, [pc, #16]	; (8005298 <USBD_FS_ConfigStrDescriptor+0x14>)
{
 8005288:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800528a:	4804      	ldr	r0, [pc, #16]	; (800529c <USBD_FS_ConfigStrDescriptor+0x18>)
 800528c:	4621      	mov	r1, r4
 800528e:	f7ff ff33 	bl	80050f8 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8005292:	4620      	mov	r0, r4
 8005294:	bd10      	pop	{r4, pc}
 8005296:	bf00      	nop
 8005298:	200005a0 	.word	0x200005a0
 800529c:	080068fc 	.word	0x080068fc

080052a0 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80052a0:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80052a2:	4c04      	ldr	r4, [pc, #16]	; (80052b4 <USBD_FS_InterfaceStrDescriptor+0x14>)
{
 80052a4:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80052a6:	4804      	ldr	r0, [pc, #16]	; (80052b8 <USBD_FS_InterfaceStrDescriptor+0x18>)
 80052a8:	4621      	mov	r1, r4
 80052aa:	f7ff ff25 	bl	80050f8 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 80052ae:	4620      	mov	r0, r4
 80052b0:	bd10      	pop	{r4, pc}
 80052b2:	bf00      	nop
 80052b4:	200005a0 	.word	0x200005a0
 80052b8:	08006908 	.word	0x08006908

080052bc <USBD_FS_SerialStrDescriptor>:
  *length = USB_SIZ_STRING_SERIAL;
 80052bc:	f04f 0c1a 	mov.w	ip, #26
  */
static void Get_SerialNum(void)
{
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 80052c0:	4a44      	ldr	r2, [pc, #272]	; (80053d4 <USBD_FS_SerialStrDescriptor+0x118>)
 80052c2:	f8d2 07e8 	ldr.w	r0, [r2, #2024]	; 0x7e8
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
  deviceserial2 = *(uint32_t *) DEVICE_ID3;

  deviceserial0 += deviceserial2;
 80052c6:	f8d2 37f0 	ldr.w	r3, [r2, #2032]	; 0x7f0
  *length = USB_SIZ_STRING_SERIAL;
 80052ca:	f8a1 c000 	strh.w	ip, [r1]

  if (deviceserial0 != 0)
 80052ce:	18c3      	adds	r3, r0, r3
 80052d0:	d101      	bne.n	80052d6 <USBD_FS_SerialStrDescriptor+0x1a>
}
 80052d2:	4841      	ldr	r0, [pc, #260]	; (80053d8 <USBD_FS_SerialStrDescriptor+0x11c>)
 80052d4:	4770      	bx	lr
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
    }

    value = value << 4;

    pbuf[2 * idx + 1] = 0;
 80052d6:	f04f 0c00 	mov.w	ip, #0
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 80052da:	f8d2 17ec 	ldr.w	r1, [r2, #2028]	; 0x7ec
    if (((value >> 28)) < 0xA)
 80052de:	0f18      	lsrs	r0, r3, #28
      pbuf[2 * idx] = (value >> 28) + '0';
 80052e0:	4a3d      	ldr	r2, [pc, #244]	; (80053d8 <USBD_FS_SerialStrDescriptor+0x11c>)
    if (((value >> 28)) < 0xA)
 80052e2:	f1b3 4f20 	cmp.w	r3, #2684354560	; 0xa0000000
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 80052e6:	bf2c      	ite	cs
 80052e8:	3037      	addcs	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 80052ea:	3030      	addcc	r0, #48	; 0x30
 80052ec:	7090      	strb	r0, [r2, #2]
    if (((value >> 28)) < 0xA)
 80052ee:	f3c3 6003 	ubfx	r0, r3, #24, #4
 80052f2:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 80052f4:	bf8c      	ite	hi
 80052f6:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 80052f8:	3030      	addls	r0, #48	; 0x30
 80052fa:	7110      	strb	r0, [r2, #4]
    if (((value >> 28)) < 0xA)
 80052fc:	f3c3 5003 	ubfx	r0, r3, #20, #4
 8005300:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8005302:	bf8c      	ite	hi
 8005304:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8005306:	3030      	addls	r0, #48	; 0x30
 8005308:	7190      	strb	r0, [r2, #6]
    if (((value >> 28)) < 0xA)
 800530a:	f3c3 4003 	ubfx	r0, r3, #16, #4
 800530e:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8005310:	bf8c      	ite	hi
 8005312:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8005314:	3030      	addls	r0, #48	; 0x30
 8005316:	7210      	strb	r0, [r2, #8]
    if (((value >> 28)) < 0xA)
 8005318:	f3c3 3003 	ubfx	r0, r3, #12, #4
 800531c:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800531e:	bf8c      	ite	hi
 8005320:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8005322:	3030      	addls	r0, #48	; 0x30
 8005324:	7290      	strb	r0, [r2, #10]
    if (((value >> 28)) < 0xA)
 8005326:	f3c3 2003 	ubfx	r0, r3, #8, #4
 800532a:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800532c:	bf8c      	ite	hi
 800532e:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8005330:	3030      	addls	r0, #48	; 0x30
 8005332:	7310      	strb	r0, [r2, #12]
    if (((value >> 28)) < 0xA)
 8005334:	f3c3 1003 	ubfx	r0, r3, #4, #4
 8005338:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800533a:	bf8c      	ite	hi
 800533c:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 800533e:	3030      	addls	r0, #48	; 0x30
    pbuf[2 * idx + 1] = 0;
 8005340:	f882 c003 	strb.w	ip, [r2, #3]
      pbuf[2 * idx] = (value >> 28) + '0';
 8005344:	7390      	strb	r0, [r2, #14]
    pbuf[2 * idx + 1] = 0;
 8005346:	f04f 0c00 	mov.w	ip, #0
 800534a:	2000      	movs	r0, #0
 800534c:	f882 c005 	strb.w	ip, [r2, #5]
 8005350:	73d0      	strb	r0, [r2, #15]
 8005352:	f04f 0c00 	mov.w	ip, #0
 8005356:	2000      	movs	r0, #0
 8005358:	f882 c007 	strb.w	ip, [r2, #7]
 800535c:	7450      	strb	r0, [r2, #17]
 800535e:	f04f 0c00 	mov.w	ip, #0
 8005362:	2000      	movs	r0, #0
 8005364:	f882 c009 	strb.w	ip, [r2, #9]
 8005368:	74d0      	strb	r0, [r2, #19]
 800536a:	f04f 0c00 	mov.w	ip, #0
 800536e:	2000      	movs	r0, #0
    if (((value >> 28)) < 0xA)
 8005370:	f003 030f 	and.w	r3, r3, #15
 8005374:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 8005376:	bf94      	ite	ls
 8005378:	3330      	addls	r3, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800537a:	3337      	addhi	r3, #55	; 0x37
 800537c:	7413      	strb	r3, [r2, #16]
    if (((value >> 28)) < 0xA)
 800537e:	f1b1 4f20 	cmp.w	r1, #2684354560	; 0xa0000000
 8005382:	ea4f 7311 	mov.w	r3, r1, lsr #28
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8005386:	bf2c      	ite	cs
 8005388:	3337      	addcs	r3, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 800538a:	3330      	addcc	r3, #48	; 0x30
 800538c:	7493      	strb	r3, [r2, #18]
    if (((value >> 28)) < 0xA)
 800538e:	f3c1 6303 	ubfx	r3, r1, #24, #4
 8005392:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8005394:	bf8c      	ite	hi
 8005396:	3337      	addhi	r3, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8005398:	3330      	addls	r3, #48	; 0x30
 800539a:	7513      	strb	r3, [r2, #20]
    if (((value >> 28)) < 0xA)
 800539c:	f3c1 5303 	ubfx	r3, r1, #20, #4
 80053a0:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 80053a2:	bf8c      	ite	hi
 80053a4:	3337      	addhi	r3, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 80053a6:	3330      	addls	r3, #48	; 0x30
 80053a8:	7593      	strb	r3, [r2, #22]
    if (((value >> 28)) < 0xA)
 80053aa:	f3c1 4303 	ubfx	r3, r1, #16, #4
 80053ae:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 80053b0:	bf94      	ite	ls
 80053b2:	3330      	addls	r3, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 80053b4:	3337      	addhi	r3, #55	; 0x37
    pbuf[2 * idx + 1] = 0;
 80053b6:	f882 c00b 	strb.w	ip, [r2, #11]
 80053ba:	7550      	strb	r0, [r2, #21]
 80053bc:	f04f 0c00 	mov.w	ip, #0
 80053c0:	2000      	movs	r0, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 80053c2:	7613      	strb	r3, [r2, #24]
    pbuf[2 * idx + 1] = 0;
 80053c4:	2300      	movs	r3, #0
 80053c6:	75d0      	strb	r0, [r2, #23]
 80053c8:	f882 c00d 	strb.w	ip, [r2, #13]
}
 80053cc:	4802      	ldr	r0, [pc, #8]	; (80053d8 <USBD_FS_SerialStrDescriptor+0x11c>)
    pbuf[2 * idx + 1] = 0;
 80053ce:	7653      	strb	r3, [r2, #25]
}
 80053d0:	4770      	bx	lr
 80053d2:	bf00      	nop
 80053d4:	1ffff000 	.word	0x1ffff000
 80053d8:	200000e4 	.word	0x200000e4

080053dc <STORAGE_GetCapacity_FS>:
  * @param  block_num: .
  * @param  block_size: .
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_GetCapacity_FS(uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 80053dc:	b410      	push	{r4}
  /* USER CODE BEGIN 3 */
  *block_num  = STORAGE_BLK_NBR;
  *block_size = STORAGE_BLK_SIZ;
 80053de:	f44f 7300 	mov.w	r3, #512	; 0x200
  *block_num  = STORAGE_BLK_NBR;
 80053e2:	2480      	movs	r4, #128	; 0x80
  return (USBD_OK);
  /* USER CODE END 3 */
}
 80053e4:	2000      	movs	r0, #0
  *block_num  = STORAGE_BLK_NBR;
 80053e6:	600c      	str	r4, [r1, #0]
}
 80053e8:	bc10      	pop	{r4}
  *block_size = STORAGE_BLK_SIZ;
 80053ea:	8013      	strh	r3, [r2, #0]
}
 80053ec:	4770      	bx	lr
 80053ee:	bf00      	nop

080053f0 <STORAGE_IsReady_FS>:
int8_t STORAGE_IsReady_FS(uint8_t lun)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 80053f0:	2000      	movs	r0, #0
 80053f2:	4770      	bx	lr

080053f4 <STORAGE_GetMaxLun_FS>:
int8_t STORAGE_GetMaxLun_FS(void)
{
  /* USER CODE BEGIN 8 */
  return (STORAGE_LUN_NBR - 1);
  /* USER CODE END 8 */
}
 80053f4:	2000      	movs	r0, #0
 80053f6:	4770      	bx	lr

080053f8 <STORAGE_Init_FS>:
{
 80053f8:	b508      	push	{r3, lr}
	HAL_FLASH_Unlock();
 80053fa:	f7fb fd49 	bl	8000e90 <HAL_FLASH_Unlock>
}
 80053fe:	2000      	movs	r0, #0
 8005400:	bd08      	pop	{r3, pc}
 8005402:	bf00      	nop

08005404 <STORAGE_Read_FS>:
{
 8005404:	b508      	push	{r3, lr}
 8005406:	4613      	mov	r3, r2
 8005408:	4608      	mov	r0, r1
	uint32_t inbuf_addr = blk_addr << 9;// 1 sector has 512 bytes in size. 1 << 9 = 1*512.
 800540a:	0259      	lsls	r1, r3, #9
	memcpy(buf, (uint8_t *)(FLASH_MEM_BASE_ADDR + inbuf_addr),  STORAGE_BLK_SIZ);
 800540c:	f101 6100 	add.w	r1, r1, #134217728	; 0x8000000
 8005410:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005414:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
 8005418:	f000 f9be 	bl	8005798 <memcpy>
}
 800541c:	2000      	movs	r0, #0
 800541e:	bd08      	pop	{r3, pc}

08005420 <STORAGE_Write_FS>:
{
 8005420:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005424:	4690      	mov	r8, r2
 8005426:	4689      	mov	r9, r1
	cpy_addr = (FLASH_MEM_BASE_ADDR	+ ((blk_addr >> 1) << 10));
 8005428:	ea4f 0758 	mov.w	r7, r8, lsr #1
 800542c:	02bf      	lsls	r7, r7, #10
	memcpy(mod_space, (uint8_t*) cpy_addr,	FLASH_PAGE_SIZE);
 800542e:	f8df b080 	ldr.w	fp, [pc, #128]	; 80054b0 <STORAGE_Write_FS+0x90>
	cpy_addr = (FLASH_MEM_BASE_ADDR	+ ((blk_addr >> 1) << 10));
 8005432:	f107 6700 	add.w	r7, r7, #134217728	; 0x8000000
 8005436:	f507 477c 	add.w	r7, r7, #64512	; 0xfc00
	HAL_FLASH_Unlock();
 800543a:	f7fb fd29 	bl	8000e90 <HAL_FLASH_Unlock>
	memcpy(mod_space, (uint8_t*) cpy_addr,	FLASH_PAGE_SIZE);
 800543e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8005442:	4639      	mov	r1, r7
 8005444:	4658      	mov	r0, fp
 8005446:	f000 f9a7 	bl	8005798 <memcpy>
	memcpy(mod_space + ((blk_addr % 2) << 9), buf, 512);
 800544a:	ea4f 2048 	mov.w	r0, r8, lsl #9
 800544e:	f400 7000 	and.w	r0, r0, #512	; 0x200
 8005452:	4649      	mov	r1, r9
 8005454:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005458:	4458      	add	r0, fp
 800545a:	f000 f99d 	bl	8005798 <memcpy>
	USB_EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; // erase 1024 KBytes (which is the size of 1 page).
 800545e:	f04f 0a00 	mov.w	sl, #0
	USB_EraseInitStruct.NbPages = 1; // this tells eraser for how many page we want to erase. Which is 1 page.
 8005462:	2301      	movs	r3, #1
	USB_EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; // erase 1024 KBytes (which is the size of 1 page).
 8005464:	4e13      	ldr	r6, [pc, #76]	; (80054b4 <STORAGE_Write_FS+0x94>)
	HAL_FLASHEx_Erase(&USB_EraseInitStruct, &USB_PAGEError);
 8005466:	4914      	ldr	r1, [pc, #80]	; (80054b8 <STORAGE_Write_FS+0x98>)
 8005468:	4630      	mov	r0, r6
 800546a:	465c      	mov	r4, fp
	for (uint32_t i = 0; i < FLASH_PAGE_SIZE; i+=4) {
 800546c:	4655      	mov	r5, sl
	USB_EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; // erase 1024 KBytes (which is the size of 1 page).
 800546e:	f8c6 a000 	str.w	sl, [r6]
	USB_EraseInitStruct.PageAddress = cpy_addr; // We start erase from the beginning of sector.
 8005472:	60b7      	str	r7, [r6, #8]
	USB_EraseInitStruct.NbPages = 1; // this tells eraser for how many page we want to erase. Which is 1 page.
 8005474:	60f3      	str	r3, [r6, #12]
	HAL_FLASHEx_Erase(&USB_EraseInitStruct, &USB_PAGEError);
 8005476:	f7fb fd75 	bl	8000f64 <HAL_FLASHEx_Erase>
		temp_buf = mod_space[i] | mod_space[i+1] << 8 | mod_space[i+2] << 16
 800547a:	78a3      	ldrb	r3, [r4, #2]
 800547c:	7860      	ldrb	r0, [r4, #1]
 800547e:	7822      	ldrb	r2, [r4, #0]
 8005480:	041b      	lsls	r3, r3, #16
				| mod_space[i+3] << 24; // parse byte n n+1 n+2 and n+3
 8005482:	f894 c003 	ldrb.w	ip, [r4, #3]
		temp_buf = mod_space[i] | mod_space[i+1] << 8 | mod_space[i+2] << 16
 8005486:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 800548a:	68b1      	ldr	r1, [r6, #8]
		temp_buf = mod_space[i] | mod_space[i+1] << 8 | mod_space[i+2] << 16
 800548c:	431a      	orrs	r2, r3
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 800548e:	4429      	add	r1, r5
 8005490:	2300      	movs	r3, #0
 8005492:	2002      	movs	r0, #2
 8005494:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
	for (uint32_t i = 0; i < FLASH_PAGE_SIZE; i+=4) {
 8005498:	3504      	adds	r5, #4
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 800549a:	f7fb fc0f 	bl	8000cbc <HAL_FLASH_Program>
	for (uint32_t i = 0; i < FLASH_PAGE_SIZE; i+=4) {
 800549e:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 80054a2:	f104 0404 	add.w	r4, r4, #4
 80054a6:	d1e8      	bne.n	800547a <STORAGE_Write_FS+0x5a>
}
 80054a8:	2000      	movs	r0, #0
 80054aa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80054ae:	bf00      	nop
 80054b0:	200007b4 	.word	0x200007b4
 80054b4:	200007a0 	.word	0x200007a0
 80054b8:	200007b0 	.word	0x200007b0

080054bc <STORAGE_IsWriteProtected_FS>:
 80054bc:	2000      	movs	r0, #0
 80054be:	4770      	bx	lr

080054c0 <HAL_PCD_MspInit>:
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
  if(pcdHandle->Instance==USB)
 80054c0:	4b0e      	ldr	r3, [pc, #56]	; (80054fc <HAL_PCD_MspInit+0x3c>)
 80054c2:	6802      	ldr	r2, [r0, #0]
 80054c4:	429a      	cmp	r2, r3
 80054c6:	d000      	beq.n	80054ca <HAL_PCD_MspInit+0xa>
 80054c8:	4770      	bx	lr
  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
 80054ca:	2200      	movs	r2, #0
    __HAL_RCC_USB_CLK_ENABLE();
 80054cc:	f503 33da 	add.w	r3, r3, #111616	; 0x1b400
 80054d0:	69d9      	ldr	r1, [r3, #28]
{
 80054d2:	b500      	push	{lr}
    __HAL_RCC_USB_CLK_ENABLE();
 80054d4:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80054d8:	61d9      	str	r1, [r3, #28]
 80054da:	69db      	ldr	r3, [r3, #28]
{
 80054dc:	b083      	sub	sp, #12
    __HAL_RCC_USB_CLK_ENABLE();
 80054de:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80054e2:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
 80054e4:	2014      	movs	r0, #20
 80054e6:	4611      	mov	r1, r2
    __HAL_RCC_USB_CLK_ENABLE();
 80054e8:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
 80054ea:	f7fb fabd 	bl	8000a68 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 80054ee:	2014      	movs	r0, #20
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 80054f0:	b003      	add	sp, #12
 80054f2:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 80054f6:	f7fb baf5 	b.w	8000ae4 <HAL_NVIC_EnableIRQ>
 80054fa:	bf00      	nop
 80054fc:	40005c00 	.word	0x40005c00

08005500 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8005500:	4601      	mov	r1, r0
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8005502:	f8d0 02e8 	ldr.w	r0, [r0, #744]	; 0x2e8
 8005506:	f501 712c 	add.w	r1, r1, #688	; 0x2b0
 800550a:	f7ff ba6f 	b.w	80049ec <USBD_LL_SetupStage>
 800550e:	bf00      	nop

08005510 <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8005510:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8005514:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8005518:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
 800551c:	f8d0 02e8 	ldr.w	r0, [r0, #744]	; 0x2e8
 8005520:	f7ff ba94 	b.w	8004a4c <USBD_LL_DataOutStage>

08005524 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8005524:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8005528:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 800552c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800552e:	f8d0 02e8 	ldr.w	r0, [r0, #744]	; 0x2e8
 8005532:	f7ff bac9 	b.w	8004ac8 <USBD_LL_DataInStage>
 8005536:	bf00      	nop

08005538 <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8005538:	f8d0 02e8 	ldr.w	r0, [r0, #744]	; 0x2e8
 800553c:	f7ff bb6a 	b.w	8004c14 <USBD_LL_SOF>

08005540 <HAL_PCD_ResetCallback>:
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8005540:	6883      	ldr	r3, [r0, #8]
{
 8005542:	b510      	push	{r4, lr}
  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8005544:	2b02      	cmp	r3, #2
{
 8005546:	4604      	mov	r4, r0
  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8005548:	d001      	beq.n	800554e <HAL_PCD_ResetCallback+0xe>
  {
    Error_Handler();
 800554a:	f7fb f8d9 	bl	8000700 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 800554e:	f8d4 02e8 	ldr.w	r0, [r4, #744]	; 0x2e8
 8005552:	2101      	movs	r1, #1
 8005554:	f7ff fb46 	bl	8004be4 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8005558:	f8d4 02e8 	ldr.w	r0, [r4, #744]	; 0x2e8
}
 800555c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8005560:	f7ff bb18 	b.w	8004b94 <USBD_LL_Reset>

08005564 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8005564:	b510      	push	{r4, lr}
 8005566:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8005568:	f8d0 02e8 	ldr.w	r0, [r0, #744]	; 0x2e8
 800556c:	f7ff fb3e 	bl	8004bec <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8005570:	69a3      	ldr	r3, [r4, #24]
 8005572:	b123      	cbz	r3, 800557e <HAL_PCD_SuspendCallback+0x1a>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8005574:	4a02      	ldr	r2, [pc, #8]	; (8005580 <HAL_PCD_SuspendCallback+0x1c>)
 8005576:	6913      	ldr	r3, [r2, #16]
 8005578:	f043 0306 	orr.w	r3, r3, #6
 800557c:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 800557e:	bd10      	pop	{r4, pc}
 8005580:	e000ed00 	.word	0xe000ed00

08005584 <HAL_PCD_ResumeCallback>:
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8005584:	f8d0 02e8 	ldr.w	r0, [r0, #744]	; 0x2e8
 8005588:	f7ff bb3a 	b.w	8004c00 <USBD_LL_Resume>

0800558c <USBD_LL_Init>:
  /* Link the driver to the stack. */
  hpcd_USB_FS.pData = pdev;
  pdev->pData = &hpcd_USB_FS;

  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
 800558c:	2208      	movs	r2, #8
{
 800558e:	b538      	push	{r3, r4, r5, lr}
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8005590:	2400      	movs	r4, #0
 8005592:	2500      	movs	r5, #0
  hpcd_USB_FS.pData = pdev;
 8005594:	4b19      	ldr	r3, [pc, #100]	; (80055fc <USBD_LL_Init+0x70>)
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8005596:	2102      	movs	r1, #2
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8005598:	605a      	str	r2, [r3, #4]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 800559a:	2200      	movs	r2, #0
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 800559c:	e9c3 4506 	strd	r4, r5, [r3, #24]
{
 80055a0:	4604      	mov	r4, r0
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 80055a2:	621a      	str	r2, [r3, #32]
  hpcd_USB_FS.Instance = USB;
 80055a4:	4a16      	ldr	r2, [pc, #88]	; (8005600 <USBD_LL_Init+0x74>)
  hpcd_USB_FS.pData = pdev;
 80055a6:	f8c3 42e8 	str.w	r4, [r3, #744]	; 0x2e8
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 80055aa:	4618      	mov	r0, r3
  pdev->pData = &hpcd_USB_FS;
 80055ac:	f8c4 32c0 	str.w	r3, [r4, #704]	; 0x2c0
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 80055b0:	6099      	str	r1, [r3, #8]
  hpcd_USB_FS.Instance = USB;
 80055b2:	601a      	str	r2, [r3, #0]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 80055b4:	f7fb fe4a 	bl	800124c <HAL_PCD_Init>
 80055b8:	b9e8      	cbnz	r0, 80055f6 <USBD_LL_Init+0x6a>
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN EndPoint_Configuration */
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 80055ba:	2200      	movs	r2, #0
 80055bc:	2318      	movs	r3, #24
 80055be:	4611      	mov	r1, r2
 80055c0:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 80055c4:	f7fc fdbe 	bl	8002144 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 80055c8:	2358      	movs	r3, #88	; 0x58
 80055ca:	2200      	movs	r2, #0
 80055cc:	2180      	movs	r1, #128	; 0x80
 80055ce:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 80055d2:	f7fc fdb7 	bl	8002144 <HAL_PCDEx_PMAConfig>
  /* USER CODE END EndPoint_Configuration */
  /* USER CODE BEGIN EndPoint_Configuration_MSC */
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0x98);
 80055d6:	2398      	movs	r3, #152	; 0x98
 80055d8:	2200      	movs	r2, #0
 80055da:	2181      	movs	r1, #129	; 0x81
 80055dc:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 80055e0:	f7fc fdb0 	bl	8002144 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0xD8);
 80055e4:	23d8      	movs	r3, #216	; 0xd8
 80055e6:	2200      	movs	r2, #0
 80055e8:	2101      	movs	r1, #1
 80055ea:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 80055ee:	f7fc fda9 	bl	8002144 <HAL_PCDEx_PMAConfig>
  /* USER CODE END EndPoint_Configuration_MSC */
  return USBD_OK;
}
 80055f2:	2000      	movs	r0, #0
 80055f4:	bd38      	pop	{r3, r4, r5, pc}
    Error_Handler( );
 80055f6:	f7fb f883 	bl	8000700 <Error_Handler>
 80055fa:	e7de      	b.n	80055ba <USBD_LL_Init+0x2e>
 80055fc:	20000bb8 	.word	0x20000bb8
 8005600:	40005c00 	.word	0x40005c00

08005604 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8005604:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_Start(pdev->pData);
 8005606:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800560a:	f7fb fe9d 	bl	8001348 <HAL_PCD_Start>
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 800560e:	2803      	cmp	r0, #3
 8005610:	bf96      	itet	ls
 8005612:	4b02      	ldrls	r3, [pc, #8]	; (800561c <USBD_LL_Start+0x18>)
  hal_status = HAL_PCD_Start(pdev->pData);
 8005614:	2002      	movhi	r0, #2
 8005616:	5c18      	ldrbls	r0, [r3, r0]
}
 8005618:	bd08      	pop	{r3, pc}
 800561a:	bf00      	nop
 800561c:	0800693c 	.word	0x0800693c

08005620 <USBD_LL_OpenEP>:
{
 8005620:	4694      	mov	ip, r2
 8005622:	b508      	push	{r3, lr}
 8005624:	461a      	mov	r2, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8005626:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800562a:	4663      	mov	r3, ip
 800562c:	f7fc fc3c 	bl	8001ea8 <HAL_PCD_EP_Open>
  switch (hal_status)
 8005630:	2803      	cmp	r0, #3
 8005632:	bf96      	itet	ls
 8005634:	4b01      	ldrls	r3, [pc, #4]	; (800563c <USBD_LL_OpenEP+0x1c>)
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8005636:	2002      	movhi	r0, #2
 8005638:	5c18      	ldrbls	r0, [r3, r0]
}
 800563a:	bd08      	pop	{r3, pc}
 800563c:	0800693c 	.word	0x0800693c

08005640 <USBD_LL_CloseEP>:
{
 8005640:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8005642:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8005646:	f7fc fc6d 	bl	8001f24 <HAL_PCD_EP_Close>
  switch (hal_status)
 800564a:	2803      	cmp	r0, #3
 800564c:	bf96      	itet	ls
 800564e:	4b02      	ldrls	r3, [pc, #8]	; (8005658 <USBD_LL_CloseEP+0x18>)
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8005650:	2002      	movhi	r0, #2
 8005652:	5c18      	ldrbls	r0, [r3, r0]
}
 8005654:	bd08      	pop	{r3, pc}
 8005656:	bf00      	nop
 8005658:	0800693c 	.word	0x0800693c

0800565c <USBD_LL_FlushEP>:
{
 800565c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 800565e:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8005662:	f7fc fd51 	bl	8002108 <HAL_PCD_EP_Flush>
  switch (hal_status)
 8005666:	2803      	cmp	r0, #3
 8005668:	bf96      	itet	ls
 800566a:	4b02      	ldrls	r3, [pc, #8]	; (8005674 <USBD_LL_FlushEP+0x18>)
  hal_status = HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 800566c:	2002      	movhi	r0, #2
 800566e:	5c18      	ldrbls	r0, [r3, r0]
}
 8005670:	bd08      	pop	{r3, pc}
 8005672:	bf00      	nop
 8005674:	0800693c 	.word	0x0800693c

08005678 <USBD_LL_StallEP>:
{
 8005678:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 800567a:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800567e:	f7fc fcc9 	bl	8002014 <HAL_PCD_EP_SetStall>
  switch (hal_status)
 8005682:	2803      	cmp	r0, #3
 8005684:	bf96      	itet	ls
 8005686:	4b02      	ldrls	r3, [pc, #8]	; (8005690 <USBD_LL_StallEP+0x18>)
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8005688:	2002      	movhi	r0, #2
 800568a:	5c18      	ldrbls	r0, [r3, r0]
}
 800568c:	bd08      	pop	{r3, pc}
 800568e:	bf00      	nop
 8005690:	0800693c 	.word	0x0800693c

08005694 <USBD_LL_ClearStallEP>:
{
 8005694:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8005696:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800569a:	f7fc fcf9 	bl	8002090 <HAL_PCD_EP_ClrStall>
  switch (hal_status)
 800569e:	2803      	cmp	r0, #3
 80056a0:	bf96      	itet	ls
 80056a2:	4b02      	ldrls	r3, [pc, #8]	; (80056ac <USBD_LL_ClearStallEP+0x18>)
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 80056a4:	2002      	movhi	r0, #2
 80056a6:	5c18      	ldrbls	r0, [r3, r0]
}
 80056a8:	bd08      	pop	{r3, pc}
 80056aa:	bf00      	nop
 80056ac:	0800693c 	.word	0x0800693c

080056b0 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 80056b0:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 80056b2:	f8d0 32c0 	ldr.w	r3, [r0, #704]	; 0x2c0
  if((ep_addr & 0x80) == 0x80)
 80056b6:	d406      	bmi.n	80056c6 <USBD_LL_IsStallEP+0x16>
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 80056b8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 80056bc:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80056c0:	f891 016a 	ldrb.w	r0, [r1, #362]	; 0x16a
}
 80056c4:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 80056c6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80056ca:	3101      	adds	r1, #1
 80056cc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 80056d0:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80056d4:	7888      	ldrb	r0, [r1, #2]
 80056d6:	4770      	bx	lr

080056d8 <USBD_LL_SetUSBAddress>:
{
 80056d8:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80056da:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 80056de:	f7fc fbcd 	bl	8001e7c <HAL_PCD_SetAddress>
  switch (hal_status)
 80056e2:	2803      	cmp	r0, #3
 80056e4:	bf96      	itet	ls
 80056e6:	4b02      	ldrls	r3, [pc, #8]	; (80056f0 <USBD_LL_SetUSBAddress+0x18>)
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80056e8:	2002      	movhi	r0, #2
 80056ea:	5c18      	ldrbls	r0, [r3, r0]
}
 80056ec:	bd08      	pop	{r3, pc}
 80056ee:	bf00      	nop
 80056f0:	0800693c 	.word	0x0800693c

080056f4 <USBD_LL_Transmit>:
{
 80056f4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 80056f6:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 80056fa:	f7fc fc67 	bl	8001fcc <HAL_PCD_EP_Transmit>
  switch (hal_status)
 80056fe:	2803      	cmp	r0, #3
 8005700:	bf96      	itet	ls
 8005702:	4b02      	ldrls	r3, [pc, #8]	; (800570c <USBD_LL_Transmit+0x18>)
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8005704:	2002      	movhi	r0, #2
 8005706:	5c18      	ldrbls	r0, [r3, r0]
}
 8005708:	bd08      	pop	{r3, pc}
 800570a:	bf00      	nop
 800570c:	0800693c 	.word	0x0800693c

08005710 <USBD_LL_PrepareReceive>:
{
 8005710:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8005712:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8005716:	f7fc fc37 	bl	8001f88 <HAL_PCD_EP_Receive>
  switch (hal_status)
 800571a:	2803      	cmp	r0, #3
 800571c:	bf96      	itet	ls
 800571e:	4b02      	ldrls	r3, [pc, #8]	; (8005728 <USBD_LL_PrepareReceive+0x18>)
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8005720:	2002      	movhi	r0, #2
 8005722:	5c18      	ldrbls	r0, [r3, r0]
}
 8005724:	bd08      	pop	{r3, pc}
 8005726:	bf00      	nop
 8005728:	0800693c 	.word	0x0800693c

0800572c <USBD_LL_GetRxDataSize>:
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 800572c:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8005730:	f7fc bc42 	b.w	8001fb8 <HAL_PCD_EP_GetRxCount>

08005734 <USBD_static_malloc>:
}
 8005734:	4800      	ldr	r0, [pc, #0]	; (8005738 <USBD_static_malloc+0x4>)
 8005736:	4770      	bx	lr
 8005738:	20000ea4 	.word	0x20000ea4

0800573c <USBD_static_free>:
}
 800573c:	4770      	bx	lr
 800573e:	bf00      	nop

08005740 <HAL_PCDEx_SetConnectionState>:
}
 8005740:	4770      	bx	lr
 8005742:	bf00      	nop

08005744 <__errno>:
 8005744:	4b01      	ldr	r3, [pc, #4]	; (800574c <__errno+0x8>)
 8005746:	6818      	ldr	r0, [r3, #0]
 8005748:	4770      	bx	lr
 800574a:	bf00      	nop
 800574c:	20000120 	.word	0x20000120

08005750 <__libc_init_array>:
 8005750:	b570      	push	{r4, r5, r6, lr}
 8005752:	2600      	movs	r6, #0
 8005754:	4d0c      	ldr	r5, [pc, #48]	; (8005788 <__libc_init_array+0x38>)
 8005756:	4c0d      	ldr	r4, [pc, #52]	; (800578c <__libc_init_array+0x3c>)
 8005758:	1b64      	subs	r4, r4, r5
 800575a:	10a4      	asrs	r4, r4, #2
 800575c:	42a6      	cmp	r6, r4
 800575e:	d109      	bne.n	8005774 <__libc_init_array+0x24>
 8005760:	f001 f83a 	bl	80067d8 <_init>
 8005764:	2600      	movs	r6, #0
 8005766:	4d0a      	ldr	r5, [pc, #40]	; (8005790 <__libc_init_array+0x40>)
 8005768:	4c0a      	ldr	r4, [pc, #40]	; (8005794 <__libc_init_array+0x44>)
 800576a:	1b64      	subs	r4, r4, r5
 800576c:	10a4      	asrs	r4, r4, #2
 800576e:	42a6      	cmp	r6, r4
 8005770:	d105      	bne.n	800577e <__libc_init_array+0x2e>
 8005772:	bd70      	pop	{r4, r5, r6, pc}
 8005774:	f855 3b04 	ldr.w	r3, [r5], #4
 8005778:	4798      	blx	r3
 800577a:	3601      	adds	r6, #1
 800577c:	e7ee      	b.n	800575c <__libc_init_array+0xc>
 800577e:	f855 3b04 	ldr.w	r3, [r5], #4
 8005782:	4798      	blx	r3
 8005784:	3601      	adds	r6, #1
 8005786:	e7f2      	b.n	800576e <__libc_init_array+0x1e>
 8005788:	080069d8 	.word	0x080069d8
 800578c:	080069d8 	.word	0x080069d8
 8005790:	080069d8 	.word	0x080069d8
 8005794:	080069dc 	.word	0x080069dc

08005798 <memcpy>:
 8005798:	440a      	add	r2, r1
 800579a:	4291      	cmp	r1, r2
 800579c:	f100 33ff 	add.w	r3, r0, #4294967295
 80057a0:	d100      	bne.n	80057a4 <memcpy+0xc>
 80057a2:	4770      	bx	lr
 80057a4:	b510      	push	{r4, lr}
 80057a6:	f811 4b01 	ldrb.w	r4, [r1], #1
 80057aa:	4291      	cmp	r1, r2
 80057ac:	f803 4f01 	strb.w	r4, [r3, #1]!
 80057b0:	d1f9      	bne.n	80057a6 <memcpy+0xe>
 80057b2:	bd10      	pop	{r4, pc}

080057b4 <memset>:
 80057b4:	4603      	mov	r3, r0
 80057b6:	4402      	add	r2, r0
 80057b8:	4293      	cmp	r3, r2
 80057ba:	d100      	bne.n	80057be <memset+0xa>
 80057bc:	4770      	bx	lr
 80057be:	f803 1b01 	strb.w	r1, [r3], #1
 80057c2:	e7f9      	b.n	80057b8 <memset+0x4>

080057c4 <iprintf>:
 80057c4:	b40f      	push	{r0, r1, r2, r3}
 80057c6:	4b0a      	ldr	r3, [pc, #40]	; (80057f0 <iprintf+0x2c>)
 80057c8:	b513      	push	{r0, r1, r4, lr}
 80057ca:	681c      	ldr	r4, [r3, #0]
 80057cc:	b124      	cbz	r4, 80057d8 <iprintf+0x14>
 80057ce:	69a3      	ldr	r3, [r4, #24]
 80057d0:	b913      	cbnz	r3, 80057d8 <iprintf+0x14>
 80057d2:	4620      	mov	r0, r4
 80057d4:	f000 fa5a 	bl	8005c8c <__sinit>
 80057d8:	ab05      	add	r3, sp, #20
 80057da:	4620      	mov	r0, r4
 80057dc:	9a04      	ldr	r2, [sp, #16]
 80057de:	68a1      	ldr	r1, [r4, #8]
 80057e0:	9301      	str	r3, [sp, #4]
 80057e2:	f000 fc5d 	bl	80060a0 <_vfiprintf_r>
 80057e6:	b002      	add	sp, #8
 80057e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80057ec:	b004      	add	sp, #16
 80057ee:	4770      	bx	lr
 80057f0:	20000120 	.word	0x20000120

080057f4 <_puts_r>:
 80057f4:	b570      	push	{r4, r5, r6, lr}
 80057f6:	460e      	mov	r6, r1
 80057f8:	4605      	mov	r5, r0
 80057fa:	b118      	cbz	r0, 8005804 <_puts_r+0x10>
 80057fc:	6983      	ldr	r3, [r0, #24]
 80057fe:	b90b      	cbnz	r3, 8005804 <_puts_r+0x10>
 8005800:	f000 fa44 	bl	8005c8c <__sinit>
 8005804:	69ab      	ldr	r3, [r5, #24]
 8005806:	68ac      	ldr	r4, [r5, #8]
 8005808:	b913      	cbnz	r3, 8005810 <_puts_r+0x1c>
 800580a:	4628      	mov	r0, r5
 800580c:	f000 fa3e 	bl	8005c8c <__sinit>
 8005810:	4b2c      	ldr	r3, [pc, #176]	; (80058c4 <_puts_r+0xd0>)
 8005812:	429c      	cmp	r4, r3
 8005814:	d120      	bne.n	8005858 <_puts_r+0x64>
 8005816:	686c      	ldr	r4, [r5, #4]
 8005818:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800581a:	07db      	lsls	r3, r3, #31
 800581c:	d405      	bmi.n	800582a <_puts_r+0x36>
 800581e:	89a3      	ldrh	r3, [r4, #12]
 8005820:	0598      	lsls	r0, r3, #22
 8005822:	d402      	bmi.n	800582a <_puts_r+0x36>
 8005824:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8005826:	f000 facf 	bl	8005dc8 <__retarget_lock_acquire_recursive>
 800582a:	89a3      	ldrh	r3, [r4, #12]
 800582c:	0719      	lsls	r1, r3, #28
 800582e:	d51d      	bpl.n	800586c <_puts_r+0x78>
 8005830:	6923      	ldr	r3, [r4, #16]
 8005832:	b1db      	cbz	r3, 800586c <_puts_r+0x78>
 8005834:	3e01      	subs	r6, #1
 8005836:	68a3      	ldr	r3, [r4, #8]
 8005838:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800583c:	3b01      	subs	r3, #1
 800583e:	60a3      	str	r3, [r4, #8]
 8005840:	bb39      	cbnz	r1, 8005892 <_puts_r+0x9e>
 8005842:	2b00      	cmp	r3, #0
 8005844:	da38      	bge.n	80058b8 <_puts_r+0xc4>
 8005846:	4622      	mov	r2, r4
 8005848:	210a      	movs	r1, #10
 800584a:	4628      	mov	r0, r5
 800584c:	f000 f848 	bl	80058e0 <__swbuf_r>
 8005850:	3001      	adds	r0, #1
 8005852:	d011      	beq.n	8005878 <_puts_r+0x84>
 8005854:	250a      	movs	r5, #10
 8005856:	e011      	b.n	800587c <_puts_r+0x88>
 8005858:	4b1b      	ldr	r3, [pc, #108]	; (80058c8 <_puts_r+0xd4>)
 800585a:	429c      	cmp	r4, r3
 800585c:	d101      	bne.n	8005862 <_puts_r+0x6e>
 800585e:	68ac      	ldr	r4, [r5, #8]
 8005860:	e7da      	b.n	8005818 <_puts_r+0x24>
 8005862:	4b1a      	ldr	r3, [pc, #104]	; (80058cc <_puts_r+0xd8>)
 8005864:	429c      	cmp	r4, r3
 8005866:	bf08      	it	eq
 8005868:	68ec      	ldreq	r4, [r5, #12]
 800586a:	e7d5      	b.n	8005818 <_puts_r+0x24>
 800586c:	4621      	mov	r1, r4
 800586e:	4628      	mov	r0, r5
 8005870:	f000 f888 	bl	8005984 <__swsetup_r>
 8005874:	2800      	cmp	r0, #0
 8005876:	d0dd      	beq.n	8005834 <_puts_r+0x40>
 8005878:	f04f 35ff 	mov.w	r5, #4294967295
 800587c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800587e:	07da      	lsls	r2, r3, #31
 8005880:	d405      	bmi.n	800588e <_puts_r+0x9a>
 8005882:	89a3      	ldrh	r3, [r4, #12]
 8005884:	059b      	lsls	r3, r3, #22
 8005886:	d402      	bmi.n	800588e <_puts_r+0x9a>
 8005888:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800588a:	f000 fa9e 	bl	8005dca <__retarget_lock_release_recursive>
 800588e:	4628      	mov	r0, r5
 8005890:	bd70      	pop	{r4, r5, r6, pc}
 8005892:	2b00      	cmp	r3, #0
 8005894:	da04      	bge.n	80058a0 <_puts_r+0xac>
 8005896:	69a2      	ldr	r2, [r4, #24]
 8005898:	429a      	cmp	r2, r3
 800589a:	dc06      	bgt.n	80058aa <_puts_r+0xb6>
 800589c:	290a      	cmp	r1, #10
 800589e:	d004      	beq.n	80058aa <_puts_r+0xb6>
 80058a0:	6823      	ldr	r3, [r4, #0]
 80058a2:	1c5a      	adds	r2, r3, #1
 80058a4:	6022      	str	r2, [r4, #0]
 80058a6:	7019      	strb	r1, [r3, #0]
 80058a8:	e7c5      	b.n	8005836 <_puts_r+0x42>
 80058aa:	4622      	mov	r2, r4
 80058ac:	4628      	mov	r0, r5
 80058ae:	f000 f817 	bl	80058e0 <__swbuf_r>
 80058b2:	3001      	adds	r0, #1
 80058b4:	d1bf      	bne.n	8005836 <_puts_r+0x42>
 80058b6:	e7df      	b.n	8005878 <_puts_r+0x84>
 80058b8:	250a      	movs	r5, #10
 80058ba:	6823      	ldr	r3, [r4, #0]
 80058bc:	1c5a      	adds	r2, r3, #1
 80058be:	6022      	str	r2, [r4, #0]
 80058c0:	701d      	strb	r5, [r3, #0]
 80058c2:	e7db      	b.n	800587c <_puts_r+0x88>
 80058c4:	08006964 	.word	0x08006964
 80058c8:	08006984 	.word	0x08006984
 80058cc:	08006944 	.word	0x08006944

080058d0 <puts>:
 80058d0:	4b02      	ldr	r3, [pc, #8]	; (80058dc <puts+0xc>)
 80058d2:	4601      	mov	r1, r0
 80058d4:	6818      	ldr	r0, [r3, #0]
 80058d6:	f7ff bf8d 	b.w	80057f4 <_puts_r>
 80058da:	bf00      	nop
 80058dc:	20000120 	.word	0x20000120

080058e0 <__swbuf_r>:
 80058e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058e2:	460e      	mov	r6, r1
 80058e4:	4614      	mov	r4, r2
 80058e6:	4605      	mov	r5, r0
 80058e8:	b118      	cbz	r0, 80058f2 <__swbuf_r+0x12>
 80058ea:	6983      	ldr	r3, [r0, #24]
 80058ec:	b90b      	cbnz	r3, 80058f2 <__swbuf_r+0x12>
 80058ee:	f000 f9cd 	bl	8005c8c <__sinit>
 80058f2:	4b21      	ldr	r3, [pc, #132]	; (8005978 <__swbuf_r+0x98>)
 80058f4:	429c      	cmp	r4, r3
 80058f6:	d12b      	bne.n	8005950 <__swbuf_r+0x70>
 80058f8:	686c      	ldr	r4, [r5, #4]
 80058fa:	69a3      	ldr	r3, [r4, #24]
 80058fc:	60a3      	str	r3, [r4, #8]
 80058fe:	89a3      	ldrh	r3, [r4, #12]
 8005900:	071a      	lsls	r2, r3, #28
 8005902:	d52f      	bpl.n	8005964 <__swbuf_r+0x84>
 8005904:	6923      	ldr	r3, [r4, #16]
 8005906:	b36b      	cbz	r3, 8005964 <__swbuf_r+0x84>
 8005908:	6923      	ldr	r3, [r4, #16]
 800590a:	6820      	ldr	r0, [r4, #0]
 800590c:	b2f6      	uxtb	r6, r6
 800590e:	1ac0      	subs	r0, r0, r3
 8005910:	6963      	ldr	r3, [r4, #20]
 8005912:	4637      	mov	r7, r6
 8005914:	4283      	cmp	r3, r0
 8005916:	dc04      	bgt.n	8005922 <__swbuf_r+0x42>
 8005918:	4621      	mov	r1, r4
 800591a:	4628      	mov	r0, r5
 800591c:	f000 f922 	bl	8005b64 <_fflush_r>
 8005920:	bb30      	cbnz	r0, 8005970 <__swbuf_r+0x90>
 8005922:	68a3      	ldr	r3, [r4, #8]
 8005924:	3001      	adds	r0, #1
 8005926:	3b01      	subs	r3, #1
 8005928:	60a3      	str	r3, [r4, #8]
 800592a:	6823      	ldr	r3, [r4, #0]
 800592c:	1c5a      	adds	r2, r3, #1
 800592e:	6022      	str	r2, [r4, #0]
 8005930:	701e      	strb	r6, [r3, #0]
 8005932:	6963      	ldr	r3, [r4, #20]
 8005934:	4283      	cmp	r3, r0
 8005936:	d004      	beq.n	8005942 <__swbuf_r+0x62>
 8005938:	89a3      	ldrh	r3, [r4, #12]
 800593a:	07db      	lsls	r3, r3, #31
 800593c:	d506      	bpl.n	800594c <__swbuf_r+0x6c>
 800593e:	2e0a      	cmp	r6, #10
 8005940:	d104      	bne.n	800594c <__swbuf_r+0x6c>
 8005942:	4621      	mov	r1, r4
 8005944:	4628      	mov	r0, r5
 8005946:	f000 f90d 	bl	8005b64 <_fflush_r>
 800594a:	b988      	cbnz	r0, 8005970 <__swbuf_r+0x90>
 800594c:	4638      	mov	r0, r7
 800594e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005950:	4b0a      	ldr	r3, [pc, #40]	; (800597c <__swbuf_r+0x9c>)
 8005952:	429c      	cmp	r4, r3
 8005954:	d101      	bne.n	800595a <__swbuf_r+0x7a>
 8005956:	68ac      	ldr	r4, [r5, #8]
 8005958:	e7cf      	b.n	80058fa <__swbuf_r+0x1a>
 800595a:	4b09      	ldr	r3, [pc, #36]	; (8005980 <__swbuf_r+0xa0>)
 800595c:	429c      	cmp	r4, r3
 800595e:	bf08      	it	eq
 8005960:	68ec      	ldreq	r4, [r5, #12]
 8005962:	e7ca      	b.n	80058fa <__swbuf_r+0x1a>
 8005964:	4621      	mov	r1, r4
 8005966:	4628      	mov	r0, r5
 8005968:	f000 f80c 	bl	8005984 <__swsetup_r>
 800596c:	2800      	cmp	r0, #0
 800596e:	d0cb      	beq.n	8005908 <__swbuf_r+0x28>
 8005970:	f04f 37ff 	mov.w	r7, #4294967295
 8005974:	e7ea      	b.n	800594c <__swbuf_r+0x6c>
 8005976:	bf00      	nop
 8005978:	08006964 	.word	0x08006964
 800597c:	08006984 	.word	0x08006984
 8005980:	08006944 	.word	0x08006944

08005984 <__swsetup_r>:
 8005984:	4b32      	ldr	r3, [pc, #200]	; (8005a50 <__swsetup_r+0xcc>)
 8005986:	b570      	push	{r4, r5, r6, lr}
 8005988:	681d      	ldr	r5, [r3, #0]
 800598a:	4606      	mov	r6, r0
 800598c:	460c      	mov	r4, r1
 800598e:	b125      	cbz	r5, 800599a <__swsetup_r+0x16>
 8005990:	69ab      	ldr	r3, [r5, #24]
 8005992:	b913      	cbnz	r3, 800599a <__swsetup_r+0x16>
 8005994:	4628      	mov	r0, r5
 8005996:	f000 f979 	bl	8005c8c <__sinit>
 800599a:	4b2e      	ldr	r3, [pc, #184]	; (8005a54 <__swsetup_r+0xd0>)
 800599c:	429c      	cmp	r4, r3
 800599e:	d10f      	bne.n	80059c0 <__swsetup_r+0x3c>
 80059a0:	686c      	ldr	r4, [r5, #4]
 80059a2:	89a3      	ldrh	r3, [r4, #12]
 80059a4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80059a8:	0719      	lsls	r1, r3, #28
 80059aa:	d42c      	bmi.n	8005a06 <__swsetup_r+0x82>
 80059ac:	06dd      	lsls	r5, r3, #27
 80059ae:	d411      	bmi.n	80059d4 <__swsetup_r+0x50>
 80059b0:	2309      	movs	r3, #9
 80059b2:	6033      	str	r3, [r6, #0]
 80059b4:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80059b8:	f04f 30ff 	mov.w	r0, #4294967295
 80059bc:	81a3      	strh	r3, [r4, #12]
 80059be:	e03e      	b.n	8005a3e <__swsetup_r+0xba>
 80059c0:	4b25      	ldr	r3, [pc, #148]	; (8005a58 <__swsetup_r+0xd4>)
 80059c2:	429c      	cmp	r4, r3
 80059c4:	d101      	bne.n	80059ca <__swsetup_r+0x46>
 80059c6:	68ac      	ldr	r4, [r5, #8]
 80059c8:	e7eb      	b.n	80059a2 <__swsetup_r+0x1e>
 80059ca:	4b24      	ldr	r3, [pc, #144]	; (8005a5c <__swsetup_r+0xd8>)
 80059cc:	429c      	cmp	r4, r3
 80059ce:	bf08      	it	eq
 80059d0:	68ec      	ldreq	r4, [r5, #12]
 80059d2:	e7e6      	b.n	80059a2 <__swsetup_r+0x1e>
 80059d4:	0758      	lsls	r0, r3, #29
 80059d6:	d512      	bpl.n	80059fe <__swsetup_r+0x7a>
 80059d8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80059da:	b141      	cbz	r1, 80059ee <__swsetup_r+0x6a>
 80059dc:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80059e0:	4299      	cmp	r1, r3
 80059e2:	d002      	beq.n	80059ea <__swsetup_r+0x66>
 80059e4:	4630      	mov	r0, r6
 80059e6:	f000 fa57 	bl	8005e98 <_free_r>
 80059ea:	2300      	movs	r3, #0
 80059ec:	6363      	str	r3, [r4, #52]	; 0x34
 80059ee:	89a3      	ldrh	r3, [r4, #12]
 80059f0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80059f4:	81a3      	strh	r3, [r4, #12]
 80059f6:	2300      	movs	r3, #0
 80059f8:	6063      	str	r3, [r4, #4]
 80059fa:	6923      	ldr	r3, [r4, #16]
 80059fc:	6023      	str	r3, [r4, #0]
 80059fe:	89a3      	ldrh	r3, [r4, #12]
 8005a00:	f043 0308 	orr.w	r3, r3, #8
 8005a04:	81a3      	strh	r3, [r4, #12]
 8005a06:	6923      	ldr	r3, [r4, #16]
 8005a08:	b94b      	cbnz	r3, 8005a1e <__swsetup_r+0x9a>
 8005a0a:	89a3      	ldrh	r3, [r4, #12]
 8005a0c:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8005a10:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005a14:	d003      	beq.n	8005a1e <__swsetup_r+0x9a>
 8005a16:	4621      	mov	r1, r4
 8005a18:	4630      	mov	r0, r6
 8005a1a:	f000 f9fd 	bl	8005e18 <__smakebuf_r>
 8005a1e:	89a0      	ldrh	r0, [r4, #12]
 8005a20:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8005a24:	f010 0301 	ands.w	r3, r0, #1
 8005a28:	d00a      	beq.n	8005a40 <__swsetup_r+0xbc>
 8005a2a:	2300      	movs	r3, #0
 8005a2c:	60a3      	str	r3, [r4, #8]
 8005a2e:	6963      	ldr	r3, [r4, #20]
 8005a30:	425b      	negs	r3, r3
 8005a32:	61a3      	str	r3, [r4, #24]
 8005a34:	6923      	ldr	r3, [r4, #16]
 8005a36:	b943      	cbnz	r3, 8005a4a <__swsetup_r+0xc6>
 8005a38:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8005a3c:	d1ba      	bne.n	80059b4 <__swsetup_r+0x30>
 8005a3e:	bd70      	pop	{r4, r5, r6, pc}
 8005a40:	0781      	lsls	r1, r0, #30
 8005a42:	bf58      	it	pl
 8005a44:	6963      	ldrpl	r3, [r4, #20]
 8005a46:	60a3      	str	r3, [r4, #8]
 8005a48:	e7f4      	b.n	8005a34 <__swsetup_r+0xb0>
 8005a4a:	2000      	movs	r0, #0
 8005a4c:	e7f7      	b.n	8005a3e <__swsetup_r+0xba>
 8005a4e:	bf00      	nop
 8005a50:	20000120 	.word	0x20000120
 8005a54:	08006964 	.word	0x08006964
 8005a58:	08006984 	.word	0x08006984
 8005a5c:	08006944 	.word	0x08006944

08005a60 <__sflush_r>:
 8005a60:	898a      	ldrh	r2, [r1, #12]
 8005a62:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a64:	4605      	mov	r5, r0
 8005a66:	0710      	lsls	r0, r2, #28
 8005a68:	460c      	mov	r4, r1
 8005a6a:	d457      	bmi.n	8005b1c <__sflush_r+0xbc>
 8005a6c:	684b      	ldr	r3, [r1, #4]
 8005a6e:	2b00      	cmp	r3, #0
 8005a70:	dc04      	bgt.n	8005a7c <__sflush_r+0x1c>
 8005a72:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8005a74:	2b00      	cmp	r3, #0
 8005a76:	dc01      	bgt.n	8005a7c <__sflush_r+0x1c>
 8005a78:	2000      	movs	r0, #0
 8005a7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005a7c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005a7e:	2e00      	cmp	r6, #0
 8005a80:	d0fa      	beq.n	8005a78 <__sflush_r+0x18>
 8005a82:	2300      	movs	r3, #0
 8005a84:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8005a88:	682f      	ldr	r7, [r5, #0]
 8005a8a:	602b      	str	r3, [r5, #0]
 8005a8c:	d032      	beq.n	8005af4 <__sflush_r+0x94>
 8005a8e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8005a90:	89a3      	ldrh	r3, [r4, #12]
 8005a92:	075a      	lsls	r2, r3, #29
 8005a94:	d505      	bpl.n	8005aa2 <__sflush_r+0x42>
 8005a96:	6863      	ldr	r3, [r4, #4]
 8005a98:	1ac0      	subs	r0, r0, r3
 8005a9a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005a9c:	b10b      	cbz	r3, 8005aa2 <__sflush_r+0x42>
 8005a9e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005aa0:	1ac0      	subs	r0, r0, r3
 8005aa2:	2300      	movs	r3, #0
 8005aa4:	4602      	mov	r2, r0
 8005aa6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005aa8:	4628      	mov	r0, r5
 8005aaa:	6a21      	ldr	r1, [r4, #32]
 8005aac:	47b0      	blx	r6
 8005aae:	1c43      	adds	r3, r0, #1
 8005ab0:	89a3      	ldrh	r3, [r4, #12]
 8005ab2:	d106      	bne.n	8005ac2 <__sflush_r+0x62>
 8005ab4:	6829      	ldr	r1, [r5, #0]
 8005ab6:	291d      	cmp	r1, #29
 8005ab8:	d82c      	bhi.n	8005b14 <__sflush_r+0xb4>
 8005aba:	4a29      	ldr	r2, [pc, #164]	; (8005b60 <__sflush_r+0x100>)
 8005abc:	40ca      	lsrs	r2, r1
 8005abe:	07d6      	lsls	r6, r2, #31
 8005ac0:	d528      	bpl.n	8005b14 <__sflush_r+0xb4>
 8005ac2:	2200      	movs	r2, #0
 8005ac4:	6062      	str	r2, [r4, #4]
 8005ac6:	6922      	ldr	r2, [r4, #16]
 8005ac8:	04d9      	lsls	r1, r3, #19
 8005aca:	6022      	str	r2, [r4, #0]
 8005acc:	d504      	bpl.n	8005ad8 <__sflush_r+0x78>
 8005ace:	1c42      	adds	r2, r0, #1
 8005ad0:	d101      	bne.n	8005ad6 <__sflush_r+0x76>
 8005ad2:	682b      	ldr	r3, [r5, #0]
 8005ad4:	b903      	cbnz	r3, 8005ad8 <__sflush_r+0x78>
 8005ad6:	6560      	str	r0, [r4, #84]	; 0x54
 8005ad8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005ada:	602f      	str	r7, [r5, #0]
 8005adc:	2900      	cmp	r1, #0
 8005ade:	d0cb      	beq.n	8005a78 <__sflush_r+0x18>
 8005ae0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8005ae4:	4299      	cmp	r1, r3
 8005ae6:	d002      	beq.n	8005aee <__sflush_r+0x8e>
 8005ae8:	4628      	mov	r0, r5
 8005aea:	f000 f9d5 	bl	8005e98 <_free_r>
 8005aee:	2000      	movs	r0, #0
 8005af0:	6360      	str	r0, [r4, #52]	; 0x34
 8005af2:	e7c2      	b.n	8005a7a <__sflush_r+0x1a>
 8005af4:	6a21      	ldr	r1, [r4, #32]
 8005af6:	2301      	movs	r3, #1
 8005af8:	4628      	mov	r0, r5
 8005afa:	47b0      	blx	r6
 8005afc:	1c41      	adds	r1, r0, #1
 8005afe:	d1c7      	bne.n	8005a90 <__sflush_r+0x30>
 8005b00:	682b      	ldr	r3, [r5, #0]
 8005b02:	2b00      	cmp	r3, #0
 8005b04:	d0c4      	beq.n	8005a90 <__sflush_r+0x30>
 8005b06:	2b1d      	cmp	r3, #29
 8005b08:	d001      	beq.n	8005b0e <__sflush_r+0xae>
 8005b0a:	2b16      	cmp	r3, #22
 8005b0c:	d101      	bne.n	8005b12 <__sflush_r+0xb2>
 8005b0e:	602f      	str	r7, [r5, #0]
 8005b10:	e7b2      	b.n	8005a78 <__sflush_r+0x18>
 8005b12:	89a3      	ldrh	r3, [r4, #12]
 8005b14:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005b18:	81a3      	strh	r3, [r4, #12]
 8005b1a:	e7ae      	b.n	8005a7a <__sflush_r+0x1a>
 8005b1c:	690f      	ldr	r7, [r1, #16]
 8005b1e:	2f00      	cmp	r7, #0
 8005b20:	d0aa      	beq.n	8005a78 <__sflush_r+0x18>
 8005b22:	0793      	lsls	r3, r2, #30
 8005b24:	bf18      	it	ne
 8005b26:	2300      	movne	r3, #0
 8005b28:	680e      	ldr	r6, [r1, #0]
 8005b2a:	bf08      	it	eq
 8005b2c:	694b      	ldreq	r3, [r1, #20]
 8005b2e:	1bf6      	subs	r6, r6, r7
 8005b30:	600f      	str	r7, [r1, #0]
 8005b32:	608b      	str	r3, [r1, #8]
 8005b34:	2e00      	cmp	r6, #0
 8005b36:	dd9f      	ble.n	8005a78 <__sflush_r+0x18>
 8005b38:	4633      	mov	r3, r6
 8005b3a:	463a      	mov	r2, r7
 8005b3c:	4628      	mov	r0, r5
 8005b3e:	6a21      	ldr	r1, [r4, #32]
 8005b40:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
 8005b44:	47e0      	blx	ip
 8005b46:	2800      	cmp	r0, #0
 8005b48:	dc06      	bgt.n	8005b58 <__sflush_r+0xf8>
 8005b4a:	89a3      	ldrh	r3, [r4, #12]
 8005b4c:	f04f 30ff 	mov.w	r0, #4294967295
 8005b50:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005b54:	81a3      	strh	r3, [r4, #12]
 8005b56:	e790      	b.n	8005a7a <__sflush_r+0x1a>
 8005b58:	4407      	add	r7, r0
 8005b5a:	1a36      	subs	r6, r6, r0
 8005b5c:	e7ea      	b.n	8005b34 <__sflush_r+0xd4>
 8005b5e:	bf00      	nop
 8005b60:	20400001 	.word	0x20400001

08005b64 <_fflush_r>:
 8005b64:	b538      	push	{r3, r4, r5, lr}
 8005b66:	690b      	ldr	r3, [r1, #16]
 8005b68:	4605      	mov	r5, r0
 8005b6a:	460c      	mov	r4, r1
 8005b6c:	b913      	cbnz	r3, 8005b74 <_fflush_r+0x10>
 8005b6e:	2500      	movs	r5, #0
 8005b70:	4628      	mov	r0, r5
 8005b72:	bd38      	pop	{r3, r4, r5, pc}
 8005b74:	b118      	cbz	r0, 8005b7e <_fflush_r+0x1a>
 8005b76:	6983      	ldr	r3, [r0, #24]
 8005b78:	b90b      	cbnz	r3, 8005b7e <_fflush_r+0x1a>
 8005b7a:	f000 f887 	bl	8005c8c <__sinit>
 8005b7e:	4b14      	ldr	r3, [pc, #80]	; (8005bd0 <_fflush_r+0x6c>)
 8005b80:	429c      	cmp	r4, r3
 8005b82:	d11b      	bne.n	8005bbc <_fflush_r+0x58>
 8005b84:	686c      	ldr	r4, [r5, #4]
 8005b86:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005b8a:	2b00      	cmp	r3, #0
 8005b8c:	d0ef      	beq.n	8005b6e <_fflush_r+0xa>
 8005b8e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005b90:	07d0      	lsls	r0, r2, #31
 8005b92:	d404      	bmi.n	8005b9e <_fflush_r+0x3a>
 8005b94:	0599      	lsls	r1, r3, #22
 8005b96:	d402      	bmi.n	8005b9e <_fflush_r+0x3a>
 8005b98:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8005b9a:	f000 f915 	bl	8005dc8 <__retarget_lock_acquire_recursive>
 8005b9e:	4628      	mov	r0, r5
 8005ba0:	4621      	mov	r1, r4
 8005ba2:	f7ff ff5d 	bl	8005a60 <__sflush_r>
 8005ba6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8005ba8:	4605      	mov	r5, r0
 8005baa:	07da      	lsls	r2, r3, #31
 8005bac:	d4e0      	bmi.n	8005b70 <_fflush_r+0xc>
 8005bae:	89a3      	ldrh	r3, [r4, #12]
 8005bb0:	059b      	lsls	r3, r3, #22
 8005bb2:	d4dd      	bmi.n	8005b70 <_fflush_r+0xc>
 8005bb4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8005bb6:	f000 f908 	bl	8005dca <__retarget_lock_release_recursive>
 8005bba:	e7d9      	b.n	8005b70 <_fflush_r+0xc>
 8005bbc:	4b05      	ldr	r3, [pc, #20]	; (8005bd4 <_fflush_r+0x70>)
 8005bbe:	429c      	cmp	r4, r3
 8005bc0:	d101      	bne.n	8005bc6 <_fflush_r+0x62>
 8005bc2:	68ac      	ldr	r4, [r5, #8]
 8005bc4:	e7df      	b.n	8005b86 <_fflush_r+0x22>
 8005bc6:	4b04      	ldr	r3, [pc, #16]	; (8005bd8 <_fflush_r+0x74>)
 8005bc8:	429c      	cmp	r4, r3
 8005bca:	bf08      	it	eq
 8005bcc:	68ec      	ldreq	r4, [r5, #12]
 8005bce:	e7da      	b.n	8005b86 <_fflush_r+0x22>
 8005bd0:	08006964 	.word	0x08006964
 8005bd4:	08006984 	.word	0x08006984
 8005bd8:	08006944 	.word	0x08006944

08005bdc <std>:
 8005bdc:	2300      	movs	r3, #0
 8005bde:	b510      	push	{r4, lr}
 8005be0:	4604      	mov	r4, r0
 8005be2:	e9c0 3300 	strd	r3, r3, [r0]
 8005be6:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8005bea:	6083      	str	r3, [r0, #8]
 8005bec:	8181      	strh	r1, [r0, #12]
 8005bee:	6643      	str	r3, [r0, #100]	; 0x64
 8005bf0:	81c2      	strh	r2, [r0, #14]
 8005bf2:	6183      	str	r3, [r0, #24]
 8005bf4:	4619      	mov	r1, r3
 8005bf6:	2208      	movs	r2, #8
 8005bf8:	305c      	adds	r0, #92	; 0x5c
 8005bfa:	f7ff fddb 	bl	80057b4 <memset>
 8005bfe:	4b05      	ldr	r3, [pc, #20]	; (8005c14 <std+0x38>)
 8005c00:	6224      	str	r4, [r4, #32]
 8005c02:	6263      	str	r3, [r4, #36]	; 0x24
 8005c04:	4b04      	ldr	r3, [pc, #16]	; (8005c18 <std+0x3c>)
 8005c06:	62a3      	str	r3, [r4, #40]	; 0x28
 8005c08:	4b04      	ldr	r3, [pc, #16]	; (8005c1c <std+0x40>)
 8005c0a:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005c0c:	4b04      	ldr	r3, [pc, #16]	; (8005c20 <std+0x44>)
 8005c0e:	6323      	str	r3, [r4, #48]	; 0x30
 8005c10:	bd10      	pop	{r4, pc}
 8005c12:	bf00      	nop
 8005c14:	0800664d 	.word	0x0800664d
 8005c18:	0800666f 	.word	0x0800666f
 8005c1c:	080066a7 	.word	0x080066a7
 8005c20:	080066cb 	.word	0x080066cb

08005c24 <_cleanup_r>:
 8005c24:	4901      	ldr	r1, [pc, #4]	; (8005c2c <_cleanup_r+0x8>)
 8005c26:	f000 b8af 	b.w	8005d88 <_fwalk_reent>
 8005c2a:	bf00      	nop
 8005c2c:	08005b65 	.word	0x08005b65

08005c30 <__sfmoreglue>:
 8005c30:	2268      	movs	r2, #104	; 0x68
 8005c32:	b570      	push	{r4, r5, r6, lr}
 8005c34:	1e4d      	subs	r5, r1, #1
 8005c36:	4355      	muls	r5, r2
 8005c38:	460e      	mov	r6, r1
 8005c3a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8005c3e:	f000 f993 	bl	8005f68 <_malloc_r>
 8005c42:	4604      	mov	r4, r0
 8005c44:	b140      	cbz	r0, 8005c58 <__sfmoreglue+0x28>
 8005c46:	2100      	movs	r1, #0
 8005c48:	e9c0 1600 	strd	r1, r6, [r0]
 8005c4c:	300c      	adds	r0, #12
 8005c4e:	60a0      	str	r0, [r4, #8]
 8005c50:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8005c54:	f7ff fdae 	bl	80057b4 <memset>
 8005c58:	4620      	mov	r0, r4
 8005c5a:	bd70      	pop	{r4, r5, r6, pc}

08005c5c <__sfp_lock_acquire>:
 8005c5c:	4801      	ldr	r0, [pc, #4]	; (8005c64 <__sfp_lock_acquire+0x8>)
 8005c5e:	f000 b8b3 	b.w	8005dc8 <__retarget_lock_acquire_recursive>
 8005c62:	bf00      	nop
 8005c64:	20001015 	.word	0x20001015

08005c68 <__sfp_lock_release>:
 8005c68:	4801      	ldr	r0, [pc, #4]	; (8005c70 <__sfp_lock_release+0x8>)
 8005c6a:	f000 b8ae 	b.w	8005dca <__retarget_lock_release_recursive>
 8005c6e:	bf00      	nop
 8005c70:	20001015 	.word	0x20001015

08005c74 <__sinit_lock_acquire>:
 8005c74:	4801      	ldr	r0, [pc, #4]	; (8005c7c <__sinit_lock_acquire+0x8>)
 8005c76:	f000 b8a7 	b.w	8005dc8 <__retarget_lock_acquire_recursive>
 8005c7a:	bf00      	nop
 8005c7c:	20001016 	.word	0x20001016

08005c80 <__sinit_lock_release>:
 8005c80:	4801      	ldr	r0, [pc, #4]	; (8005c88 <__sinit_lock_release+0x8>)
 8005c82:	f000 b8a2 	b.w	8005dca <__retarget_lock_release_recursive>
 8005c86:	bf00      	nop
 8005c88:	20001016 	.word	0x20001016

08005c8c <__sinit>:
 8005c8c:	b510      	push	{r4, lr}
 8005c8e:	4604      	mov	r4, r0
 8005c90:	f7ff fff0 	bl	8005c74 <__sinit_lock_acquire>
 8005c94:	69a3      	ldr	r3, [r4, #24]
 8005c96:	b11b      	cbz	r3, 8005ca0 <__sinit+0x14>
 8005c98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005c9c:	f7ff bff0 	b.w	8005c80 <__sinit_lock_release>
 8005ca0:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8005ca4:	6523      	str	r3, [r4, #80]	; 0x50
 8005ca6:	4b13      	ldr	r3, [pc, #76]	; (8005cf4 <__sinit+0x68>)
 8005ca8:	4a13      	ldr	r2, [pc, #76]	; (8005cf8 <__sinit+0x6c>)
 8005caa:	681b      	ldr	r3, [r3, #0]
 8005cac:	62a2      	str	r2, [r4, #40]	; 0x28
 8005cae:	42a3      	cmp	r3, r4
 8005cb0:	bf08      	it	eq
 8005cb2:	2301      	moveq	r3, #1
 8005cb4:	4620      	mov	r0, r4
 8005cb6:	bf08      	it	eq
 8005cb8:	61a3      	streq	r3, [r4, #24]
 8005cba:	f000 f81f 	bl	8005cfc <__sfp>
 8005cbe:	6060      	str	r0, [r4, #4]
 8005cc0:	4620      	mov	r0, r4
 8005cc2:	f000 f81b 	bl	8005cfc <__sfp>
 8005cc6:	60a0      	str	r0, [r4, #8]
 8005cc8:	4620      	mov	r0, r4
 8005cca:	f000 f817 	bl	8005cfc <__sfp>
 8005cce:	2200      	movs	r2, #0
 8005cd0:	2104      	movs	r1, #4
 8005cd2:	60e0      	str	r0, [r4, #12]
 8005cd4:	6860      	ldr	r0, [r4, #4]
 8005cd6:	f7ff ff81 	bl	8005bdc <std>
 8005cda:	2201      	movs	r2, #1
 8005cdc:	2109      	movs	r1, #9
 8005cde:	68a0      	ldr	r0, [r4, #8]
 8005ce0:	f7ff ff7c 	bl	8005bdc <std>
 8005ce4:	2202      	movs	r2, #2
 8005ce6:	2112      	movs	r1, #18
 8005ce8:	68e0      	ldr	r0, [r4, #12]
 8005cea:	f7ff ff77 	bl	8005bdc <std>
 8005cee:	2301      	movs	r3, #1
 8005cf0:	61a3      	str	r3, [r4, #24]
 8005cf2:	e7d1      	b.n	8005c98 <__sinit+0xc>
 8005cf4:	08006940 	.word	0x08006940
 8005cf8:	08005c25 	.word	0x08005c25

08005cfc <__sfp>:
 8005cfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005cfe:	4607      	mov	r7, r0
 8005d00:	f7ff ffac 	bl	8005c5c <__sfp_lock_acquire>
 8005d04:	4b1e      	ldr	r3, [pc, #120]	; (8005d80 <__sfp+0x84>)
 8005d06:	681e      	ldr	r6, [r3, #0]
 8005d08:	69b3      	ldr	r3, [r6, #24]
 8005d0a:	b913      	cbnz	r3, 8005d12 <__sfp+0x16>
 8005d0c:	4630      	mov	r0, r6
 8005d0e:	f7ff ffbd 	bl	8005c8c <__sinit>
 8005d12:	3648      	adds	r6, #72	; 0x48
 8005d14:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8005d18:	3b01      	subs	r3, #1
 8005d1a:	d503      	bpl.n	8005d24 <__sfp+0x28>
 8005d1c:	6833      	ldr	r3, [r6, #0]
 8005d1e:	b30b      	cbz	r3, 8005d64 <__sfp+0x68>
 8005d20:	6836      	ldr	r6, [r6, #0]
 8005d22:	e7f7      	b.n	8005d14 <__sfp+0x18>
 8005d24:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8005d28:	b9d5      	cbnz	r5, 8005d60 <__sfp+0x64>
 8005d2a:	4b16      	ldr	r3, [pc, #88]	; (8005d84 <__sfp+0x88>)
 8005d2c:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8005d30:	60e3      	str	r3, [r4, #12]
 8005d32:	6665      	str	r5, [r4, #100]	; 0x64
 8005d34:	f000 f847 	bl	8005dc6 <__retarget_lock_init_recursive>
 8005d38:	f7ff ff96 	bl	8005c68 <__sfp_lock_release>
 8005d3c:	2208      	movs	r2, #8
 8005d3e:	4629      	mov	r1, r5
 8005d40:	e9c4 5501 	strd	r5, r5, [r4, #4]
 8005d44:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8005d48:	6025      	str	r5, [r4, #0]
 8005d4a:	61a5      	str	r5, [r4, #24]
 8005d4c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8005d50:	f7ff fd30 	bl	80057b4 <memset>
 8005d54:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8005d58:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8005d5c:	4620      	mov	r0, r4
 8005d5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005d60:	3468      	adds	r4, #104	; 0x68
 8005d62:	e7d9      	b.n	8005d18 <__sfp+0x1c>
 8005d64:	2104      	movs	r1, #4
 8005d66:	4638      	mov	r0, r7
 8005d68:	f7ff ff62 	bl	8005c30 <__sfmoreglue>
 8005d6c:	4604      	mov	r4, r0
 8005d6e:	6030      	str	r0, [r6, #0]
 8005d70:	2800      	cmp	r0, #0
 8005d72:	d1d5      	bne.n	8005d20 <__sfp+0x24>
 8005d74:	f7ff ff78 	bl	8005c68 <__sfp_lock_release>
 8005d78:	230c      	movs	r3, #12
 8005d7a:	603b      	str	r3, [r7, #0]
 8005d7c:	e7ee      	b.n	8005d5c <__sfp+0x60>
 8005d7e:	bf00      	nop
 8005d80:	08006940 	.word	0x08006940
 8005d84:	ffff0001 	.word	0xffff0001

08005d88 <_fwalk_reent>:
 8005d88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005d8c:	4606      	mov	r6, r0
 8005d8e:	4688      	mov	r8, r1
 8005d90:	2700      	movs	r7, #0
 8005d92:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8005d96:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8005d9a:	f1b9 0901 	subs.w	r9, r9, #1
 8005d9e:	d505      	bpl.n	8005dac <_fwalk_reent+0x24>
 8005da0:	6824      	ldr	r4, [r4, #0]
 8005da2:	2c00      	cmp	r4, #0
 8005da4:	d1f7      	bne.n	8005d96 <_fwalk_reent+0xe>
 8005da6:	4638      	mov	r0, r7
 8005da8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005dac:	89ab      	ldrh	r3, [r5, #12]
 8005dae:	2b01      	cmp	r3, #1
 8005db0:	d907      	bls.n	8005dc2 <_fwalk_reent+0x3a>
 8005db2:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8005db6:	3301      	adds	r3, #1
 8005db8:	d003      	beq.n	8005dc2 <_fwalk_reent+0x3a>
 8005dba:	4629      	mov	r1, r5
 8005dbc:	4630      	mov	r0, r6
 8005dbe:	47c0      	blx	r8
 8005dc0:	4307      	orrs	r7, r0
 8005dc2:	3568      	adds	r5, #104	; 0x68
 8005dc4:	e7e9      	b.n	8005d9a <_fwalk_reent+0x12>

08005dc6 <__retarget_lock_init_recursive>:
 8005dc6:	4770      	bx	lr

08005dc8 <__retarget_lock_acquire_recursive>:
 8005dc8:	4770      	bx	lr

08005dca <__retarget_lock_release_recursive>:
 8005dca:	4770      	bx	lr

08005dcc <__swhatbuf_r>:
 8005dcc:	b570      	push	{r4, r5, r6, lr}
 8005dce:	460e      	mov	r6, r1
 8005dd0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005dd4:	4614      	mov	r4, r2
 8005dd6:	2900      	cmp	r1, #0
 8005dd8:	461d      	mov	r5, r3
 8005dda:	b096      	sub	sp, #88	; 0x58
 8005ddc:	da08      	bge.n	8005df0 <__swhatbuf_r+0x24>
 8005dde:	2200      	movs	r2, #0
 8005de0:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 8005de4:	602a      	str	r2, [r5, #0]
 8005de6:	061a      	lsls	r2, r3, #24
 8005de8:	d410      	bmi.n	8005e0c <__swhatbuf_r+0x40>
 8005dea:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005dee:	e00e      	b.n	8005e0e <__swhatbuf_r+0x42>
 8005df0:	466a      	mov	r2, sp
 8005df2:	f000 fc91 	bl	8006718 <_fstat_r>
 8005df6:	2800      	cmp	r0, #0
 8005df8:	dbf1      	blt.n	8005dde <__swhatbuf_r+0x12>
 8005dfa:	9a01      	ldr	r2, [sp, #4]
 8005dfc:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8005e00:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8005e04:	425a      	negs	r2, r3
 8005e06:	415a      	adcs	r2, r3
 8005e08:	602a      	str	r2, [r5, #0]
 8005e0a:	e7ee      	b.n	8005dea <__swhatbuf_r+0x1e>
 8005e0c:	2340      	movs	r3, #64	; 0x40
 8005e0e:	2000      	movs	r0, #0
 8005e10:	6023      	str	r3, [r4, #0]
 8005e12:	b016      	add	sp, #88	; 0x58
 8005e14:	bd70      	pop	{r4, r5, r6, pc}
	...

08005e18 <__smakebuf_r>:
 8005e18:	898b      	ldrh	r3, [r1, #12]
 8005e1a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005e1c:	079d      	lsls	r5, r3, #30
 8005e1e:	4606      	mov	r6, r0
 8005e20:	460c      	mov	r4, r1
 8005e22:	d507      	bpl.n	8005e34 <__smakebuf_r+0x1c>
 8005e24:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8005e28:	6023      	str	r3, [r4, #0]
 8005e2a:	6123      	str	r3, [r4, #16]
 8005e2c:	2301      	movs	r3, #1
 8005e2e:	6163      	str	r3, [r4, #20]
 8005e30:	b002      	add	sp, #8
 8005e32:	bd70      	pop	{r4, r5, r6, pc}
 8005e34:	466a      	mov	r2, sp
 8005e36:	ab01      	add	r3, sp, #4
 8005e38:	f7ff ffc8 	bl	8005dcc <__swhatbuf_r>
 8005e3c:	9900      	ldr	r1, [sp, #0]
 8005e3e:	4605      	mov	r5, r0
 8005e40:	4630      	mov	r0, r6
 8005e42:	f000 f891 	bl	8005f68 <_malloc_r>
 8005e46:	b948      	cbnz	r0, 8005e5c <__smakebuf_r+0x44>
 8005e48:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005e4c:	059a      	lsls	r2, r3, #22
 8005e4e:	d4ef      	bmi.n	8005e30 <__smakebuf_r+0x18>
 8005e50:	f023 0303 	bic.w	r3, r3, #3
 8005e54:	f043 0302 	orr.w	r3, r3, #2
 8005e58:	81a3      	strh	r3, [r4, #12]
 8005e5a:	e7e3      	b.n	8005e24 <__smakebuf_r+0xc>
 8005e5c:	4b0d      	ldr	r3, [pc, #52]	; (8005e94 <__smakebuf_r+0x7c>)
 8005e5e:	62b3      	str	r3, [r6, #40]	; 0x28
 8005e60:	89a3      	ldrh	r3, [r4, #12]
 8005e62:	6020      	str	r0, [r4, #0]
 8005e64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005e68:	81a3      	strh	r3, [r4, #12]
 8005e6a:	9b00      	ldr	r3, [sp, #0]
 8005e6c:	6120      	str	r0, [r4, #16]
 8005e6e:	6163      	str	r3, [r4, #20]
 8005e70:	9b01      	ldr	r3, [sp, #4]
 8005e72:	b15b      	cbz	r3, 8005e8c <__smakebuf_r+0x74>
 8005e74:	4630      	mov	r0, r6
 8005e76:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8005e7a:	f000 fc5f 	bl	800673c <_isatty_r>
 8005e7e:	b128      	cbz	r0, 8005e8c <__smakebuf_r+0x74>
 8005e80:	89a3      	ldrh	r3, [r4, #12]
 8005e82:	f023 0303 	bic.w	r3, r3, #3
 8005e86:	f043 0301 	orr.w	r3, r3, #1
 8005e8a:	81a3      	strh	r3, [r4, #12]
 8005e8c:	89a0      	ldrh	r0, [r4, #12]
 8005e8e:	4305      	orrs	r5, r0
 8005e90:	81a5      	strh	r5, [r4, #12]
 8005e92:	e7cd      	b.n	8005e30 <__smakebuf_r+0x18>
 8005e94:	08005c25 	.word	0x08005c25

08005e98 <_free_r>:
 8005e98:	b538      	push	{r3, r4, r5, lr}
 8005e9a:	4605      	mov	r5, r0
 8005e9c:	2900      	cmp	r1, #0
 8005e9e:	d040      	beq.n	8005f22 <_free_r+0x8a>
 8005ea0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8005ea4:	1f0c      	subs	r4, r1, #4
 8005ea6:	2b00      	cmp	r3, #0
 8005ea8:	bfb8      	it	lt
 8005eaa:	18e4      	addlt	r4, r4, r3
 8005eac:	f000 fc76 	bl	800679c <__malloc_lock>
 8005eb0:	4a1c      	ldr	r2, [pc, #112]	; (8005f24 <_free_r+0x8c>)
 8005eb2:	6813      	ldr	r3, [r2, #0]
 8005eb4:	b933      	cbnz	r3, 8005ec4 <_free_r+0x2c>
 8005eb6:	6063      	str	r3, [r4, #4]
 8005eb8:	6014      	str	r4, [r2, #0]
 8005eba:	4628      	mov	r0, r5
 8005ebc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8005ec0:	f000 bc72 	b.w	80067a8 <__malloc_unlock>
 8005ec4:	42a3      	cmp	r3, r4
 8005ec6:	d908      	bls.n	8005eda <_free_r+0x42>
 8005ec8:	6820      	ldr	r0, [r4, #0]
 8005eca:	1821      	adds	r1, r4, r0
 8005ecc:	428b      	cmp	r3, r1
 8005ece:	bf01      	itttt	eq
 8005ed0:	6819      	ldreq	r1, [r3, #0]
 8005ed2:	685b      	ldreq	r3, [r3, #4]
 8005ed4:	1809      	addeq	r1, r1, r0
 8005ed6:	6021      	streq	r1, [r4, #0]
 8005ed8:	e7ed      	b.n	8005eb6 <_free_r+0x1e>
 8005eda:	461a      	mov	r2, r3
 8005edc:	685b      	ldr	r3, [r3, #4]
 8005ede:	b10b      	cbz	r3, 8005ee4 <_free_r+0x4c>
 8005ee0:	42a3      	cmp	r3, r4
 8005ee2:	d9fa      	bls.n	8005eda <_free_r+0x42>
 8005ee4:	6811      	ldr	r1, [r2, #0]
 8005ee6:	1850      	adds	r0, r2, r1
 8005ee8:	42a0      	cmp	r0, r4
 8005eea:	d10b      	bne.n	8005f04 <_free_r+0x6c>
 8005eec:	6820      	ldr	r0, [r4, #0]
 8005eee:	4401      	add	r1, r0
 8005ef0:	1850      	adds	r0, r2, r1
 8005ef2:	4283      	cmp	r3, r0
 8005ef4:	6011      	str	r1, [r2, #0]
 8005ef6:	d1e0      	bne.n	8005eba <_free_r+0x22>
 8005ef8:	6818      	ldr	r0, [r3, #0]
 8005efa:	685b      	ldr	r3, [r3, #4]
 8005efc:	4401      	add	r1, r0
 8005efe:	6011      	str	r1, [r2, #0]
 8005f00:	6053      	str	r3, [r2, #4]
 8005f02:	e7da      	b.n	8005eba <_free_r+0x22>
 8005f04:	d902      	bls.n	8005f0c <_free_r+0x74>
 8005f06:	230c      	movs	r3, #12
 8005f08:	602b      	str	r3, [r5, #0]
 8005f0a:	e7d6      	b.n	8005eba <_free_r+0x22>
 8005f0c:	6820      	ldr	r0, [r4, #0]
 8005f0e:	1821      	adds	r1, r4, r0
 8005f10:	428b      	cmp	r3, r1
 8005f12:	bf01      	itttt	eq
 8005f14:	6819      	ldreq	r1, [r3, #0]
 8005f16:	685b      	ldreq	r3, [r3, #4]
 8005f18:	1809      	addeq	r1, r1, r0
 8005f1a:	6021      	streq	r1, [r4, #0]
 8005f1c:	6063      	str	r3, [r4, #4]
 8005f1e:	6054      	str	r4, [r2, #4]
 8005f20:	e7cb      	b.n	8005eba <_free_r+0x22>
 8005f22:	bd38      	pop	{r3, r4, r5, pc}
 8005f24:	20001018 	.word	0x20001018

08005f28 <sbrk_aligned>:
 8005f28:	b570      	push	{r4, r5, r6, lr}
 8005f2a:	4e0e      	ldr	r6, [pc, #56]	; (8005f64 <sbrk_aligned+0x3c>)
 8005f2c:	460c      	mov	r4, r1
 8005f2e:	6831      	ldr	r1, [r6, #0]
 8005f30:	4605      	mov	r5, r0
 8005f32:	b911      	cbnz	r1, 8005f3a <sbrk_aligned+0x12>
 8005f34:	f000 fb7a 	bl	800662c <_sbrk_r>
 8005f38:	6030      	str	r0, [r6, #0]
 8005f3a:	4621      	mov	r1, r4
 8005f3c:	4628      	mov	r0, r5
 8005f3e:	f000 fb75 	bl	800662c <_sbrk_r>
 8005f42:	1c43      	adds	r3, r0, #1
 8005f44:	d00a      	beq.n	8005f5c <sbrk_aligned+0x34>
 8005f46:	1cc4      	adds	r4, r0, #3
 8005f48:	f024 0403 	bic.w	r4, r4, #3
 8005f4c:	42a0      	cmp	r0, r4
 8005f4e:	d007      	beq.n	8005f60 <sbrk_aligned+0x38>
 8005f50:	1a21      	subs	r1, r4, r0
 8005f52:	4628      	mov	r0, r5
 8005f54:	f000 fb6a 	bl	800662c <_sbrk_r>
 8005f58:	3001      	adds	r0, #1
 8005f5a:	d101      	bne.n	8005f60 <sbrk_aligned+0x38>
 8005f5c:	f04f 34ff 	mov.w	r4, #4294967295
 8005f60:	4620      	mov	r0, r4
 8005f62:	bd70      	pop	{r4, r5, r6, pc}
 8005f64:	2000101c 	.word	0x2000101c

08005f68 <_malloc_r>:
 8005f68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005f6c:	1ccd      	adds	r5, r1, #3
 8005f6e:	f025 0503 	bic.w	r5, r5, #3
 8005f72:	3508      	adds	r5, #8
 8005f74:	2d0c      	cmp	r5, #12
 8005f76:	bf38      	it	cc
 8005f78:	250c      	movcc	r5, #12
 8005f7a:	2d00      	cmp	r5, #0
 8005f7c:	4607      	mov	r7, r0
 8005f7e:	db01      	blt.n	8005f84 <_malloc_r+0x1c>
 8005f80:	42a9      	cmp	r1, r5
 8005f82:	d905      	bls.n	8005f90 <_malloc_r+0x28>
 8005f84:	230c      	movs	r3, #12
 8005f86:	2600      	movs	r6, #0
 8005f88:	603b      	str	r3, [r7, #0]
 8005f8a:	4630      	mov	r0, r6
 8005f8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005f90:	4e2e      	ldr	r6, [pc, #184]	; (800604c <_malloc_r+0xe4>)
 8005f92:	f000 fc03 	bl	800679c <__malloc_lock>
 8005f96:	6833      	ldr	r3, [r6, #0]
 8005f98:	461c      	mov	r4, r3
 8005f9a:	bb34      	cbnz	r4, 8005fea <_malloc_r+0x82>
 8005f9c:	4629      	mov	r1, r5
 8005f9e:	4638      	mov	r0, r7
 8005fa0:	f7ff ffc2 	bl	8005f28 <sbrk_aligned>
 8005fa4:	1c43      	adds	r3, r0, #1
 8005fa6:	4604      	mov	r4, r0
 8005fa8:	d14d      	bne.n	8006046 <_malloc_r+0xde>
 8005faa:	6834      	ldr	r4, [r6, #0]
 8005fac:	4626      	mov	r6, r4
 8005fae:	2e00      	cmp	r6, #0
 8005fb0:	d140      	bne.n	8006034 <_malloc_r+0xcc>
 8005fb2:	6823      	ldr	r3, [r4, #0]
 8005fb4:	4631      	mov	r1, r6
 8005fb6:	4638      	mov	r0, r7
 8005fb8:	eb04 0803 	add.w	r8, r4, r3
 8005fbc:	f000 fb36 	bl	800662c <_sbrk_r>
 8005fc0:	4580      	cmp	r8, r0
 8005fc2:	d13a      	bne.n	800603a <_malloc_r+0xd2>
 8005fc4:	6821      	ldr	r1, [r4, #0]
 8005fc6:	3503      	adds	r5, #3
 8005fc8:	1a6d      	subs	r5, r5, r1
 8005fca:	f025 0503 	bic.w	r5, r5, #3
 8005fce:	3508      	adds	r5, #8
 8005fd0:	2d0c      	cmp	r5, #12
 8005fd2:	bf38      	it	cc
 8005fd4:	250c      	movcc	r5, #12
 8005fd6:	4638      	mov	r0, r7
 8005fd8:	4629      	mov	r1, r5
 8005fda:	f7ff ffa5 	bl	8005f28 <sbrk_aligned>
 8005fde:	3001      	adds	r0, #1
 8005fe0:	d02b      	beq.n	800603a <_malloc_r+0xd2>
 8005fe2:	6823      	ldr	r3, [r4, #0]
 8005fe4:	442b      	add	r3, r5
 8005fe6:	6023      	str	r3, [r4, #0]
 8005fe8:	e00e      	b.n	8006008 <_malloc_r+0xa0>
 8005fea:	6822      	ldr	r2, [r4, #0]
 8005fec:	1b52      	subs	r2, r2, r5
 8005fee:	d41e      	bmi.n	800602e <_malloc_r+0xc6>
 8005ff0:	2a0b      	cmp	r2, #11
 8005ff2:	d916      	bls.n	8006022 <_malloc_r+0xba>
 8005ff4:	1961      	adds	r1, r4, r5
 8005ff6:	42a3      	cmp	r3, r4
 8005ff8:	6025      	str	r5, [r4, #0]
 8005ffa:	bf18      	it	ne
 8005ffc:	6059      	strne	r1, [r3, #4]
 8005ffe:	6863      	ldr	r3, [r4, #4]
 8006000:	bf08      	it	eq
 8006002:	6031      	streq	r1, [r6, #0]
 8006004:	5162      	str	r2, [r4, r5]
 8006006:	604b      	str	r3, [r1, #4]
 8006008:	4638      	mov	r0, r7
 800600a:	f104 060b 	add.w	r6, r4, #11
 800600e:	f000 fbcb 	bl	80067a8 <__malloc_unlock>
 8006012:	f026 0607 	bic.w	r6, r6, #7
 8006016:	1d23      	adds	r3, r4, #4
 8006018:	1af2      	subs	r2, r6, r3
 800601a:	d0b6      	beq.n	8005f8a <_malloc_r+0x22>
 800601c:	1b9b      	subs	r3, r3, r6
 800601e:	50a3      	str	r3, [r4, r2]
 8006020:	e7b3      	b.n	8005f8a <_malloc_r+0x22>
 8006022:	6862      	ldr	r2, [r4, #4]
 8006024:	42a3      	cmp	r3, r4
 8006026:	bf0c      	ite	eq
 8006028:	6032      	streq	r2, [r6, #0]
 800602a:	605a      	strne	r2, [r3, #4]
 800602c:	e7ec      	b.n	8006008 <_malloc_r+0xa0>
 800602e:	4623      	mov	r3, r4
 8006030:	6864      	ldr	r4, [r4, #4]
 8006032:	e7b2      	b.n	8005f9a <_malloc_r+0x32>
 8006034:	4634      	mov	r4, r6
 8006036:	6876      	ldr	r6, [r6, #4]
 8006038:	e7b9      	b.n	8005fae <_malloc_r+0x46>
 800603a:	230c      	movs	r3, #12
 800603c:	4638      	mov	r0, r7
 800603e:	603b      	str	r3, [r7, #0]
 8006040:	f000 fbb2 	bl	80067a8 <__malloc_unlock>
 8006044:	e7a1      	b.n	8005f8a <_malloc_r+0x22>
 8006046:	6025      	str	r5, [r4, #0]
 8006048:	e7de      	b.n	8006008 <_malloc_r+0xa0>
 800604a:	bf00      	nop
 800604c:	20001018 	.word	0x20001018

08006050 <__sfputc_r>:
 8006050:	6893      	ldr	r3, [r2, #8]
 8006052:	b410      	push	{r4}
 8006054:	3b01      	subs	r3, #1
 8006056:	2b00      	cmp	r3, #0
 8006058:	6093      	str	r3, [r2, #8]
 800605a:	da07      	bge.n	800606c <__sfputc_r+0x1c>
 800605c:	6994      	ldr	r4, [r2, #24]
 800605e:	42a3      	cmp	r3, r4
 8006060:	db01      	blt.n	8006066 <__sfputc_r+0x16>
 8006062:	290a      	cmp	r1, #10
 8006064:	d102      	bne.n	800606c <__sfputc_r+0x1c>
 8006066:	bc10      	pop	{r4}
 8006068:	f7ff bc3a 	b.w	80058e0 <__swbuf_r>
 800606c:	6813      	ldr	r3, [r2, #0]
 800606e:	1c58      	adds	r0, r3, #1
 8006070:	6010      	str	r0, [r2, #0]
 8006072:	7019      	strb	r1, [r3, #0]
 8006074:	4608      	mov	r0, r1
 8006076:	bc10      	pop	{r4}
 8006078:	4770      	bx	lr

0800607a <__sfputs_r>:
 800607a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800607c:	4606      	mov	r6, r0
 800607e:	460f      	mov	r7, r1
 8006080:	4614      	mov	r4, r2
 8006082:	18d5      	adds	r5, r2, r3
 8006084:	42ac      	cmp	r4, r5
 8006086:	d101      	bne.n	800608c <__sfputs_r+0x12>
 8006088:	2000      	movs	r0, #0
 800608a:	e007      	b.n	800609c <__sfputs_r+0x22>
 800608c:	463a      	mov	r2, r7
 800608e:	4630      	mov	r0, r6
 8006090:	f814 1b01 	ldrb.w	r1, [r4], #1
 8006094:	f7ff ffdc 	bl	8006050 <__sfputc_r>
 8006098:	1c43      	adds	r3, r0, #1
 800609a:	d1f3      	bne.n	8006084 <__sfputs_r+0xa>
 800609c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080060a0 <_vfiprintf_r>:
 80060a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80060a4:	460d      	mov	r5, r1
 80060a6:	4614      	mov	r4, r2
 80060a8:	4698      	mov	r8, r3
 80060aa:	4606      	mov	r6, r0
 80060ac:	b09d      	sub	sp, #116	; 0x74
 80060ae:	b118      	cbz	r0, 80060b8 <_vfiprintf_r+0x18>
 80060b0:	6983      	ldr	r3, [r0, #24]
 80060b2:	b90b      	cbnz	r3, 80060b8 <_vfiprintf_r+0x18>
 80060b4:	f7ff fdea 	bl	8005c8c <__sinit>
 80060b8:	4b89      	ldr	r3, [pc, #548]	; (80062e0 <_vfiprintf_r+0x240>)
 80060ba:	429d      	cmp	r5, r3
 80060bc:	d11b      	bne.n	80060f6 <_vfiprintf_r+0x56>
 80060be:	6875      	ldr	r5, [r6, #4]
 80060c0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80060c2:	07d9      	lsls	r1, r3, #31
 80060c4:	d405      	bmi.n	80060d2 <_vfiprintf_r+0x32>
 80060c6:	89ab      	ldrh	r3, [r5, #12]
 80060c8:	059a      	lsls	r2, r3, #22
 80060ca:	d402      	bmi.n	80060d2 <_vfiprintf_r+0x32>
 80060cc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80060ce:	f7ff fe7b 	bl	8005dc8 <__retarget_lock_acquire_recursive>
 80060d2:	89ab      	ldrh	r3, [r5, #12]
 80060d4:	071b      	lsls	r3, r3, #28
 80060d6:	d501      	bpl.n	80060dc <_vfiprintf_r+0x3c>
 80060d8:	692b      	ldr	r3, [r5, #16]
 80060da:	b9eb      	cbnz	r3, 8006118 <_vfiprintf_r+0x78>
 80060dc:	4629      	mov	r1, r5
 80060de:	4630      	mov	r0, r6
 80060e0:	f7ff fc50 	bl	8005984 <__swsetup_r>
 80060e4:	b1c0      	cbz	r0, 8006118 <_vfiprintf_r+0x78>
 80060e6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80060e8:	07dc      	lsls	r4, r3, #31
 80060ea:	d50e      	bpl.n	800610a <_vfiprintf_r+0x6a>
 80060ec:	f04f 30ff 	mov.w	r0, #4294967295
 80060f0:	b01d      	add	sp, #116	; 0x74
 80060f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80060f6:	4b7b      	ldr	r3, [pc, #492]	; (80062e4 <_vfiprintf_r+0x244>)
 80060f8:	429d      	cmp	r5, r3
 80060fa:	d101      	bne.n	8006100 <_vfiprintf_r+0x60>
 80060fc:	68b5      	ldr	r5, [r6, #8]
 80060fe:	e7df      	b.n	80060c0 <_vfiprintf_r+0x20>
 8006100:	4b79      	ldr	r3, [pc, #484]	; (80062e8 <_vfiprintf_r+0x248>)
 8006102:	429d      	cmp	r5, r3
 8006104:	bf08      	it	eq
 8006106:	68f5      	ldreq	r5, [r6, #12]
 8006108:	e7da      	b.n	80060c0 <_vfiprintf_r+0x20>
 800610a:	89ab      	ldrh	r3, [r5, #12]
 800610c:	0598      	lsls	r0, r3, #22
 800610e:	d4ed      	bmi.n	80060ec <_vfiprintf_r+0x4c>
 8006110:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8006112:	f7ff fe5a 	bl	8005dca <__retarget_lock_release_recursive>
 8006116:	e7e9      	b.n	80060ec <_vfiprintf_r+0x4c>
 8006118:	2300      	movs	r3, #0
 800611a:	9309      	str	r3, [sp, #36]	; 0x24
 800611c:	2320      	movs	r3, #32
 800611e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8006122:	2330      	movs	r3, #48	; 0x30
 8006124:	f04f 0901 	mov.w	r9, #1
 8006128:	f8cd 800c 	str.w	r8, [sp, #12]
 800612c:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 80062ec <_vfiprintf_r+0x24c>
 8006130:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8006134:	4623      	mov	r3, r4
 8006136:	469a      	mov	sl, r3
 8006138:	f813 2b01 	ldrb.w	r2, [r3], #1
 800613c:	b10a      	cbz	r2, 8006142 <_vfiprintf_r+0xa2>
 800613e:	2a25      	cmp	r2, #37	; 0x25
 8006140:	d1f9      	bne.n	8006136 <_vfiprintf_r+0x96>
 8006142:	ebba 0b04 	subs.w	fp, sl, r4
 8006146:	d00b      	beq.n	8006160 <_vfiprintf_r+0xc0>
 8006148:	465b      	mov	r3, fp
 800614a:	4622      	mov	r2, r4
 800614c:	4629      	mov	r1, r5
 800614e:	4630      	mov	r0, r6
 8006150:	f7ff ff93 	bl	800607a <__sfputs_r>
 8006154:	3001      	adds	r0, #1
 8006156:	f000 80aa 	beq.w	80062ae <_vfiprintf_r+0x20e>
 800615a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800615c:	445a      	add	r2, fp
 800615e:	9209      	str	r2, [sp, #36]	; 0x24
 8006160:	f89a 3000 	ldrb.w	r3, [sl]
 8006164:	2b00      	cmp	r3, #0
 8006166:	f000 80a2 	beq.w	80062ae <_vfiprintf_r+0x20e>
 800616a:	2300      	movs	r3, #0
 800616c:	f04f 32ff 	mov.w	r2, #4294967295
 8006170:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8006174:	f10a 0a01 	add.w	sl, sl, #1
 8006178:	9304      	str	r3, [sp, #16]
 800617a:	9307      	str	r3, [sp, #28]
 800617c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8006180:	931a      	str	r3, [sp, #104]	; 0x68
 8006182:	4654      	mov	r4, sl
 8006184:	2205      	movs	r2, #5
 8006186:	f814 1b01 	ldrb.w	r1, [r4], #1
 800618a:	4858      	ldr	r0, [pc, #352]	; (80062ec <_vfiprintf_r+0x24c>)
 800618c:	f000 faf8 	bl	8006780 <memchr>
 8006190:	9a04      	ldr	r2, [sp, #16]
 8006192:	b9d8      	cbnz	r0, 80061cc <_vfiprintf_r+0x12c>
 8006194:	06d1      	lsls	r1, r2, #27
 8006196:	bf44      	itt	mi
 8006198:	2320      	movmi	r3, #32
 800619a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800619e:	0713      	lsls	r3, r2, #28
 80061a0:	bf44      	itt	mi
 80061a2:	232b      	movmi	r3, #43	; 0x2b
 80061a4:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80061a8:	f89a 3000 	ldrb.w	r3, [sl]
 80061ac:	2b2a      	cmp	r3, #42	; 0x2a
 80061ae:	d015      	beq.n	80061dc <_vfiprintf_r+0x13c>
 80061b0:	4654      	mov	r4, sl
 80061b2:	2000      	movs	r0, #0
 80061b4:	f04f 0c0a 	mov.w	ip, #10
 80061b8:	9a07      	ldr	r2, [sp, #28]
 80061ba:	4621      	mov	r1, r4
 80061bc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80061c0:	3b30      	subs	r3, #48	; 0x30
 80061c2:	2b09      	cmp	r3, #9
 80061c4:	d94e      	bls.n	8006264 <_vfiprintf_r+0x1c4>
 80061c6:	b1b0      	cbz	r0, 80061f6 <_vfiprintf_r+0x156>
 80061c8:	9207      	str	r2, [sp, #28]
 80061ca:	e014      	b.n	80061f6 <_vfiprintf_r+0x156>
 80061cc:	eba0 0308 	sub.w	r3, r0, r8
 80061d0:	fa09 f303 	lsl.w	r3, r9, r3
 80061d4:	4313      	orrs	r3, r2
 80061d6:	46a2      	mov	sl, r4
 80061d8:	9304      	str	r3, [sp, #16]
 80061da:	e7d2      	b.n	8006182 <_vfiprintf_r+0xe2>
 80061dc:	9b03      	ldr	r3, [sp, #12]
 80061de:	1d19      	adds	r1, r3, #4
 80061e0:	681b      	ldr	r3, [r3, #0]
 80061e2:	9103      	str	r1, [sp, #12]
 80061e4:	2b00      	cmp	r3, #0
 80061e6:	bfbb      	ittet	lt
 80061e8:	425b      	neglt	r3, r3
 80061ea:	f042 0202 	orrlt.w	r2, r2, #2
 80061ee:	9307      	strge	r3, [sp, #28]
 80061f0:	9307      	strlt	r3, [sp, #28]
 80061f2:	bfb8      	it	lt
 80061f4:	9204      	strlt	r2, [sp, #16]
 80061f6:	7823      	ldrb	r3, [r4, #0]
 80061f8:	2b2e      	cmp	r3, #46	; 0x2e
 80061fa:	d10c      	bne.n	8006216 <_vfiprintf_r+0x176>
 80061fc:	7863      	ldrb	r3, [r4, #1]
 80061fe:	2b2a      	cmp	r3, #42	; 0x2a
 8006200:	d135      	bne.n	800626e <_vfiprintf_r+0x1ce>
 8006202:	9b03      	ldr	r3, [sp, #12]
 8006204:	3402      	adds	r4, #2
 8006206:	1d1a      	adds	r2, r3, #4
 8006208:	681b      	ldr	r3, [r3, #0]
 800620a:	9203      	str	r2, [sp, #12]
 800620c:	2b00      	cmp	r3, #0
 800620e:	bfb8      	it	lt
 8006210:	f04f 33ff 	movlt.w	r3, #4294967295
 8006214:	9305      	str	r3, [sp, #20]
 8006216:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 80062f0 <_vfiprintf_r+0x250>
 800621a:	2203      	movs	r2, #3
 800621c:	4650      	mov	r0, sl
 800621e:	7821      	ldrb	r1, [r4, #0]
 8006220:	f000 faae 	bl	8006780 <memchr>
 8006224:	b140      	cbz	r0, 8006238 <_vfiprintf_r+0x198>
 8006226:	2340      	movs	r3, #64	; 0x40
 8006228:	eba0 000a 	sub.w	r0, r0, sl
 800622c:	fa03 f000 	lsl.w	r0, r3, r0
 8006230:	9b04      	ldr	r3, [sp, #16]
 8006232:	3401      	adds	r4, #1
 8006234:	4303      	orrs	r3, r0
 8006236:	9304      	str	r3, [sp, #16]
 8006238:	f814 1b01 	ldrb.w	r1, [r4], #1
 800623c:	2206      	movs	r2, #6
 800623e:	482d      	ldr	r0, [pc, #180]	; (80062f4 <_vfiprintf_r+0x254>)
 8006240:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8006244:	f000 fa9c 	bl	8006780 <memchr>
 8006248:	2800      	cmp	r0, #0
 800624a:	d03f      	beq.n	80062cc <_vfiprintf_r+0x22c>
 800624c:	4b2a      	ldr	r3, [pc, #168]	; (80062f8 <_vfiprintf_r+0x258>)
 800624e:	bb1b      	cbnz	r3, 8006298 <_vfiprintf_r+0x1f8>
 8006250:	9b03      	ldr	r3, [sp, #12]
 8006252:	3307      	adds	r3, #7
 8006254:	f023 0307 	bic.w	r3, r3, #7
 8006258:	3308      	adds	r3, #8
 800625a:	9303      	str	r3, [sp, #12]
 800625c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800625e:	443b      	add	r3, r7
 8006260:	9309      	str	r3, [sp, #36]	; 0x24
 8006262:	e767      	b.n	8006134 <_vfiprintf_r+0x94>
 8006264:	460c      	mov	r4, r1
 8006266:	2001      	movs	r0, #1
 8006268:	fb0c 3202 	mla	r2, ip, r2, r3
 800626c:	e7a5      	b.n	80061ba <_vfiprintf_r+0x11a>
 800626e:	2300      	movs	r3, #0
 8006270:	f04f 0c0a 	mov.w	ip, #10
 8006274:	4619      	mov	r1, r3
 8006276:	3401      	adds	r4, #1
 8006278:	9305      	str	r3, [sp, #20]
 800627a:	4620      	mov	r0, r4
 800627c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8006280:	3a30      	subs	r2, #48	; 0x30
 8006282:	2a09      	cmp	r2, #9
 8006284:	d903      	bls.n	800628e <_vfiprintf_r+0x1ee>
 8006286:	2b00      	cmp	r3, #0
 8006288:	d0c5      	beq.n	8006216 <_vfiprintf_r+0x176>
 800628a:	9105      	str	r1, [sp, #20]
 800628c:	e7c3      	b.n	8006216 <_vfiprintf_r+0x176>
 800628e:	4604      	mov	r4, r0
 8006290:	2301      	movs	r3, #1
 8006292:	fb0c 2101 	mla	r1, ip, r1, r2
 8006296:	e7f0      	b.n	800627a <_vfiprintf_r+0x1da>
 8006298:	ab03      	add	r3, sp, #12
 800629a:	9300      	str	r3, [sp, #0]
 800629c:	462a      	mov	r2, r5
 800629e:	4630      	mov	r0, r6
 80062a0:	4b16      	ldr	r3, [pc, #88]	; (80062fc <_vfiprintf_r+0x25c>)
 80062a2:	a904      	add	r1, sp, #16
 80062a4:	f3af 8000 	nop.w
 80062a8:	4607      	mov	r7, r0
 80062aa:	1c78      	adds	r0, r7, #1
 80062ac:	d1d6      	bne.n	800625c <_vfiprintf_r+0x1bc>
 80062ae:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80062b0:	07d9      	lsls	r1, r3, #31
 80062b2:	d405      	bmi.n	80062c0 <_vfiprintf_r+0x220>
 80062b4:	89ab      	ldrh	r3, [r5, #12]
 80062b6:	059a      	lsls	r2, r3, #22
 80062b8:	d402      	bmi.n	80062c0 <_vfiprintf_r+0x220>
 80062ba:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80062bc:	f7ff fd85 	bl	8005dca <__retarget_lock_release_recursive>
 80062c0:	89ab      	ldrh	r3, [r5, #12]
 80062c2:	065b      	lsls	r3, r3, #25
 80062c4:	f53f af12 	bmi.w	80060ec <_vfiprintf_r+0x4c>
 80062c8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80062ca:	e711      	b.n	80060f0 <_vfiprintf_r+0x50>
 80062cc:	ab03      	add	r3, sp, #12
 80062ce:	9300      	str	r3, [sp, #0]
 80062d0:	462a      	mov	r2, r5
 80062d2:	4630      	mov	r0, r6
 80062d4:	4b09      	ldr	r3, [pc, #36]	; (80062fc <_vfiprintf_r+0x25c>)
 80062d6:	a904      	add	r1, sp, #16
 80062d8:	f000 f882 	bl	80063e0 <_printf_i>
 80062dc:	e7e4      	b.n	80062a8 <_vfiprintf_r+0x208>
 80062de:	bf00      	nop
 80062e0:	08006964 	.word	0x08006964
 80062e4:	08006984 	.word	0x08006984
 80062e8:	08006944 	.word	0x08006944
 80062ec:	080069a4 	.word	0x080069a4
 80062f0:	080069aa 	.word	0x080069aa
 80062f4:	080069ae 	.word	0x080069ae
 80062f8:	00000000 	.word	0x00000000
 80062fc:	0800607b 	.word	0x0800607b

08006300 <_printf_common>:
 8006300:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006304:	4616      	mov	r6, r2
 8006306:	4699      	mov	r9, r3
 8006308:	688a      	ldr	r2, [r1, #8]
 800630a:	690b      	ldr	r3, [r1, #16]
 800630c:	4607      	mov	r7, r0
 800630e:	4293      	cmp	r3, r2
 8006310:	bfb8      	it	lt
 8006312:	4613      	movlt	r3, r2
 8006314:	6033      	str	r3, [r6, #0]
 8006316:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800631a:	460c      	mov	r4, r1
 800631c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8006320:	b10a      	cbz	r2, 8006326 <_printf_common+0x26>
 8006322:	3301      	adds	r3, #1
 8006324:	6033      	str	r3, [r6, #0]
 8006326:	6823      	ldr	r3, [r4, #0]
 8006328:	0699      	lsls	r1, r3, #26
 800632a:	bf42      	ittt	mi
 800632c:	6833      	ldrmi	r3, [r6, #0]
 800632e:	3302      	addmi	r3, #2
 8006330:	6033      	strmi	r3, [r6, #0]
 8006332:	6825      	ldr	r5, [r4, #0]
 8006334:	f015 0506 	ands.w	r5, r5, #6
 8006338:	d106      	bne.n	8006348 <_printf_common+0x48>
 800633a:	f104 0a19 	add.w	sl, r4, #25
 800633e:	68e3      	ldr	r3, [r4, #12]
 8006340:	6832      	ldr	r2, [r6, #0]
 8006342:	1a9b      	subs	r3, r3, r2
 8006344:	42ab      	cmp	r3, r5
 8006346:	dc28      	bgt.n	800639a <_printf_common+0x9a>
 8006348:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800634c:	1e13      	subs	r3, r2, #0
 800634e:	6822      	ldr	r2, [r4, #0]
 8006350:	bf18      	it	ne
 8006352:	2301      	movne	r3, #1
 8006354:	0692      	lsls	r2, r2, #26
 8006356:	d42d      	bmi.n	80063b4 <_printf_common+0xb4>
 8006358:	4649      	mov	r1, r9
 800635a:	4638      	mov	r0, r7
 800635c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8006360:	47c0      	blx	r8
 8006362:	3001      	adds	r0, #1
 8006364:	d020      	beq.n	80063a8 <_printf_common+0xa8>
 8006366:	6823      	ldr	r3, [r4, #0]
 8006368:	68e5      	ldr	r5, [r4, #12]
 800636a:	f003 0306 	and.w	r3, r3, #6
 800636e:	2b04      	cmp	r3, #4
 8006370:	bf18      	it	ne
 8006372:	2500      	movne	r5, #0
 8006374:	6832      	ldr	r2, [r6, #0]
 8006376:	f04f 0600 	mov.w	r6, #0
 800637a:	68a3      	ldr	r3, [r4, #8]
 800637c:	bf08      	it	eq
 800637e:	1aad      	subeq	r5, r5, r2
 8006380:	6922      	ldr	r2, [r4, #16]
 8006382:	bf08      	it	eq
 8006384:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8006388:	4293      	cmp	r3, r2
 800638a:	bfc4      	itt	gt
 800638c:	1a9b      	subgt	r3, r3, r2
 800638e:	18ed      	addgt	r5, r5, r3
 8006390:	341a      	adds	r4, #26
 8006392:	42b5      	cmp	r5, r6
 8006394:	d11a      	bne.n	80063cc <_printf_common+0xcc>
 8006396:	2000      	movs	r0, #0
 8006398:	e008      	b.n	80063ac <_printf_common+0xac>
 800639a:	2301      	movs	r3, #1
 800639c:	4652      	mov	r2, sl
 800639e:	4649      	mov	r1, r9
 80063a0:	4638      	mov	r0, r7
 80063a2:	47c0      	blx	r8
 80063a4:	3001      	adds	r0, #1
 80063a6:	d103      	bne.n	80063b0 <_printf_common+0xb0>
 80063a8:	f04f 30ff 	mov.w	r0, #4294967295
 80063ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80063b0:	3501      	adds	r5, #1
 80063b2:	e7c4      	b.n	800633e <_printf_common+0x3e>
 80063b4:	2030      	movs	r0, #48	; 0x30
 80063b6:	18e1      	adds	r1, r4, r3
 80063b8:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80063bc:	1c5a      	adds	r2, r3, #1
 80063be:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80063c2:	4422      	add	r2, r4
 80063c4:	3302      	adds	r3, #2
 80063c6:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80063ca:	e7c5      	b.n	8006358 <_printf_common+0x58>
 80063cc:	2301      	movs	r3, #1
 80063ce:	4622      	mov	r2, r4
 80063d0:	4649      	mov	r1, r9
 80063d2:	4638      	mov	r0, r7
 80063d4:	47c0      	blx	r8
 80063d6:	3001      	adds	r0, #1
 80063d8:	d0e6      	beq.n	80063a8 <_printf_common+0xa8>
 80063da:	3601      	adds	r6, #1
 80063dc:	e7d9      	b.n	8006392 <_printf_common+0x92>
	...

080063e0 <_printf_i>:
 80063e0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80063e4:	7e0f      	ldrb	r7, [r1, #24]
 80063e6:	4691      	mov	r9, r2
 80063e8:	2f78      	cmp	r7, #120	; 0x78
 80063ea:	4680      	mov	r8, r0
 80063ec:	460c      	mov	r4, r1
 80063ee:	469a      	mov	sl, r3
 80063f0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80063f2:	f101 0243 	add.w	r2, r1, #67	; 0x43
 80063f6:	d807      	bhi.n	8006408 <_printf_i+0x28>
 80063f8:	2f62      	cmp	r7, #98	; 0x62
 80063fa:	d80a      	bhi.n	8006412 <_printf_i+0x32>
 80063fc:	2f00      	cmp	r7, #0
 80063fe:	f000 80d9 	beq.w	80065b4 <_printf_i+0x1d4>
 8006402:	2f58      	cmp	r7, #88	; 0x58
 8006404:	f000 80a4 	beq.w	8006550 <_printf_i+0x170>
 8006408:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800640c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8006410:	e03a      	b.n	8006488 <_printf_i+0xa8>
 8006412:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8006416:	2b15      	cmp	r3, #21
 8006418:	d8f6      	bhi.n	8006408 <_printf_i+0x28>
 800641a:	a101      	add	r1, pc, #4	; (adr r1, 8006420 <_printf_i+0x40>)
 800641c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8006420:	08006479 	.word	0x08006479
 8006424:	0800648d 	.word	0x0800648d
 8006428:	08006409 	.word	0x08006409
 800642c:	08006409 	.word	0x08006409
 8006430:	08006409 	.word	0x08006409
 8006434:	08006409 	.word	0x08006409
 8006438:	0800648d 	.word	0x0800648d
 800643c:	08006409 	.word	0x08006409
 8006440:	08006409 	.word	0x08006409
 8006444:	08006409 	.word	0x08006409
 8006448:	08006409 	.word	0x08006409
 800644c:	0800659b 	.word	0x0800659b
 8006450:	080064bd 	.word	0x080064bd
 8006454:	0800657d 	.word	0x0800657d
 8006458:	08006409 	.word	0x08006409
 800645c:	08006409 	.word	0x08006409
 8006460:	080065bd 	.word	0x080065bd
 8006464:	08006409 	.word	0x08006409
 8006468:	080064bd 	.word	0x080064bd
 800646c:	08006409 	.word	0x08006409
 8006470:	08006409 	.word	0x08006409
 8006474:	08006585 	.word	0x08006585
 8006478:	682b      	ldr	r3, [r5, #0]
 800647a:	1d1a      	adds	r2, r3, #4
 800647c:	681b      	ldr	r3, [r3, #0]
 800647e:	602a      	str	r2, [r5, #0]
 8006480:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8006484:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8006488:	2301      	movs	r3, #1
 800648a:	e0a4      	b.n	80065d6 <_printf_i+0x1f6>
 800648c:	6820      	ldr	r0, [r4, #0]
 800648e:	6829      	ldr	r1, [r5, #0]
 8006490:	0606      	lsls	r6, r0, #24
 8006492:	f101 0304 	add.w	r3, r1, #4
 8006496:	d50a      	bpl.n	80064ae <_printf_i+0xce>
 8006498:	680e      	ldr	r6, [r1, #0]
 800649a:	602b      	str	r3, [r5, #0]
 800649c:	2e00      	cmp	r6, #0
 800649e:	da03      	bge.n	80064a8 <_printf_i+0xc8>
 80064a0:	232d      	movs	r3, #45	; 0x2d
 80064a2:	4276      	negs	r6, r6
 80064a4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80064a8:	230a      	movs	r3, #10
 80064aa:	485e      	ldr	r0, [pc, #376]	; (8006624 <_printf_i+0x244>)
 80064ac:	e019      	b.n	80064e2 <_printf_i+0x102>
 80064ae:	680e      	ldr	r6, [r1, #0]
 80064b0:	f010 0f40 	tst.w	r0, #64	; 0x40
 80064b4:	602b      	str	r3, [r5, #0]
 80064b6:	bf18      	it	ne
 80064b8:	b236      	sxthne	r6, r6
 80064ba:	e7ef      	b.n	800649c <_printf_i+0xbc>
 80064bc:	682b      	ldr	r3, [r5, #0]
 80064be:	6820      	ldr	r0, [r4, #0]
 80064c0:	1d19      	adds	r1, r3, #4
 80064c2:	6029      	str	r1, [r5, #0]
 80064c4:	0601      	lsls	r1, r0, #24
 80064c6:	d501      	bpl.n	80064cc <_printf_i+0xec>
 80064c8:	681e      	ldr	r6, [r3, #0]
 80064ca:	e002      	b.n	80064d2 <_printf_i+0xf2>
 80064cc:	0646      	lsls	r6, r0, #25
 80064ce:	d5fb      	bpl.n	80064c8 <_printf_i+0xe8>
 80064d0:	881e      	ldrh	r6, [r3, #0]
 80064d2:	2f6f      	cmp	r7, #111	; 0x6f
 80064d4:	bf0c      	ite	eq
 80064d6:	2308      	moveq	r3, #8
 80064d8:	230a      	movne	r3, #10
 80064da:	4852      	ldr	r0, [pc, #328]	; (8006624 <_printf_i+0x244>)
 80064dc:	2100      	movs	r1, #0
 80064de:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80064e2:	6865      	ldr	r5, [r4, #4]
 80064e4:	2d00      	cmp	r5, #0
 80064e6:	bfa8      	it	ge
 80064e8:	6821      	ldrge	r1, [r4, #0]
 80064ea:	60a5      	str	r5, [r4, #8]
 80064ec:	bfa4      	itt	ge
 80064ee:	f021 0104 	bicge.w	r1, r1, #4
 80064f2:	6021      	strge	r1, [r4, #0]
 80064f4:	b90e      	cbnz	r6, 80064fa <_printf_i+0x11a>
 80064f6:	2d00      	cmp	r5, #0
 80064f8:	d04d      	beq.n	8006596 <_printf_i+0x1b6>
 80064fa:	4615      	mov	r5, r2
 80064fc:	fbb6 f1f3 	udiv	r1, r6, r3
 8006500:	fb03 6711 	mls	r7, r3, r1, r6
 8006504:	5dc7      	ldrb	r7, [r0, r7]
 8006506:	f805 7d01 	strb.w	r7, [r5, #-1]!
 800650a:	4637      	mov	r7, r6
 800650c:	42bb      	cmp	r3, r7
 800650e:	460e      	mov	r6, r1
 8006510:	d9f4      	bls.n	80064fc <_printf_i+0x11c>
 8006512:	2b08      	cmp	r3, #8
 8006514:	d10b      	bne.n	800652e <_printf_i+0x14e>
 8006516:	6823      	ldr	r3, [r4, #0]
 8006518:	07de      	lsls	r6, r3, #31
 800651a:	d508      	bpl.n	800652e <_printf_i+0x14e>
 800651c:	6923      	ldr	r3, [r4, #16]
 800651e:	6861      	ldr	r1, [r4, #4]
 8006520:	4299      	cmp	r1, r3
 8006522:	bfde      	ittt	le
 8006524:	2330      	movle	r3, #48	; 0x30
 8006526:	f805 3c01 	strble.w	r3, [r5, #-1]
 800652a:	f105 35ff 	addle.w	r5, r5, #4294967295
 800652e:	1b52      	subs	r2, r2, r5
 8006530:	6122      	str	r2, [r4, #16]
 8006532:	464b      	mov	r3, r9
 8006534:	4621      	mov	r1, r4
 8006536:	4640      	mov	r0, r8
 8006538:	f8cd a000 	str.w	sl, [sp]
 800653c:	aa03      	add	r2, sp, #12
 800653e:	f7ff fedf 	bl	8006300 <_printf_common>
 8006542:	3001      	adds	r0, #1
 8006544:	d14c      	bne.n	80065e0 <_printf_i+0x200>
 8006546:	f04f 30ff 	mov.w	r0, #4294967295
 800654a:	b004      	add	sp, #16
 800654c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006550:	4834      	ldr	r0, [pc, #208]	; (8006624 <_printf_i+0x244>)
 8006552:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 8006556:	6829      	ldr	r1, [r5, #0]
 8006558:	6823      	ldr	r3, [r4, #0]
 800655a:	f851 6b04 	ldr.w	r6, [r1], #4
 800655e:	6029      	str	r1, [r5, #0]
 8006560:	061d      	lsls	r5, r3, #24
 8006562:	d514      	bpl.n	800658e <_printf_i+0x1ae>
 8006564:	07df      	lsls	r7, r3, #31
 8006566:	bf44      	itt	mi
 8006568:	f043 0320 	orrmi.w	r3, r3, #32
 800656c:	6023      	strmi	r3, [r4, #0]
 800656e:	b91e      	cbnz	r6, 8006578 <_printf_i+0x198>
 8006570:	6823      	ldr	r3, [r4, #0]
 8006572:	f023 0320 	bic.w	r3, r3, #32
 8006576:	6023      	str	r3, [r4, #0]
 8006578:	2310      	movs	r3, #16
 800657a:	e7af      	b.n	80064dc <_printf_i+0xfc>
 800657c:	6823      	ldr	r3, [r4, #0]
 800657e:	f043 0320 	orr.w	r3, r3, #32
 8006582:	6023      	str	r3, [r4, #0]
 8006584:	2378      	movs	r3, #120	; 0x78
 8006586:	4828      	ldr	r0, [pc, #160]	; (8006628 <_printf_i+0x248>)
 8006588:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800658c:	e7e3      	b.n	8006556 <_printf_i+0x176>
 800658e:	0659      	lsls	r1, r3, #25
 8006590:	bf48      	it	mi
 8006592:	b2b6      	uxthmi	r6, r6
 8006594:	e7e6      	b.n	8006564 <_printf_i+0x184>
 8006596:	4615      	mov	r5, r2
 8006598:	e7bb      	b.n	8006512 <_printf_i+0x132>
 800659a:	682b      	ldr	r3, [r5, #0]
 800659c:	6826      	ldr	r6, [r4, #0]
 800659e:	1d18      	adds	r0, r3, #4
 80065a0:	6961      	ldr	r1, [r4, #20]
 80065a2:	6028      	str	r0, [r5, #0]
 80065a4:	0635      	lsls	r5, r6, #24
 80065a6:	681b      	ldr	r3, [r3, #0]
 80065a8:	d501      	bpl.n	80065ae <_printf_i+0x1ce>
 80065aa:	6019      	str	r1, [r3, #0]
 80065ac:	e002      	b.n	80065b4 <_printf_i+0x1d4>
 80065ae:	0670      	lsls	r0, r6, #25
 80065b0:	d5fb      	bpl.n	80065aa <_printf_i+0x1ca>
 80065b2:	8019      	strh	r1, [r3, #0]
 80065b4:	2300      	movs	r3, #0
 80065b6:	4615      	mov	r5, r2
 80065b8:	6123      	str	r3, [r4, #16]
 80065ba:	e7ba      	b.n	8006532 <_printf_i+0x152>
 80065bc:	682b      	ldr	r3, [r5, #0]
 80065be:	2100      	movs	r1, #0
 80065c0:	1d1a      	adds	r2, r3, #4
 80065c2:	602a      	str	r2, [r5, #0]
 80065c4:	681d      	ldr	r5, [r3, #0]
 80065c6:	6862      	ldr	r2, [r4, #4]
 80065c8:	4628      	mov	r0, r5
 80065ca:	f000 f8d9 	bl	8006780 <memchr>
 80065ce:	b108      	cbz	r0, 80065d4 <_printf_i+0x1f4>
 80065d0:	1b40      	subs	r0, r0, r5
 80065d2:	6060      	str	r0, [r4, #4]
 80065d4:	6863      	ldr	r3, [r4, #4]
 80065d6:	6123      	str	r3, [r4, #16]
 80065d8:	2300      	movs	r3, #0
 80065da:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80065de:	e7a8      	b.n	8006532 <_printf_i+0x152>
 80065e0:	462a      	mov	r2, r5
 80065e2:	4649      	mov	r1, r9
 80065e4:	4640      	mov	r0, r8
 80065e6:	6923      	ldr	r3, [r4, #16]
 80065e8:	47d0      	blx	sl
 80065ea:	3001      	adds	r0, #1
 80065ec:	d0ab      	beq.n	8006546 <_printf_i+0x166>
 80065ee:	6823      	ldr	r3, [r4, #0]
 80065f0:	079b      	lsls	r3, r3, #30
 80065f2:	d413      	bmi.n	800661c <_printf_i+0x23c>
 80065f4:	68e0      	ldr	r0, [r4, #12]
 80065f6:	9b03      	ldr	r3, [sp, #12]
 80065f8:	4298      	cmp	r0, r3
 80065fa:	bfb8      	it	lt
 80065fc:	4618      	movlt	r0, r3
 80065fe:	e7a4      	b.n	800654a <_printf_i+0x16a>
 8006600:	2301      	movs	r3, #1
 8006602:	4632      	mov	r2, r6
 8006604:	4649      	mov	r1, r9
 8006606:	4640      	mov	r0, r8
 8006608:	47d0      	blx	sl
 800660a:	3001      	adds	r0, #1
 800660c:	d09b      	beq.n	8006546 <_printf_i+0x166>
 800660e:	3501      	adds	r5, #1
 8006610:	68e3      	ldr	r3, [r4, #12]
 8006612:	9903      	ldr	r1, [sp, #12]
 8006614:	1a5b      	subs	r3, r3, r1
 8006616:	42ab      	cmp	r3, r5
 8006618:	dcf2      	bgt.n	8006600 <_printf_i+0x220>
 800661a:	e7eb      	b.n	80065f4 <_printf_i+0x214>
 800661c:	2500      	movs	r5, #0
 800661e:	f104 0619 	add.w	r6, r4, #25
 8006622:	e7f5      	b.n	8006610 <_printf_i+0x230>
 8006624:	080069b5 	.word	0x080069b5
 8006628:	080069c6 	.word	0x080069c6

0800662c <_sbrk_r>:
 800662c:	b538      	push	{r3, r4, r5, lr}
 800662e:	2300      	movs	r3, #0
 8006630:	4d05      	ldr	r5, [pc, #20]	; (8006648 <_sbrk_r+0x1c>)
 8006632:	4604      	mov	r4, r0
 8006634:	4608      	mov	r0, r1
 8006636:	602b      	str	r3, [r5, #0]
 8006638:	f7fa f95e 	bl	80008f8 <_sbrk>
 800663c:	1c43      	adds	r3, r0, #1
 800663e:	d102      	bne.n	8006646 <_sbrk_r+0x1a>
 8006640:	682b      	ldr	r3, [r5, #0]
 8006642:	b103      	cbz	r3, 8006646 <_sbrk_r+0x1a>
 8006644:	6023      	str	r3, [r4, #0]
 8006646:	bd38      	pop	{r3, r4, r5, pc}
 8006648:	20001020 	.word	0x20001020

0800664c <__sread>:
 800664c:	b510      	push	{r4, lr}
 800664e:	460c      	mov	r4, r1
 8006650:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8006654:	f000 f8ae 	bl	80067b4 <_read_r>
 8006658:	2800      	cmp	r0, #0
 800665a:	bfab      	itete	ge
 800665c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800665e:	89a3      	ldrhlt	r3, [r4, #12]
 8006660:	181b      	addge	r3, r3, r0
 8006662:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8006666:	bfac      	ite	ge
 8006668:	6563      	strge	r3, [r4, #84]	; 0x54
 800666a:	81a3      	strhlt	r3, [r4, #12]
 800666c:	bd10      	pop	{r4, pc}

0800666e <__swrite>:
 800666e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006672:	461f      	mov	r7, r3
 8006674:	898b      	ldrh	r3, [r1, #12]
 8006676:	4605      	mov	r5, r0
 8006678:	05db      	lsls	r3, r3, #23
 800667a:	460c      	mov	r4, r1
 800667c:	4616      	mov	r6, r2
 800667e:	d505      	bpl.n	800668c <__swrite+0x1e>
 8006680:	2302      	movs	r3, #2
 8006682:	2200      	movs	r2, #0
 8006684:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8006688:	f000 f868 	bl	800675c <_lseek_r>
 800668c:	89a3      	ldrh	r3, [r4, #12]
 800668e:	4632      	mov	r2, r6
 8006690:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8006694:	81a3      	strh	r3, [r4, #12]
 8006696:	4628      	mov	r0, r5
 8006698:	463b      	mov	r3, r7
 800669a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800669e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80066a2:	f000 b817 	b.w	80066d4 <_write_r>

080066a6 <__sseek>:
 80066a6:	b510      	push	{r4, lr}
 80066a8:	460c      	mov	r4, r1
 80066aa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80066ae:	f000 f855 	bl	800675c <_lseek_r>
 80066b2:	1c43      	adds	r3, r0, #1
 80066b4:	89a3      	ldrh	r3, [r4, #12]
 80066b6:	bf15      	itete	ne
 80066b8:	6560      	strne	r0, [r4, #84]	; 0x54
 80066ba:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80066be:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80066c2:	81a3      	strheq	r3, [r4, #12]
 80066c4:	bf18      	it	ne
 80066c6:	81a3      	strhne	r3, [r4, #12]
 80066c8:	bd10      	pop	{r4, pc}

080066ca <__sclose>:
 80066ca:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80066ce:	f000 b813 	b.w	80066f8 <_close_r>
	...

080066d4 <_write_r>:
 80066d4:	b538      	push	{r3, r4, r5, lr}
 80066d6:	4604      	mov	r4, r0
 80066d8:	4608      	mov	r0, r1
 80066da:	4611      	mov	r1, r2
 80066dc:	2200      	movs	r2, #0
 80066de:	4d05      	ldr	r5, [pc, #20]	; (80066f4 <_write_r+0x20>)
 80066e0:	602a      	str	r2, [r5, #0]
 80066e2:	461a      	mov	r2, r3
 80066e4:	f7fa f8ec 	bl	80008c0 <_write>
 80066e8:	1c43      	adds	r3, r0, #1
 80066ea:	d102      	bne.n	80066f2 <_write_r+0x1e>
 80066ec:	682b      	ldr	r3, [r5, #0]
 80066ee:	b103      	cbz	r3, 80066f2 <_write_r+0x1e>
 80066f0:	6023      	str	r3, [r4, #0]
 80066f2:	bd38      	pop	{r3, r4, r5, pc}
 80066f4:	20001020 	.word	0x20001020

080066f8 <_close_r>:
 80066f8:	b538      	push	{r3, r4, r5, lr}
 80066fa:	2300      	movs	r3, #0
 80066fc:	4d05      	ldr	r5, [pc, #20]	; (8006714 <_close_r+0x1c>)
 80066fe:	4604      	mov	r4, r0
 8006700:	4608      	mov	r0, r1
 8006702:	602b      	str	r3, [r5, #0]
 8006704:	f7fa f8ea 	bl	80008dc <_close>
 8006708:	1c43      	adds	r3, r0, #1
 800670a:	d102      	bne.n	8006712 <_close_r+0x1a>
 800670c:	682b      	ldr	r3, [r5, #0]
 800670e:	b103      	cbz	r3, 8006712 <_close_r+0x1a>
 8006710:	6023      	str	r3, [r4, #0]
 8006712:	bd38      	pop	{r3, r4, r5, pc}
 8006714:	20001020 	.word	0x20001020

08006718 <_fstat_r>:
 8006718:	b538      	push	{r3, r4, r5, lr}
 800671a:	2300      	movs	r3, #0
 800671c:	4d06      	ldr	r5, [pc, #24]	; (8006738 <_fstat_r+0x20>)
 800671e:	4604      	mov	r4, r0
 8006720:	4608      	mov	r0, r1
 8006722:	4611      	mov	r1, r2
 8006724:	602b      	str	r3, [r5, #0]
 8006726:	f7fa f8dd 	bl	80008e4 <_fstat>
 800672a:	1c43      	adds	r3, r0, #1
 800672c:	d102      	bne.n	8006734 <_fstat_r+0x1c>
 800672e:	682b      	ldr	r3, [r5, #0]
 8006730:	b103      	cbz	r3, 8006734 <_fstat_r+0x1c>
 8006732:	6023      	str	r3, [r4, #0]
 8006734:	bd38      	pop	{r3, r4, r5, pc}
 8006736:	bf00      	nop
 8006738:	20001020 	.word	0x20001020

0800673c <_isatty_r>:
 800673c:	b538      	push	{r3, r4, r5, lr}
 800673e:	2300      	movs	r3, #0
 8006740:	4d05      	ldr	r5, [pc, #20]	; (8006758 <_isatty_r+0x1c>)
 8006742:	4604      	mov	r4, r0
 8006744:	4608      	mov	r0, r1
 8006746:	602b      	str	r3, [r5, #0]
 8006748:	f7fa f8d2 	bl	80008f0 <_isatty>
 800674c:	1c43      	adds	r3, r0, #1
 800674e:	d102      	bne.n	8006756 <_isatty_r+0x1a>
 8006750:	682b      	ldr	r3, [r5, #0]
 8006752:	b103      	cbz	r3, 8006756 <_isatty_r+0x1a>
 8006754:	6023      	str	r3, [r4, #0]
 8006756:	bd38      	pop	{r3, r4, r5, pc}
 8006758:	20001020 	.word	0x20001020

0800675c <_lseek_r>:
 800675c:	b538      	push	{r3, r4, r5, lr}
 800675e:	4604      	mov	r4, r0
 8006760:	4608      	mov	r0, r1
 8006762:	4611      	mov	r1, r2
 8006764:	2200      	movs	r2, #0
 8006766:	4d05      	ldr	r5, [pc, #20]	; (800677c <_lseek_r+0x20>)
 8006768:	602a      	str	r2, [r5, #0]
 800676a:	461a      	mov	r2, r3
 800676c:	f7fa f8c2 	bl	80008f4 <_lseek>
 8006770:	1c43      	adds	r3, r0, #1
 8006772:	d102      	bne.n	800677a <_lseek_r+0x1e>
 8006774:	682b      	ldr	r3, [r5, #0]
 8006776:	b103      	cbz	r3, 800677a <_lseek_r+0x1e>
 8006778:	6023      	str	r3, [r4, #0]
 800677a:	bd38      	pop	{r3, r4, r5, pc}
 800677c:	20001020 	.word	0x20001020

08006780 <memchr>:
 8006780:	4603      	mov	r3, r0
 8006782:	b510      	push	{r4, lr}
 8006784:	b2c9      	uxtb	r1, r1
 8006786:	4402      	add	r2, r0
 8006788:	4293      	cmp	r3, r2
 800678a:	4618      	mov	r0, r3
 800678c:	d101      	bne.n	8006792 <memchr+0x12>
 800678e:	2000      	movs	r0, #0
 8006790:	e003      	b.n	800679a <memchr+0x1a>
 8006792:	7804      	ldrb	r4, [r0, #0]
 8006794:	3301      	adds	r3, #1
 8006796:	428c      	cmp	r4, r1
 8006798:	d1f6      	bne.n	8006788 <memchr+0x8>
 800679a:	bd10      	pop	{r4, pc}

0800679c <__malloc_lock>:
 800679c:	4801      	ldr	r0, [pc, #4]	; (80067a4 <__malloc_lock+0x8>)
 800679e:	f7ff bb13 	b.w	8005dc8 <__retarget_lock_acquire_recursive>
 80067a2:	bf00      	nop
 80067a4:	20001014 	.word	0x20001014

080067a8 <__malloc_unlock>:
 80067a8:	4801      	ldr	r0, [pc, #4]	; (80067b0 <__malloc_unlock+0x8>)
 80067aa:	f7ff bb0e 	b.w	8005dca <__retarget_lock_release_recursive>
 80067ae:	bf00      	nop
 80067b0:	20001014 	.word	0x20001014

080067b4 <_read_r>:
 80067b4:	b538      	push	{r3, r4, r5, lr}
 80067b6:	4604      	mov	r4, r0
 80067b8:	4608      	mov	r0, r1
 80067ba:	4611      	mov	r1, r2
 80067bc:	2200      	movs	r2, #0
 80067be:	4d05      	ldr	r5, [pc, #20]	; (80067d4 <_read_r+0x20>)
 80067c0:	602a      	str	r2, [r5, #0]
 80067c2:	461a      	mov	r2, r3
 80067c4:	f7fa f86e 	bl	80008a4 <_read>
 80067c8:	1c43      	adds	r3, r0, #1
 80067ca:	d102      	bne.n	80067d2 <_read_r+0x1e>
 80067cc:	682b      	ldr	r3, [r5, #0]
 80067ce:	b103      	cbz	r3, 80067d2 <_read_r+0x1e>
 80067d0:	6023      	str	r3, [r4, #0]
 80067d2:	bd38      	pop	{r3, r4, r5, pc}
 80067d4:	20001020 	.word	0x20001020

080067d8 <_init>:
 80067d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80067da:	bf00      	nop
 80067dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80067de:	bc08      	pop	{r3}
 80067e0:	469e      	mov	lr, r3
 80067e2:	4770      	bx	lr

080067e4 <_fini>:
 80067e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80067e6:	bf00      	nop
 80067e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80067ea:	bc08      	pop	{r3}
 80067ec:	469e      	mov	lr, r3
 80067ee:	4770      	bx	lr
